; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\dap.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\dap.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\dap.crf CMSIS-DAP\DAP.c]
                          THUMB

                          AREA ||i.DAP_Connect||, CODE, READONLY, ALIGN=2

                  DAP_Connect PROC
;;;220    //             number of bytes in request (upper 16 bits)
;;;221    static uint32_t DAP_Connect(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;222      uint32_t port;
;;;223    
;;;224      if (*request == DAP_PORT_AUTODETECT) {
000006  7828              LDRB     r0,[r5,#0]
000008  b908              CBNZ     r0,|L1.14|
;;;225        port = DAP_DEFAULT_PORT;
00000a  2401              MOVS     r4,#1
00000c  e000              B        |L1.16|
                  |L1.14|
;;;226      } else {
;;;227        port = *request;
00000e  782c              LDRB     r4,[r5,#0]
                  |L1.16|
;;;228      }
;;;229      
;;;230      switch (port) {
000010  2c01              CMP      r4,#1
000012  d002              BEQ      |L1.26|
000014  2c02              CMP      r4,#2
000016  d10c              BNE      |L1.50|
000018  e005              B        |L1.38|
                  |L1.26|
;;;231    #if (DAP_SWD != 0)
;;;232        case DAP_PORT_SWD:
;;;233          DAP_Data.debug_port = DAP_PORT_SWD;
00001a  2001              MOVS     r0,#1
00001c  4908              LDR      r1,|L1.64|
00001e  7008              STRB     r0,[r1,#0]
;;;234          PORT_SWD_SETUP();
000020  f7fffffe          BL       PORT_SWD_SETUP
;;;235          break;
000024  e007              B        |L1.54|
                  |L1.38|
;;;236    #endif
;;;237    #if (DAP_JTAG != 0)
;;;238        case DAP_PORT_JTAG:
;;;239          DAP_Data.debug_port = DAP_PORT_JTAG;
000026  2002              MOVS     r0,#2
000028  4905              LDR      r1,|L1.64|
00002a  7008              STRB     r0,[r1,#0]
;;;240          PORT_JTAG_SETUP();
00002c  f7fffffe          BL       PORT_JTAG_SETUP
;;;241          break;
000030  e001              B        |L1.54|
                  |L1.50|
;;;242    #endif
;;;243        default:
;;;244          port = DAP_PORT_DISABLED;
000032  2400              MOVS     r4,#0
;;;245          break;
000034  bf00              NOP      
                  |L1.54|
000036  bf00              NOP                            ;235
;;;246      }
;;;247    
;;;248      *response = (uint8_t)port;
000038  7034              STRB     r4,[r6,#0]
;;;249      return ((1U << 16) | 1U);
00003a  f04f1001          MOV      r0,#0x10001
;;;250    }
00003e  bd70              POP      {r4-r6,pc}
;;;251    
                          ENDP

                  |L1.64|
                          DCD      DAP_Data

                          AREA ||i.DAP_Delay||, CODE, READONLY, ALIGN=2

                  DAP_Delay PROC
;;;177    //             number of bytes in request (upper 16 bits)
;;;178    static uint32_t DAP_Delay(const uint8_t *request, uint8_t *response) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
000004  460b              MOV      r3,r1
;;;179      uint32_t delay;
;;;180    
;;;181      delay  = (uint32_t)(*(request+0)) |
000006  7810              LDRB     r0,[r2,#0]
000008  7854              LDRB     r4,[r2,#1]
00000a  ea402104          ORR      r1,r0,r4,LSL #8
;;;182               (uint32_t)(*(request+1) << 8);
;;;183      delay *= ((CPU_CLOCK/1000000U) + (DELAY_SLOW_CYCLES-1U)) / DELAY_SLOW_CYCLES;
00000e  480b              LDR      r0,|L2.60|
000010  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000012  4c0b              LDR      r4,|L2.64|
000014  fbb0f0f4          UDIV     r0,r0,r4
000018  1c80              ADDS     r0,r0,#2
00001a  2403              MOVS     r4,#3
00001c  fbb0f0f4          UDIV     r0,r0,r4
000020  4341              MULS     r1,r0,r1
;;;184    
;;;185      PIN_DELAY_SLOW(delay);
000022  4608              MOV      r0,r1
000024  4604              MOV      r4,r0
000026  bf00              NOP      
000028  bf00              NOP      
                  |L2.42|
00002a  1e65              SUBS     r5,r4,#1
00002c  1e2c              SUBS     r4,r5,#0
00002e  d1fc              BNE      |L2.42|
000030  bf00              NOP      
;;;186    
;;;187      *response = DAP_OK;
000032  2000              MOVS     r0,#0
000034  7018              STRB     r0,[r3,#0]
;;;188      return ((2U << 16) | 1U);
000036  4803              LDR      r0,|L2.68|
;;;189    }
000038  bd30              POP      {r4,r5,pc}
;;;190    
                          ENDP

00003a  0000              DCW      0x0000
                  |L2.60|
                          DCD      SystemCoreClock
                  |L2.64|
                          DCD      0x000f4240
                  |L2.68|
                          DCD      0x00020001

                          AREA ||i.DAP_Disconnect||, CODE, READONLY, ALIGN=2

                  DAP_Disconnect PROC
;;;255    //   return:   number of bytes in response
;;;256    static uint32_t DAP_Disconnect(uint8_t *response) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;257    
;;;258      DAP_Data.debug_port = DAP_PORT_DISABLED;
000004  2000              MOVS     r0,#0
000006  4904              LDR      r1,|L3.24|
000008  7008              STRB     r0,[r1,#0]
;;;259      PORT_OFF();
00000a  f7fffffe          BL       PORT_OFF
;;;260    
;;;261      *response = DAP_OK;
00000e  2000              MOVS     r0,#0
000010  7020              STRB     r0,[r4,#0]
;;;262      return (1U);
000012  2001              MOVS     r0,#1
;;;263    }
000014  bd10              POP      {r4,pc}
;;;264    
                          ENDP

000016  0000              DCW      0x0000
                  |L3.24|
                          DCD      DAP_Data

                          AREA ||i.DAP_Dummy_Transfer||, CODE, READONLY, ALIGN=1

                  DAP_Dummy_Transfer PROC
;;;1218   //             number of bytes in request (upper 16 bits)
;;;1219   static uint32_t DAP_Dummy_Transfer(const uint8_t *request, uint8_t *response) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
;;;1220     const
;;;1221     uint8_t  *request_head;
;;;1222     uint32_t  request_count;
;;;1223     uint32_t  request_value;
;;;1224   
;;;1225     request_head  =  request;
000004  4615              MOV      r5,r2
;;;1226   
;;;1227     request++;            // Ignore DAP index
000006  1c52              ADDS     r2,r2,#1
;;;1228   
;;;1229     request_count = *request++;
000008  f8124b01          LDRB     r4,[r2],#1
;;;1230   
;;;1231     for (; request_count != 0U; request_count--) {
00000c  e00b              B        |L4.38|
                  |L4.14|
;;;1232       // Process dummy requests
;;;1233       request_value = *request++;
00000e  f8123b01          LDRB     r3,[r2],#1
;;;1234       if ((request_value & DAP_TRANSFER_RnW) != 0U) {
000012  f0030002          AND      r0,r3,#2
000016  b120              CBZ      r0,|L4.34|
;;;1235         // Read register
;;;1236         if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
000018  f0030010          AND      r0,r3,#0x10
00001c  b110              CBZ      r0,|L4.36|
;;;1237           // Read with value match
;;;1238           request += 4;
00001e  1d12              ADDS     r2,r2,#4
000020  e000              B        |L4.36|
                  |L4.34|
;;;1239         }
;;;1240       } else {
;;;1241         // Write register
;;;1242         request += 4;
000022  1d12              ADDS     r2,r2,#4
                  |L4.36|
000024  1e64              SUBS     r4,r4,#1              ;1231
                  |L4.38|
000026  2c00              CMP      r4,#0                 ;1231
000028  d1f1              BNE      |L4.14|
;;;1243       }
;;;1244     }
;;;1245   
;;;1246     *(response+0) = 0U;   // Response count
00002a  2000              MOVS     r0,#0
00002c  7008              STRB     r0,[r1,#0]
;;;1247     *(response+1) = 0U;   // Response value
00002e  7048              STRB     r0,[r1,#1]
;;;1248   
;;;1249     return (((uint32_t)(request - request_head) << 16) | 2U);
000030  1b50              SUBS     r0,r2,r5
000032  0400              LSLS     r0,r0,#16
000034  1c80              ADDS     r0,r0,#2
;;;1250   }
000036  bd30              POP      {r4,r5,pc}
;;;1251   
                          ENDP


                          AREA ||i.DAP_ExecuteCommand||, CODE, READONLY, ALIGN=1

                  DAP_ExecuteCommand PROC
;;;1746   //             number of bytes in request (upper 16 bits)
;;;1747   uint32_t DAP_ExecuteCommand(const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1748     uint32_t cnt, num, n;
;;;1749   
;;;1750     if (*request == ID_DAP_ExecuteCommands) {
000008  7820              LDRB     r0,[r4,#0]
00000a  287f              CMP      r0,#0x7f
00000c  d11b              BNE      |L5.70|
;;;1751       *response++ = *request++;
00000e  f8140b01          LDRB     r0,[r4],#1
000012  f8050b01          STRB     r0,[r5],#1
;;;1752       cnt = *request++;
000016  f8147b01          LDRB     r7,[r4],#1
;;;1753       *response++ = (uint8_t)cnt;
00001a  f8057b01          STRB     r7,[r5],#1
;;;1754       num = (2U << 16) | 2U;
00001e  f04f1802          MOV      r8,#0x20002
;;;1755       while (cnt--) {
000022  e009              B        |L5.56|
                  |L5.36|
;;;1756         n = DAP_ProcessCommand(request, response);
000024  4629              MOV      r1,r5
000026  4620              MOV      r0,r4
000028  f7fffffe          BL       DAP_ProcessCommand
00002c  4606              MOV      r6,r0
;;;1757         num += n;
00002e  44b0              ADD      r8,r8,r6
;;;1758         request  += (uint16_t)(n >> 16);
000030  eb044416          ADD      r4,r4,r6,LSR #16
;;;1759         response += (uint16_t) n;  
000034  b2b0              UXTH     r0,r6
000036  4405              ADD      r5,r5,r0
                  |L5.56|
000038  1e38              SUBS     r0,r7,#0              ;1755
00003a  f1a70701          SUB      r7,r7,#1              ;1755
00003e  d1f1              BNE      |L5.36|
;;;1760       }
;;;1761       return (num);
000040  4640              MOV      r0,r8
                  |L5.66|
;;;1762     }
;;;1763   
;;;1764     return DAP_ProcessCommand(request, response);
;;;1765   }
000042  e8bd81f0          POP      {r4-r8,pc}
                  |L5.70|
000046  4629              MOV      r1,r5                 ;1764
000048  4620              MOV      r0,r4                 ;1764
00004a  f7fffffe          BL       DAP_ProcessCommand
00004e  e7f8              B        |L5.66|
;;;1766   
                          ENDP


                          AREA ||i.DAP_HostStatus||, CODE, READONLY, ALIGN=2

                  DAP_HostStatus PROC
;;;196    //             number of bytes in request (upper 16 bits)
;;;197    static uint32_t DAP_HostStatus(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;198    
;;;199      switch (*request) {
000006  7820              LDRB     r0,[r4,#0]
000008  b110              CBZ      r0,|L6.16|
00000a  2801              CMP      r0,#1
00000c  d110              BNE      |L6.48|
00000e  e007              B        |L6.32|
                  |L6.16|
;;;200        case DAP_DEBUGGER_CONNECTED:
;;;201          LED_CONNECTED_OUT((*(request+1) & 1U));
000010  7862              LDRB     r2,[r4,#1]
000012  f0020001          AND      r0,r2,#1
000016  4a0b              LDR      r2,|L6.68|
000018  6812              LDR      r2,[r2,#0]  ; pCoreDescriptor
00001a  6811              LDR      r1,[r2,#0]
00001c  4788              BLX      r1
;;;202          break;
00001e  e00b              B        |L6.56|
                  |L6.32|
;;;203        case DAP_TARGET_RUNNING:
;;;204          LED_RUNNING_OUT((*(request+1) & 1U));
000020  7862              LDRB     r2,[r4,#1]
000022  f0020001          AND      r0,r2,#1
000026  4a07              LDR      r2,|L6.68|
000028  6812              LDR      r2,[r2,#0]  ; pCoreDescriptor
00002a  6851              LDR      r1,[r2,#4]
00002c  4788              BLX      r1
;;;205          break;
00002e  e003              B        |L6.56|
                  |L6.48|
;;;206        default:
;;;207          *response = DAP_ERROR;
000030  20ff              MOVS     r0,#0xff
000032  7028              STRB     r0,[r5,#0]
;;;208          return ((2U << 16) | 1U);
000034  4804              LDR      r0,|L6.72|
                  |L6.54|
;;;209      }
;;;210    
;;;211      *response = DAP_OK;
;;;212      return ((2U << 16) | 1U);
;;;213    }
000036  bd70              POP      {r4-r6,pc}
                  |L6.56|
000038  bf00              NOP                            ;202
00003a  2000              MOVS     r0,#0                 ;211
00003c  7028              STRB     r0,[r5,#0]            ;211
00003e  4802              LDR      r0,|L6.72|
000040  e7f9              B        |L6.54|
;;;214    
                          ENDP

000042  0000              DCW      0x0000
                  |L6.68|
                          DCD      pCoreDescriptor
                  |L6.72|
                          DCD      0x00020001

                          AREA ||i.DAP_Info||, CODE, READONLY, ALIGN=2

                  DAP_Info PROC
;;;81     //   return:  number of bytes in info data
;;;82     static uint8_t DAP_Info(uint8_t id, uint8_t *info) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;83       uint8_t length = 0U;
000006  2500              MOVS     r5,#0
;;;84     
;;;85       switch (id) {
000008  2e06              CMP      r6,#6
00000a  d01f              BEQ      |L7.76|
00000c  dc06              BGT      |L7.28|
00000e  2e06              CMP      r6,#6
000010  d23c              BCS      |L7.140|
000012  e8dff006          TBB      [pc,r6]
000016  3b10              DCB      0x3b,0x10
000018  1112131a          DCB      0x11,0x12,0x13,0x1a
                  |L7.28|
00001c  2efd              CMP      r6,#0xfd
00001e  d022              BEQ      |L7.102|
000020  dc04              BGT      |L7.44|
000022  2ef0              CMP      r6,#0xf0
000024  d013              BEQ      |L7.78|
000026  2ef1              CMP      r6,#0xf1
000028  d130              BNE      |L7.140|
00002a  e01b              B        |L7.100|
                  |L7.44|
00002c  2efe              CMP      r6,#0xfe
00002e  d029              BEQ      |L7.132|
000030  2eff              CMP      r6,#0xff
000032  d12b              BNE      |L7.140|
000034  e020              B        |L7.120|
;;;86         case DAP_ID_VENDOR:
;;;87     #ifdef DAP_VENDOR
;;;88     			memcpy(info, DAP_Vendor, sizeof(DAP_Vendor));
;;;89     			length = sizeof(DAP_Vendor);
;;;90     #endif
;;;91           break;
000036  e02a              B        |L7.142|
;;;92         case DAP_ID_PRODUCT:
;;;93     #ifdef DAP_PRODUCT
;;;94     			memcpy(info, DAP_Product, sizeof(DAP_Product));
;;;95     			length = sizeof(DAP_Product);
;;;96     #endif
;;;97           break;
000038  e029              B        |L7.142|
;;;98         case DAP_ID_SER_NUM:
;;;99     #ifdef DAP_SER_NUM
;;;100    			memcpy(info, DAP_SerNum, sizeof(DAP_SerNum));
;;;101    			length = sizeof(DAP_SerNum);
;;;102    #endif
;;;103          break;
00003a  e028              B        |L7.142|
;;;104        case DAP_ID_FW_VER:
;;;105          length = (uint8_t)sizeof(DAP_FW_Ver);
00003c  2506              MOVS     r5,#6
;;;106          memcpy(info, DAP_FW_Ver, length);
00003e  462a              MOV      r2,r5
000040  4914              LDR      r1,|L7.148|
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       __aeabi_memcpy
;;;107          break;
000048  e021              B        |L7.142|
;;;108        case DAP_ID_DEVICE_VENDOR:
;;;109    #if TARGET_DEVICE_FIXED
;;;110          length = (uint8_t)sizeof(TargetDeviceVendor);
;;;111          memcpy(info, TargetDeviceVendor, length);
;;;112    #endif
;;;113          break;
00004a  e020              B        |L7.142|
                  |L7.76|
;;;114        case DAP_ID_DEVICE_NAME:
;;;115    #if TARGET_DEVICE_FIXED
;;;116          length = (uint8_t)sizeof(TargetDeviceName);
;;;117          memcpy(info, TargetDeviceName, length);
;;;118    #endif
;;;119          break;
00004c  e01f              B        |L7.142|
                  |L7.78|
;;;120        case DAP_ID_CAPABILITIES:
;;;121          info[0] = ((DAP_SWD  != 0)         ? (1U << 0) : 0U) |
00004e  4812              LDR      r0,|L7.152|
000050  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000052  b108              CBZ      r0,|L7.88|
;;;122                    ((DAP_JTAG != 0)         ? (1U << 1) : 0U) |
;;;123                    ((SWO_UART != 0)         ? (1U << 2) : 0U) |
;;;124                    ((SWO_MANCHESTER != 0)   ? (1U << 3) : 0U) |
;;;125                    /* Atomic Commands  */     (1U << 4)       |
;;;126                    ((TIMESTAMP_CLOCK != 0U) ? (1U << 5) : 0U) |
000054  2020              MOVS     r0,#0x20
000056  e000              B        |L7.90|
                  |L7.88|
000058  2000              MOVS     r0,#0
                  |L7.90|
00005a  f0400017          ORR      r0,r0,#0x17
00005e  7020              STRB     r0,[r4,#0]
;;;127                    ((SWO_STREAM != 0U)      ? (1U << 6) : 0U);
;;;128          length = 1U;
000060  2501              MOVS     r5,#1
;;;129          break;
000062  e014              B        |L7.142|
                  |L7.100|
;;;130        case DAP_ID_TIMESTAMP_CLOCK:
;;;131    #if (TIMESTAMP_CLOCK != 0U) 
;;;132          info[0] = (uint8_t)(TIMESTAMP_CLOCK >>  0);
;;;133          info[1] = (uint8_t)(TIMESTAMP_CLOCK >>  8);
;;;134          info[2] = (uint8_t)(TIMESTAMP_CLOCK >> 16);
;;;135          info[3] = (uint8_t)(TIMESTAMP_CLOCK >> 24);
;;;136          length = 4U;
;;;137    #endif
;;;138          break;
000064  e013              B        |L7.142|
                  |L7.102|
;;;139        case DAP_ID_SWO_BUFFER_SIZE:
;;;140    #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;141          info[0] = (uint8_t)(SWO_BUFFER_SIZE >>  0);
000066  2000              MOVS     r0,#0
000068  7020              STRB     r0,[r4,#0]
;;;142          info[1] = (uint8_t)(SWO_BUFFER_SIZE >>  8);
00006a  2010              MOVS     r0,#0x10
00006c  7060              STRB     r0,[r4,#1]
;;;143          info[2] = (uint8_t)(SWO_BUFFER_SIZE >> 16);
00006e  2000              MOVS     r0,#0
000070  70a0              STRB     r0,[r4,#2]
;;;144          info[3] = (uint8_t)(SWO_BUFFER_SIZE >> 24);
000072  70e0              STRB     r0,[r4,#3]
;;;145          length = 4U;
000074  2504              MOVS     r5,#4
;;;146    #endif
;;;147          break;
000076  e00a              B        |L7.142|
                  |L7.120|
;;;148        case DAP_ID_PACKET_SIZE:
;;;149          info[0] = (uint8_t)(DAP_PACKET_SIZE >> 0);
000078  2040              MOVS     r0,#0x40
00007a  7020              STRB     r0,[r4,#0]
;;;150          info[1] = (uint8_t)(DAP_PACKET_SIZE >> 8);
00007c  2000              MOVS     r0,#0
00007e  7060              STRB     r0,[r4,#1]
;;;151          length = 2U;
000080  2502              MOVS     r5,#2
;;;152          break;
000082  e004              B        |L7.142|
                  |L7.132|
;;;153        case DAP_ID_PACKET_COUNT:
;;;154          info[0] = DAP_PACKET_COUNT;
000084  2040              MOVS     r0,#0x40
000086  7020              STRB     r0,[r4,#0]
;;;155          length = 1U;
000088  2501              MOVS     r5,#1
;;;156          break;
00008a  e000              B        |L7.142|
                  |L7.140|
;;;157        default:
;;;158          break;
00008c  bf00              NOP      
                  |L7.142|
00008e  bf00              NOP                            ;91
;;;159      }
;;;160    
;;;161      return (length);
000090  4628              MOV      r0,r5
;;;162    }
000092  bd70              POP      {r4-r6,pc}
;;;163    
                          ENDP

                  |L7.148|
                          DCD      DAP_FW_Ver
                  |L7.152|
                          DCD      SystemCoreClock

                          AREA ||i.DAP_JTAG_Configure||, CODE, READONLY, ALIGN=2

                  DAP_JTAG_Configure PROC
;;;578    //             number of bytes in request (upper 16 bits)
;;;579    static uint32_t DAP_JTAG_Configure(const uint8_t *request, uint8_t *response) {
000000  b5f0              PUSH     {r4-r7,lr}
000002  4602              MOV      r2,r0
000004  460e              MOV      r6,r1
;;;580      uint32_t count;
;;;581    #if (DAP_JTAG != 0)
;;;582      uint32_t length;
;;;583      uint32_t bits;
;;;584      uint32_t n;
;;;585    
;;;586      count = *request++;
000006  f8123b01          LDRB     r3,[r2],#1
;;;587      DAP_Data.jtag_dev.count = (uint8_t)count;
00000a  4812              LDR      r0,|L8.84|
00000c  7683              STRB     r3,[r0,#0x1a]
;;;588    
;;;589      bits = 0U;
00000e  2500              MOVS     r5,#0
;;;590      for (n = 0U; n < count; n++) {
000010  2100              MOVS     r1,#0
000012  e009              B        |L8.40|
                  |L8.20|
;;;591        length = *request++;
000014  f8124b01          LDRB     r4,[r2],#1
;;;592        DAP_Data.jtag_dev.ir_length[n] =  (uint8_t)length;
000018  480e              LDR      r0,|L8.84|
00001a  301c              ADDS     r0,r0,#0x1c
00001c  5444              STRB     r4,[r0,r1]
;;;593        DAP_Data.jtag_dev.ir_before[n] = (uint16_t)bits;
00001e  3008              ADDS     r0,r0,#8
000020  f8205011          STRH     r5,[r0,r1,LSL #1]
;;;594        bits += length;
000024  4425              ADD      r5,r5,r4
000026  1c49              ADDS     r1,r1,#1              ;590
                  |L8.40|
000028  4299              CMP      r1,r3                 ;590
00002a  d3f3              BCC      |L8.20|
;;;595      }
;;;596      for (n = 0U; n < count; n++) {
00002c  2100              MOVS     r1,#0
00002e  e008              B        |L8.66|
                  |L8.48|
;;;597        bits -= DAP_Data.jtag_dev.ir_length[n];
000030  4808              LDR      r0,|L8.84|
000032  301c              ADDS     r0,r0,#0x1c
000034  5c40              LDRB     r0,[r0,r1]
000036  1a2d              SUBS     r5,r5,r0
;;;598        DAP_Data.jtag_dev.ir_after[n] = (uint16_t)bits;
000038  4806              LDR      r0,|L8.84|
00003a  3034              ADDS     r0,r0,#0x34
00003c  f8205011          STRH     r5,[r0,r1,LSL #1]
000040  1c49              ADDS     r1,r1,#1              ;596
                  |L8.66|
000042  4299              CMP      r1,r3                 ;596
000044  d3f4              BCC      |L8.48|
;;;599      }
;;;600    
;;;601      *response = DAP_OK;
000046  2000              MOVS     r0,#0
000048  7030              STRB     r0,[r6,#0]
;;;602    #else
;;;603      count = *request;
;;;604      *response = DAP_ERROR;
;;;605    #endif
;;;606    
;;;607      return (((count + 1U) << 16) | 1U);
00004a  1c58              ADDS     r0,r3,#1
00004c  0400              LSLS     r0,r0,#16
00004e  1c40              ADDS     r0,r0,#1
;;;608    }
000050  bdf0              POP      {r4-r7,pc}
;;;609    
                          ENDP

000052  0000              DCW      0x0000
                  |L8.84|
                          DCD      DAP_Data

                          AREA ||i.DAP_JTAG_IDCode||, CODE, READONLY, ALIGN=2

                  DAP_JTAG_IDCode PROC
;;;615    //             number of bytes in request (upper 16 bits)
;;;616    static uint32_t DAP_JTAG_IDCode(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;617    #if (DAP_JTAG != 0)
;;;618      uint32_t data;
;;;619    
;;;620      if (DAP_Data.debug_port != DAP_PORT_JTAG) {
000006  4812              LDR      r0,|L9.80|
000008  7800              LDRB     r0,[r0,#0]  ; DAP_Data
00000a  2802              CMP      r0,#2
00000c  d000              BEQ      |L9.16|
;;;621        goto id_error;
00000e  e019              B        |L9.68|
                  |L9.16|
;;;622      }
;;;623    
;;;624      // Device index (JTAP TAP)
;;;625      DAP_Data.jtag_dev.index = *request;
000010  7831              LDRB     r1,[r6,#0]
000012  480f              LDR      r0,|L9.80|
000014  76c1              STRB     r1,[r0,#0x1b]
;;;626      if (DAP_Data.jtag_dev.index >= DAP_Data.jtag_dev.count) {
000016  7ec0              LDRB     r0,[r0,#0x1b]
000018  490d              LDR      r1,|L9.80|
00001a  7e89              LDRB     r1,[r1,#0x1a]  ; DAP_Data
00001c  4288              CMP      r0,r1
00001e  db00              BLT      |L9.34|
;;;627        goto id_error;
000020  e010              B        |L9.68|
                  |L9.34|
;;;628      }
;;;629    
;;;630      // Select JTAG chain
;;;631      JTAG_IR(JTAG_IDCODE);
000022  200e              MOVS     r0,#0xe
000024  f7fffffe          BL       JTAG_IR
;;;632    
;;;633      // Read IDCODE register
;;;634      data = JTAG_ReadIDCode();
000028  f7fffffe          BL       JTAG_ReadIDCode
00002c  4605              MOV      r5,r0
;;;635    
;;;636      // Store Data
;;;637      *(response+0) =  DAP_OK;
00002e  2000              MOVS     r0,#0
000030  7020              STRB     r0,[r4,#0]
;;;638      *(response+1) = (uint8_t)(data >>  0);
000032  7065              STRB     r5,[r4,#1]
;;;639      *(response+2) = (uint8_t)(data >>  8);
000034  0a28              LSRS     r0,r5,#8
000036  70a0              STRB     r0,[r4,#2]
;;;640      *(response+3) = (uint8_t)(data >> 16);
000038  0c28              LSRS     r0,r5,#16
00003a  70e0              STRB     r0,[r4,#3]
;;;641      *(response+4) = (uint8_t)(data >> 24);
00003c  0e28              LSRS     r0,r5,#24
00003e  7120              STRB     r0,[r4,#4]
;;;642    
;;;643      return ((1U << 16) | 5U);
000040  4804              LDR      r0,|L9.84|
                  |L9.66|
;;;644    
;;;645    id_error:
;;;646    #endif
;;;647      *response = DAP_ERROR;
;;;648      return ((1U << 16) | 1U); 
;;;649    }
000042  bd70              POP      {r4-r6,pc}
                  |L9.68|
000044  20ff              MOVS     r0,#0xff              ;647
000046  7020              STRB     r0,[r4,#0]            ;647
000048  f04f1001          MOV      r0,#0x10001           ;648
00004c  e7f9              B        |L9.66|
;;;650    
                          ENDP

00004e  0000              DCW      0x0000
                  |L9.80|
                          DCD      DAP_Data
                  |L9.84|
                          DCD      0x00010005

                          AREA ||i.DAP_JTAG_Sequence||, CODE, READONLY, ALIGN=1

                  DAP_JTAG_Sequence PROC
;;;533    //             number of bytes in request (upper 16 bits)
;;;534    static uint32_t DAP_JTAG_Sequence(const uint8_t *request, uint8_t *response) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;535      uint32_t sequence_info;
;;;536      uint32_t sequence_count;
;;;537      uint32_t request_count;
;;;538      uint32_t response_count;
;;;539      uint32_t count;
;;;540    
;;;541    #if (DAP_JTAG != 0)
;;;542      *response++ = DAP_OK;
000008  2000              MOVS     r0,#0
00000a  f8060b01          STRB     r0,[r6],#1
;;;543    #else
;;;544      *response++ = DAP_ERROR;
;;;545    #endif
;;;546      request_count  = 1U;
00000e  f04f0801          MOV      r8,#1
;;;547      response_count = 1U;
000012  f04f0901          MOV      r9,#1
;;;548    
;;;549      sequence_count = *request++;
000016  f814ab01          LDRB     r10,[r4],#1
;;;550      while (sequence_count--) {
00001a  e014              B        |L10.70|
                  |L10.28|
;;;551        sequence_info = *request++;
00001c  f8147b01          LDRB     r7,[r4],#1
;;;552        count = sequence_info & JTAG_SEQUENCE_TCK;
000020  f007053f          AND      r5,r7,#0x3f
;;;553        if (count == 0U) {
000024  b905              CBNZ     r5,|L10.40|
;;;554          count = 64U;
000026  2540              MOVS     r5,#0x40
                  |L10.40|
;;;555        }
;;;556        count = (count + 7U) / 8U;
000028  1de8              ADDS     r0,r5,#7
00002a  08c5              LSRS     r5,r0,#3
;;;557    #if (DAP_JTAG != 0)
;;;558        JTAG_Sequence(sequence_info, request, response);
00002c  4632              MOV      r2,r6
00002e  4621              MOV      r1,r4
000030  4638              MOV      r0,r7
000032  f7fffffe          BL       JTAG_Sequence
;;;559    #endif
;;;560        request += count;
000036  442c              ADD      r4,r4,r5
;;;561        request_count += count + 1U;
000038  1c68              ADDS     r0,r5,#1
00003a  4480              ADD      r8,r8,r0
;;;562    #if (DAP_JTAG != 0)
;;;563        if ((sequence_info & JTAG_SEQUENCE_TDO) != 0U) {
00003c  f0070080          AND      r0,r7,#0x80
000040  b108              CBZ      r0,|L10.70|
;;;564          response += count;
000042  442e              ADD      r6,r6,r5
;;;565          response_count += count;
000044  44a9              ADD      r9,r9,r5
                  |L10.70|
000046  f1ba0000          SUBS     r0,r10,#0             ;550
00004a  f1aa0a01          SUB      r10,r10,#1            ;550
00004e  d1e5              BNE      |L10.28|
;;;566        }
;;;567    #endif
;;;568      }
;;;569    
;;;570      return ((request_count << 16) | response_count);
000050  ea494008          ORR      r0,r9,r8,LSL #16
;;;571    }
000054  e8bd87f0          POP      {r4-r10,pc}
;;;572    
                          ENDP


                          AREA ||i.DAP_JTAG_Transfer||, CODE, READONLY, ALIGN=2

                  DAP_JTAG_Transfer PROC
;;;944    #if (DAP_JTAG != 0)
;;;945    static uint32_t DAP_JTAG_Transfer(const uint8_t *request, uint8_t *response) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;946      const
;;;947      uint8_t  *request_head;
;;;948      uint32_t  request_count;
;;;949      uint32_t  request_value;
;;;950      uint32_t  request_ir;
;;;951      uint8_t  *response_head;
;;;952      uint32_t  response_count;
;;;953      uint32_t  response_value;
;;;954      uint32_t  post_read;
;;;955      uint32_t  match_value;
;;;956      uint32_t  match_retry;
;;;957      uint32_t  retry;
;;;958      uint32_t  data;
;;;959      uint32_t  ir;
;;;960    #if (TIMESTAMP_CLOCK != 0U)
;;;961      uint32_t  timestamp;
;;;962    #endif
;;;963    
;;;964      request_head   = request;
00000a  9506              STR      r5,[sp,#0x18]
;;;965    
;;;966      response_count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9004              STR      r0,[sp,#0x10]
;;;967      response_value = 0U;
000010  2600              MOVS     r6,#0
;;;968      response_head  = response;
000012  9405              STR      r4,[sp,#0x14]
;;;969      response      += 2;
000014  1ca4              ADDS     r4,r4,#2
;;;970    
;;;971      DAP_TransferAbort = 0U;
000016  49e4              LDR      r1,|L11.936|
000018  7008              STRB     r0,[r1,#0]
;;;972    
;;;973      ir        = 0U;
00001a  4681              MOV      r9,r0
;;;974      post_read = 0U;
00001c  9003              STR      r0,[sp,#0xc]
;;;975    
;;;976      // Device index (JTAP TAP)
;;;977      DAP_Data.jtag_dev.index = *request++;
00001e  f8151b01          LDRB     r1,[r5],#1
000022  48e2              LDR      r0,|L11.940|
000024  76c1              STRB     r1,[r0,#0x1b]
;;;978      if (DAP_Data.jtag_dev.index >= DAP_Data.jtag_dev.count) {
000026  7ec0              LDRB     r0,[r0,#0x1b]
000028  49e0              LDR      r1,|L11.940|
00002a  7e89              LDRB     r1,[r1,#0x1a]  ; DAP_Data
00002c  4288              CMP      r0,r1
00002e  db00              BLT      |L11.50|
;;;979        goto end;
000030  e1ab              B        |L11.906|
                  |L11.50|
;;;980      }
;;;981    
;;;982      request_count = *request++;
000032  f815bb01          LDRB     r11,[r5],#1
;;;983    
;;;984      for (; request_count != 0U; request_count--) {
000036  e14a              B        |L11.718|
                  |L11.56|
;;;985        request_value = *request++;
000038  f8157b01          LDRB     r7,[r5],#1
;;;986        request_ir = (request_value & DAP_TRANSFER_APnDP) ? JTAG_APACC : JTAG_DPACC;
00003c  f0070001          AND      r0,r7,#1
000040  b108              CBZ      r0,|L11.70|
000042  200b              MOVS     r0,#0xb
000044  e000              B        |L11.72|
                  |L11.70|
000046  200a              MOVS     r0,#0xa
                  |L11.72|
000048  4682              MOV      r10,r0
;;;987        if ((request_value & DAP_TRANSFER_RnW) != 0U) {
00004a  f0070002          AND      r0,r7,#2
00004e  2800              CMP      r0,#0
000050  d079              BEQ      |L11.326|
;;;988          // Read register
;;;989          if (post_read) {
000052  9803              LDR      r0,[sp,#0xc]
000054  2800              CMP      r0,#0
000056  d046              BEQ      |L11.230|
;;;990            // Read was posted before
;;;991            retry = DAP_Data.transfer.retry_count;
000058  48d4              LDR      r0,|L11.940|
00005a  f8b08010          LDRH     r8,[r0,#0x10]
;;;992            if ((ir == request_ir) && ((request_value & DAP_TRANSFER_MATCH_VALUE) == 0U)) {
00005e  45d1              CMP      r9,r10
000060  d114              BNE      |L11.140|
000062  f0070010          AND      r0,r7,#0x10
000066  b988              CBNZ     r0,|L11.140|
;;;993              // Read previous data and post next read
;;;994              do {
000068  bf00              NOP      
                  |L11.106|
;;;995                response_value = JTAG_Transfer(request_value, &data);
00006a  4669              MOV      r1,sp
00006c  4638              MOV      r0,r7
00006e  f7fffffe          BL       JTAG_Transfer
000072  4606              MOV      r6,r0
;;;996              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000074  2e02              CMP      r6,#2
000076  d124              BNE      |L11.194|
000078  f1b80000          SUBS     r0,r8,#0
00007c  f1a80801          SUB      r8,r8,#1
000080  d01f              BEQ      |L11.194|
000082  48c9              LDR      r0,|L11.936|
000084  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000086  2800              CMP      r0,#0
000088  d0ef              BEQ      |L11.106|
00008a  e01a              B        |L11.194|
                  |L11.140|
;;;997            } else {
;;;998              // Select JTAG chain
;;;999              if (ir != JTAG_DPACC) {
00008c  f1b90f0a          CMP      r9,#0xa
000090  d004              BEQ      |L11.156|
;;;1000               ir = JTAG_DPACC;
000092  f04f090a          MOV      r9,#0xa
;;;1001               JTAG_IR(ir);
000096  4648              MOV      r0,r9
000098  f7fffffe          BL       JTAG_IR
                  |L11.156|
;;;1002             }
;;;1003             // Read previous data
;;;1004             do {
00009c  bf00              NOP      
                  |L11.158|
;;;1005               response_value = JTAG_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
00009e  4669              MOV      r1,sp
0000a0  200e              MOVS     r0,#0xe
0000a2  f7fffffe          BL       JTAG_Transfer
0000a6  4606              MOV      r6,r0
;;;1006             } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000a8  2e02              CMP      r6,#2
0000aa  d108              BNE      |L11.190|
0000ac  f1b80000          SUBS     r0,r8,#0
0000b0  f1a80801          SUB      r8,r8,#1
0000b4  d003              BEQ      |L11.190|
0000b6  48bc              LDR      r0,|L11.936|
0000b8  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0000ba  2800              CMP      r0,#0
0000bc  d0ef              BEQ      |L11.158|
                  |L11.190|
;;;1007             post_read = 0U;
0000be  2000              MOVS     r0,#0
0000c0  9003              STR      r0,[sp,#0xc]
                  |L11.194|
;;;1008           }
;;;1009           if (response_value != DAP_TRANSFER_OK) {
0000c2  2e01              CMP      r6,#1
0000c4  d000              BEQ      |L11.200|
;;;1010             break;
0000c6  e106              B        |L11.726|
                  |L11.200|
;;;1011           }
;;;1012           // Store previous data
;;;1013           *response++ = (uint8_t) data;
0000c8  9800              LDR      r0,[sp,#0]
0000ca  f8040b01          STRB     r0,[r4],#1
;;;1014           *response++ = (uint8_t)(data >>  8);
0000ce  9800              LDR      r0,[sp,#0]
0000d0  0a00              LSRS     r0,r0,#8
0000d2  f8040b01          STRB     r0,[r4],#1
;;;1015           *response++ = (uint8_t)(data >> 16);
0000d6  9800              LDR      r0,[sp,#0]
0000d8  0c00              LSRS     r0,r0,#16
0000da  f8040b01          STRB     r0,[r4],#1
;;;1016           *response++ = (uint8_t)(data >> 24);
0000de  9800              LDR      r0,[sp,#0]
0000e0  0e00              LSRS     r0,r0,#24
0000e2  f8040b01          STRB     r0,[r4],#1
                  |L11.230|
;;;1017   #if (TIMESTAMP_CLOCK != 0U)
;;;1018           if (post_read) {
;;;1019             // Store Timestamp of next AP read
;;;1020             if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;1021               timestamp = DAP_Data.timestamp;
;;;1022               *response++ = (uint8_t) timestamp;
;;;1023               *response++ = (uint8_t)(timestamp >>  8);
;;;1024               *response++ = (uint8_t)(timestamp >> 16);
;;;1025               *response++ = (uint8_t)(timestamp >> 24);
;;;1026             }
;;;1027           }
;;;1028   #endif
;;;1029         }
;;;1030         if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
0000e6  f0070010          AND      r0,r7,#0x10
0000ea  2800              CMP      r0,#0
0000ec  d060              BEQ      |L11.432|
;;;1031           // Read with value match
;;;1032           match_value = (uint32_t)(*(request+0) <<  0) |
0000ee  7828              LDRB     r0,[r5,#0]
0000f0  7869              LDRB     r1,[r5,#1]
0000f2  ea402001          ORR      r0,r0,r1,LSL #8
0000f6  78a9              LDRB     r1,[r5,#2]
0000f8  ea404001          ORR      r0,r0,r1,LSL #16
0000fc  78e9              LDRB     r1,[r5,#3]
0000fe  ea406001          ORR      r0,r0,r1,LSL #24
000102  9002              STR      r0,[sp,#8]
;;;1033                         (uint32_t)(*(request+1) <<  8) |
;;;1034                         (uint32_t)(*(request+2) << 16) |
;;;1035                         (uint32_t)(*(request+3) << 24);
;;;1036           request += 4;
000104  1d2d              ADDS     r5,r5,#4
;;;1037           match_retry  = DAP_Data.transfer.match_retry;
000106  48a9              LDR      r0,|L11.940|
000108  8a40              LDRH     r0,[r0,#0x12]
00010a  9001              STR      r0,[sp,#4]
;;;1038           // Select JTAG chain
;;;1039           if (ir != request_ir) {
00010c  45d1              CMP      r9,r10
00010e  d003              BEQ      |L11.280|
;;;1040             ir = request_ir;
000110  46d1              MOV      r9,r10
;;;1041             JTAG_IR(ir);
000112  4648              MOV      r0,r9
000114  f7fffffe          BL       JTAG_IR
                  |L11.280|
;;;1042           }
;;;1043           // Post DP/AP read
;;;1044           retry = DAP_Data.transfer.retry_count;
000118  48a4              LDR      r0,|L11.940|
00011a  f8b08010          LDRH     r8,[r0,#0x10]
;;;1045           do {
00011e  bf00              NOP      
                  |L11.288|
;;;1046             response_value = JTAG_Transfer(request_value, NULL);
000120  2100              MOVS     r1,#0
000122  4638              MOV      r0,r7
000124  f7fffffe          BL       JTAG_Transfer
000128  4606              MOV      r6,r0
;;;1047           } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00012a  2e02              CMP      r6,#2
00012c  d108              BNE      |L11.320|
00012e  f1b80000          SUBS     r0,r8,#0
000132  f1a80801          SUB      r8,r8,#1
000136  d003              BEQ      |L11.320|
000138  489b              LDR      r0,|L11.936|
00013a  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00013c  2800              CMP      r0,#0
00013e  d0ef              BEQ      |L11.288|
                  |L11.320|
;;;1048           if (response_value != DAP_TRANSFER_OK) {
000140  2e01              CMP      r6,#1
000142  d001              BEQ      |L11.328|
;;;1049             break;
000144  e0c7              B        |L11.726|
                  |L11.326|
000146  e056              B        |L11.502|
                  |L11.328|
;;;1050           }
;;;1051           do {
000148  bf00              NOP      
                  |L11.330|
;;;1052             // Read register until its value matches or retry counter expires
;;;1053             retry = DAP_Data.transfer.retry_count;
00014a  4898              LDR      r0,|L11.940|
00014c  f8b08010          LDRH     r8,[r0,#0x10]
;;;1054             do {
000150  bf00              NOP      
                  |L11.338|
;;;1055               response_value = JTAG_Transfer(request_value, &data);
000152  4669              MOV      r1,sp
000154  4638              MOV      r0,r7
000156  f7fffffe          BL       JTAG_Transfer
00015a  4606              MOV      r6,r0
;;;1056             } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00015c  2e02              CMP      r6,#2
00015e  d108              BNE      |L11.370|
000160  f1b80000          SUBS     r0,r8,#0
000164  f1a80801          SUB      r8,r8,#1
000168  d003              BEQ      |L11.370|
00016a  488f              LDR      r0,|L11.936|
00016c  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00016e  2800              CMP      r0,#0
000170  d0ef              BEQ      |L11.338|
                  |L11.370|
;;;1057             if (response_value != DAP_TRANSFER_OK) {
000172  2e01              CMP      r6,#1
000174  d000              BEQ      |L11.376|
;;;1058               break;
000176  e00e              B        |L11.406|
                  |L11.376|
;;;1059             }
;;;1060           } while (((data & DAP_Data.transfer.match_mask) != match_value) && match_retry-- && !DAP_TransferAbort);
000178  488c              LDR      r0,|L11.940|
00017a  6940              LDR      r0,[r0,#0x14]
00017c  9900              LDR      r1,[sp,#0]
00017e  4008              ANDS     r0,r0,r1
000180  9902              LDR      r1,[sp,#8]
000182  4288              CMP      r0,r1
000184  d007              BEQ      |L11.406|
000186  9801              LDR      r0,[sp,#4]
000188  1e41              SUBS     r1,r0,#1
00018a  9101              STR      r1,[sp,#4]
00018c  b118              CBZ      r0,|L11.406|
00018e  4886              LDR      r0,|L11.936|
000190  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000192  2800              CMP      r0,#0
000194  d0d9              BEQ      |L11.330|
                  |L11.406|
000196  bf00              NOP                            ;1058
;;;1061           if ((data & DAP_Data.transfer.match_mask) != match_value) {
000198  4884              LDR      r0,|L11.940|
00019a  6940              LDR      r0,[r0,#0x14]
00019c  9900              LDR      r1,[sp,#0]
00019e  4008              ANDS     r0,r0,r1
0001a0  9902              LDR      r1,[sp,#8]
0001a2  4288              CMP      r0,r1
0001a4  d001              BEQ      |L11.426|
;;;1062             response_value |= DAP_TRANSFER_MISMATCH;
0001a6  f0460610          ORR      r6,r6,#0x10
                  |L11.426|
;;;1063           }
;;;1064           if (response_value != DAP_TRANSFER_OK) {
0001aa  2e01              CMP      r6,#1
0001ac  d022              BEQ      |L11.500|
;;;1065             break;
0001ae  e092              B        |L11.726|
                  |L11.432|
;;;1066           }
;;;1067         } else {
;;;1068           // Normal read
;;;1069           if (post_read == 0U) {
0001b0  9803              LDR      r0,[sp,#0xc]
0001b2  2800              CMP      r0,#0
0001b4  d11e              BNE      |L11.500|
;;;1070             // Select JTAG chain
;;;1071             if (ir != request_ir) {
0001b6  45d1              CMP      r9,r10
0001b8  d003              BEQ      |L11.450|
;;;1072               ir = request_ir;
0001ba  46d1              MOV      r9,r10
;;;1073               JTAG_IR(ir);
0001bc  4648              MOV      r0,r9
0001be  f7fffffe          BL       JTAG_IR
                  |L11.450|
;;;1074             }
;;;1075             // Post DP/AP read
;;;1076             retry = DAP_Data.transfer.retry_count;
0001c2  487a              LDR      r0,|L11.940|
0001c4  f8b08010          LDRH     r8,[r0,#0x10]
;;;1077             do {
0001c8  bf00              NOP      
                  |L11.458|
;;;1078               response_value = JTAG_Transfer(request_value, NULL);
0001ca  2100              MOVS     r1,#0
0001cc  4638              MOV      r0,r7
0001ce  f7fffffe          BL       JTAG_Transfer
0001d2  4606              MOV      r6,r0
;;;1079             } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0001d4  2e02              CMP      r6,#2
0001d6  d108              BNE      |L11.490|
0001d8  f1b80000          SUBS     r0,r8,#0
0001dc  f1a80801          SUB      r8,r8,#1
0001e0  d003              BEQ      |L11.490|
0001e2  4871              LDR      r0,|L11.936|
0001e4  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0001e6  2800              CMP      r0,#0
0001e8  d0ef              BEQ      |L11.458|
                  |L11.490|
;;;1080             if (response_value != DAP_TRANSFER_OK) {
0001ea  2e01              CMP      r6,#1
0001ec  d000              BEQ      |L11.496|
;;;1081               break;
0001ee  e072              B        |L11.726|
                  |L11.496|
;;;1082             }
;;;1083   #if (TIMESTAMP_CLOCK != 0U)
;;;1084             // Store Timestamp
;;;1085             if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;1086               timestamp = DAP_Data.timestamp;
;;;1087               *response++ = (uint8_t) timestamp;
;;;1088               *response++ = (uint8_t)(timestamp >>  8);
;;;1089               *response++ = (uint8_t)(timestamp >> 16);
;;;1090               *response++ = (uint8_t)(timestamp >> 24);
;;;1091             }
;;;1092   #endif
;;;1093             post_read = 1U;
0001f0  2001              MOVS     r0,#1
0001f2  9003              STR      r0,[sp,#0xc]
                  |L11.500|
0001f4  e062              B        |L11.700|
                  |L11.502|
;;;1094           }
;;;1095         }
;;;1096       } else {
;;;1097         // Write register
;;;1098         if (post_read) {
0001f6  9803              LDR      r0,[sp,#0xc]
0001f8  b378              CBZ      r0,|L11.602|
;;;1099           // Select JTAG chain
;;;1100           if (ir != JTAG_DPACC) {
0001fa  f1b90f0a          CMP      r9,#0xa
0001fe  d004              BEQ      |L11.522|
;;;1101             ir = JTAG_DPACC;
000200  f04f090a          MOV      r9,#0xa
;;;1102             JTAG_IR(ir);
000204  4648              MOV      r0,r9
000206  f7fffffe          BL       JTAG_IR
                  |L11.522|
;;;1103           }
;;;1104           // Read previous data
;;;1105           retry = DAP_Data.transfer.retry_count;
00020a  4868              LDR      r0,|L11.940|
00020c  f8b08010          LDRH     r8,[r0,#0x10]
;;;1106           do {
000210  bf00              NOP      
                  |L11.530|
;;;1107             response_value = JTAG_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000212  4669              MOV      r1,sp
000214  200e              MOVS     r0,#0xe
000216  f7fffffe          BL       JTAG_Transfer
00021a  4606              MOV      r6,r0
;;;1108           } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00021c  2e02              CMP      r6,#2
00021e  d108              BNE      |L11.562|
000220  f1b80000          SUBS     r0,r8,#0
000224  f1a80801          SUB      r8,r8,#1
000228  d003              BEQ      |L11.562|
00022a  485f              LDR      r0,|L11.936|
00022c  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00022e  2800              CMP      r0,#0
000230  d0ef              BEQ      |L11.530|
                  |L11.562|
;;;1109           if (response_value != DAP_TRANSFER_OK) {
000232  2e01              CMP      r6,#1
000234  d000              BEQ      |L11.568|
;;;1110             break;
000236  e04e              B        |L11.726|
                  |L11.568|
;;;1111           }
;;;1112           // Store previous data
;;;1113           *response++ = (uint8_t) data;
000238  9800              LDR      r0,[sp,#0]
00023a  f8040b01          STRB     r0,[r4],#1
;;;1114           *response++ = (uint8_t)(data >>  8);
00023e  9800              LDR      r0,[sp,#0]
000240  0a00              LSRS     r0,r0,#8
000242  f8040b01          STRB     r0,[r4],#1
;;;1115           *response++ = (uint8_t)(data >> 16);
000246  9800              LDR      r0,[sp,#0]
000248  0c00              LSRS     r0,r0,#16
00024a  f8040b01          STRB     r0,[r4],#1
;;;1116           *response++ = (uint8_t)(data >> 24);
00024e  9800              LDR      r0,[sp,#0]
000250  0e00              LSRS     r0,r0,#24
000252  f8040b01          STRB     r0,[r4],#1
;;;1117           post_read = 0U;
000256  2000              MOVS     r0,#0
000258  9003              STR      r0,[sp,#0xc]
                  |L11.602|
;;;1118         }
;;;1119         // Load data
;;;1120         data = (uint32_t)(*(request+0) <<  0) |
00025a  7828              LDRB     r0,[r5,#0]
00025c  7869              LDRB     r1,[r5,#1]
00025e  ea402001          ORR      r0,r0,r1,LSL #8
000262  78a9              LDRB     r1,[r5,#2]
000264  ea404001          ORR      r0,r0,r1,LSL #16
000268  78e9              LDRB     r1,[r5,#3]
00026a  ea406001          ORR      r0,r0,r1,LSL #24
00026e  9000              STR      r0,[sp,#0]
;;;1121                (uint32_t)(*(request+1) <<  8) |
;;;1122                (uint32_t)(*(request+2) << 16) |
;;;1123                (uint32_t)(*(request+3) << 24);
;;;1124         request += 4;
000270  1d2d              ADDS     r5,r5,#4
;;;1125         if ((request_value & DAP_TRANSFER_MATCH_MASK) != 0U) {
000272  f0070020          AND      r0,r7,#0x20
000276  b120              CBZ      r0,|L11.642|
;;;1126           // Write match mask
;;;1127           DAP_Data.transfer.match_mask = data;
000278  484c              LDR      r0,|L11.940|
00027a  9900              LDR      r1,[sp,#0]
00027c  6141              STR      r1,[r0,#0x14]
;;;1128           response_value = DAP_TRANSFER_OK;
00027e  2601              MOVS     r6,#1
000280  e01c              B        |L11.700|
                  |L11.642|
;;;1129         } else {
;;;1130           // Select JTAG chain
;;;1131           if (ir != request_ir) {
000282  45d1              CMP      r9,r10
000284  d003              BEQ      |L11.654|
;;;1132             ir = request_ir;
000286  46d1              MOV      r9,r10
;;;1133             JTAG_IR(ir);
000288  4648              MOV      r0,r9
00028a  f7fffffe          BL       JTAG_IR
                  |L11.654|
;;;1134           }
;;;1135           // Write DP/AP register
;;;1136           retry = DAP_Data.transfer.retry_count;
00028e  4847              LDR      r0,|L11.940|
000290  f8b08010          LDRH     r8,[r0,#0x10]
;;;1137           do {
000294  bf00              NOP      
                  |L11.662|
;;;1138             response_value = JTAG_Transfer(request_value, &data);
000296  4669              MOV      r1,sp
000298  4638              MOV      r0,r7
00029a  f7fffffe          BL       JTAG_Transfer
00029e  4606              MOV      r6,r0
;;;1139           } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0002a0  2e02              CMP      r6,#2
0002a2  d108              BNE      |L11.694|
0002a4  f1b80000          SUBS     r0,r8,#0
0002a8  f1a80801          SUB      r8,r8,#1
0002ac  d003              BEQ      |L11.694|
0002ae  483e              LDR      r0,|L11.936|
0002b0  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0002b2  2800              CMP      r0,#0
0002b4  d0ef              BEQ      |L11.662|
                  |L11.694|
;;;1140           if (response_value != DAP_TRANSFER_OK) {
0002b6  2e01              CMP      r6,#1
0002b8  d000              BEQ      |L11.700|
;;;1141             break;
0002ba  e00c              B        |L11.726|
                  |L11.700|
;;;1142           }
;;;1143   #if (TIMESTAMP_CLOCK != 0U)
;;;1144           // Store Timestamp
;;;1145           if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;1146             timestamp = DAP_Data.timestamp;
;;;1147             *response++ = (uint8_t) timestamp;
;;;1148             *response++ = (uint8_t)(timestamp >>  8);
;;;1149             *response++ = (uint8_t)(timestamp >> 16);
;;;1150             *response++ = (uint8_t)(timestamp >> 24);
;;;1151           }
;;;1152   #endif
;;;1153         }
;;;1154       }
;;;1155       response_count++;
0002bc  9804              LDR      r0,[sp,#0x10]
0002be  1c40              ADDS     r0,r0,#1
0002c0  9004              STR      r0,[sp,#0x10]
;;;1156       if (DAP_TransferAbort) {
0002c2  4839              LDR      r0,|L11.936|
0002c4  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0002c6  b100              CBZ      r0,|L11.714|
;;;1157         break;
0002c8  e005              B        |L11.726|
                  |L11.714|
0002ca  f1ab0b01          SUB      r11,r11,#1            ;984
                  |L11.718|
0002ce  f1bb0f00          CMP      r11,#0                ;984
0002d2  f47faeb1          BNE      |L11.56|
                  |L11.726|
0002d6  bf00              NOP                            ;1010
;;;1158       }
;;;1159     }
;;;1160   
;;;1161     for (; request_count != 0U; request_count--) {
0002d8  e00c              B        |L11.756|
                  |L11.730|
;;;1162       // Process canceled requests
;;;1163       request_value = *request++;
0002da  f8157b01          LDRB     r7,[r5],#1
;;;1164       if ((request_value & DAP_TRANSFER_RnW) != 0U) {
0002de  f0070002          AND      r0,r7,#2
0002e2  b120              CBZ      r0,|L11.750|
;;;1165         // Read register
;;;1166         if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
0002e4  f0070010          AND      r0,r7,#0x10
0002e8  b110              CBZ      r0,|L11.752|
;;;1167           // Read with value match
;;;1168           request += 4;
0002ea  1d2d              ADDS     r5,r5,#4
0002ec  e000              B        |L11.752|
                  |L11.750|
;;;1169         }
;;;1170       } else {
;;;1171         // Write register
;;;1172         request += 4;
0002ee  1d2d              ADDS     r5,r5,#4
                  |L11.752|
0002f0  f1ab0b01          SUB      r11,r11,#1            ;1161
                  |L11.756|
0002f4  f1bb0f00          CMP      r11,#0                ;1161
0002f8  d1ef              BNE      |L11.730|
;;;1173       }
;;;1174     }
;;;1175   
;;;1176     if (response_value == DAP_TRANSFER_OK) {
0002fa  2e01              CMP      r6,#1
0002fc  d144              BNE      |L11.904|
;;;1177       // Select JTAG chain
;;;1178       if (ir != JTAG_DPACC) {
0002fe  f1b90f0a          CMP      r9,#0xa
000302  d004              BEQ      |L11.782|
;;;1179         ir = JTAG_DPACC;
000304  f04f090a          MOV      r9,#0xa
;;;1180         JTAG_IR(ir);
000308  4648              MOV      r0,r9
00030a  f7fffffe          BL       JTAG_IR
                  |L11.782|
;;;1181       }
;;;1182       if (post_read) {
00030e  9803              LDR      r0,[sp,#0xc]
000310  b330              CBZ      r0,|L11.864|
;;;1183         // Read previous data
;;;1184         retry = DAP_Data.transfer.retry_count;
000312  4826              LDR      r0,|L11.940|
000314  f8b08010          LDRH     r8,[r0,#0x10]
;;;1185         do {
000318  bf00              NOP      
                  |L11.794|
;;;1186           response_value = JTAG_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
00031a  4669              MOV      r1,sp
00031c  200e              MOVS     r0,#0xe
00031e  f7fffffe          BL       JTAG_Transfer
000322  4606              MOV      r6,r0
;;;1187         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000324  2e02              CMP      r6,#2
000326  d108              BNE      |L11.826|
000328  f1b80000          SUBS     r0,r8,#0
00032c  f1a80801          SUB      r8,r8,#1
000330  d003              BEQ      |L11.826|
000332  481d              LDR      r0,|L11.936|
000334  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000336  2800              CMP      r0,#0
000338  d0ef              BEQ      |L11.794|
                  |L11.826|
;;;1188         if (response_value != DAP_TRANSFER_OK) {
00033a  2e01              CMP      r6,#1
00033c  d000              BEQ      |L11.832|
;;;1189           goto end;
00033e  e024              B        |L11.906|
                  |L11.832|
;;;1190         }
;;;1191         // Store previous data
;;;1192         *response++ = (uint8_t) data;
000340  9800              LDR      r0,[sp,#0]
000342  f8040b01          STRB     r0,[r4],#1
;;;1193         *response++ = (uint8_t)(data >>  8);
000346  9800              LDR      r0,[sp,#0]
000348  0a00              LSRS     r0,r0,#8
00034a  f8040b01          STRB     r0,[r4],#1
;;;1194         *response++ = (uint8_t)(data >> 16);
00034e  9800              LDR      r0,[sp,#0]
000350  0c00              LSRS     r0,r0,#16
000352  f8040b01          STRB     r0,[r4],#1
;;;1195         *response++ = (uint8_t)(data >> 24);
000356  9800              LDR      r0,[sp,#0]
000358  0e00              LSRS     r0,r0,#24
00035a  f8040b01          STRB     r0,[r4],#1
00035e  e013              B        |L11.904|
                  |L11.864|
;;;1196       } else {
;;;1197         // Check last write
;;;1198         retry = DAP_Data.transfer.retry_count;
000360  4812              LDR      r0,|L11.940|
000362  f8b08010          LDRH     r8,[r0,#0x10]
;;;1199         do {
000366  bf00              NOP      
                  |L11.872|
;;;1200           response_value = JTAG_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
000368  2100              MOVS     r1,#0
00036a  200e              MOVS     r0,#0xe
00036c  f7fffffe          BL       JTAG_Transfer
000370  4606              MOV      r6,r0
;;;1201         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000372  2e02              CMP      r6,#2
000374  d108              BNE      |L11.904|
000376  f1b80000          SUBS     r0,r8,#0
00037a  f1a80801          SUB      r8,r8,#1
00037e  d003              BEQ      |L11.904|
000380  4809              LDR      r0,|L11.936|
000382  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000384  2800              CMP      r0,#0
000386  d0ef              BEQ      |L11.872|
                  |L11.904|
;;;1202       }
;;;1203     }
;;;1204   
;;;1205   end:
000388  bf00              NOP      
                  |L11.906|
;;;1206     *(response_head+0) = (uint8_t)response_count;
00038a  9804              LDR      r0,[sp,#0x10]
00038c  b2c1              UXTB     r1,r0
00038e  9805              LDR      r0,[sp,#0x14]
000390  7001              STRB     r1,[r0,#0]
;;;1207     *(response_head+1) = (uint8_t)response_value;
000392  9805              LDR      r0,[sp,#0x14]
000394  7046              STRB     r6,[r0,#1]
;;;1208   
;;;1209     return (((uint32_t)(request - request_head) << 16) | (uint32_t)(response - response_head));
000396  9805              LDR      r0,[sp,#0x14]
000398  1a21              SUBS     r1,r4,r0
00039a  9806              LDR      r0,[sp,#0x18]
00039c  1a28              SUBS     r0,r5,r0
00039e  ea414000          ORR      r0,r1,r0,LSL #16
;;;1210   }
0003a2  b007              ADD      sp,sp,#0x1c
0003a4  e8bd8ff0          POP      {r4-r11,pc}
;;;1211   #endif
                          ENDP

                  |L11.936|
                          DCD      DAP_TransferAbort
                  |L11.940|
                          DCD      DAP_Data

                          AREA ||i.DAP_JTAG_TransferBlock||, CODE, READONLY, ALIGN=2

                  DAP_JTAG_TransferBlock PROC
;;;1384   #if (DAP_JTAG != 0)
;;;1385   static uint32_t DAP_JTAG_TransferBlock(const uint8_t *request, uint8_t *response) {
000000  e92d5ffc          PUSH     {r2-r12,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1386     uint32_t  request_count;
;;;1387     uint32_t  request_value;
;;;1388     uint32_t  response_count;
;;;1389     uint32_t  response_value;
;;;1390     uint8_t  *response_head;
;;;1391     uint32_t  retry;
;;;1392     uint32_t  data;
;;;1393     uint32_t  ir;
;;;1394   
;;;1395     response_count = 0U;
000008  f04f0b00          MOV      r11,#0
;;;1396     response_value = 0U;
00000c  2600              MOVS     r6,#0
;;;1397     response_head  = response;
00000e  46a8              MOV      r8,r5
;;;1398     response      += 3;
000010  1ced              ADDS     r5,r5,#3
;;;1399   
;;;1400     DAP_TransferAbort = 0U;
000012  2000              MOVS     r0,#0
000014  4960              LDR      r1,|L12.408|
000016  7008              STRB     r0,[r1,#0]
;;;1401   
;;;1402     // Device index (JTAP TAP)
;;;1403     DAP_Data.jtag_dev.index = *request++;
000018  f8141b01          LDRB     r1,[r4],#1
00001c  485f              LDR      r0,|L12.412|
00001e  76c1              STRB     r1,[r0,#0x1b]
;;;1404     if (DAP_Data.jtag_dev.index >= DAP_Data.jtag_dev.count) { 
000020  7ec0              LDRB     r0,[r0,#0x1b]
000022  495e              LDR      r1,|L12.412|
000024  7e89              LDRB     r1,[r1,#0x1a]  ; DAP_Data
000026  4288              CMP      r0,r1
000028  db00              BLT      |L12.44|
;;;1405       goto end;
00002a  e0a9              B        |L12.384|
                  |L12.44|
;;;1406     }
;;;1407   
;;;1408     request_count = (uint32_t)(*(request+0) << 0) | 
00002c  7820              LDRB     r0,[r4,#0]
00002e  7861              LDRB     r1,[r4,#1]
000030  ea402701          ORR      r7,r0,r1,LSL #8
;;;1409                     (uint32_t)(*(request+1) << 8);
;;;1410     request += 2;
000034  1ca4              ADDS     r4,r4,#2
;;;1411     if (request_count == 0U) { 
000036  b907              CBNZ     r7,|L12.58|
;;;1412       goto end;
000038  e0a2              B        |L12.384|
                  |L12.58|
;;;1413     }
;;;1414   
;;;1415     request_value = *request++;
00003a  f814ab01          LDRB     r10,[r4],#1
;;;1416   
;;;1417     // Select JTAG chain
;;;1418     ir = (request_value & DAP_TRANSFER_APnDP) ? JTAG_APACC : JTAG_DPACC;
00003e  f00a0001          AND      r0,r10,#1
000042  b108              CBZ      r0,|L12.72|
000044  200b              MOVS     r0,#0xb
000046  e000              B        |L12.74|
                  |L12.72|
000048  200a              MOVS     r0,#0xa
                  |L12.74|
00004a  9000              STR      r0,[sp,#0]
;;;1419     JTAG_IR(ir);
00004c  9800              LDR      r0,[sp,#0]
00004e  f7fffffe          BL       JTAG_IR
;;;1420   
;;;1421     if ((request_value & DAP_TRANSFER_RnW) != 0U) {
000052  f00a0002          AND      r0,r10,#2
000056  2800              CMP      r0,#0
000058  d04d              BEQ      |L12.246|
;;;1422       // Post read
;;;1423       retry = DAP_Data.transfer.retry_count;
00005a  4850              LDR      r0,|L12.412|
00005c  f8b09010          LDRH     r9,[r0,#0x10]
;;;1424       do {
000060  bf00              NOP      
                  |L12.98|
;;;1425         response_value = JTAG_Transfer(request_value, NULL);
000062  2100              MOVS     r1,#0
000064  4650              MOV      r0,r10
000066  f7fffffe          BL       JTAG_Transfer
00006a  4606              MOV      r6,r0
;;;1426       } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00006c  2e02              CMP      r6,#2
00006e  d108              BNE      |L12.130|
000070  f1b90000          SUBS     r0,r9,#0
000074  f1a90901          SUB      r9,r9,#1
000078  d003              BEQ      |L12.130|
00007a  4847              LDR      r0,|L12.408|
00007c  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00007e  2800              CMP      r0,#0
000080  d0ef              BEQ      |L12.98|
                  |L12.130|
;;;1427       if (response_value != DAP_TRANSFER_OK) {
000082  2e01              CMP      r6,#1
000084  d000              BEQ      |L12.136|
;;;1428         goto end;
000086  e07b              B        |L12.384|
                  |L12.136|
;;;1429       }
;;;1430       // Read register block
;;;1431       while (request_count--) {
000088  e030              B        |L12.236|
                  |L12.138|
;;;1432         // Read DP/AP register
;;;1433         if (request_count == 0U) {
00008a  b93f              CBNZ     r7,|L12.156|
;;;1434           // Last read
;;;1435           if (ir != JTAG_DPACC) {
00008c  9800              LDR      r0,[sp,#0]
00008e  280a              CMP      r0,#0xa
000090  d002              BEQ      |L12.152|
;;;1436             JTAG_IR(JTAG_DPACC);
000092  200a              MOVS     r0,#0xa
000094  f7fffffe          BL       JTAG_IR
                  |L12.152|
;;;1437           }
;;;1438           request_value = DP_RDBUFF | DAP_TRANSFER_RnW;
000098  f04f0a0e          MOV      r10,#0xe
                  |L12.156|
;;;1439         }
;;;1440         retry = DAP_Data.transfer.retry_count;
00009c  483f              LDR      r0,|L12.412|
00009e  f8b09010          LDRH     r9,[r0,#0x10]
;;;1441         do {
0000a2  bf00              NOP      
                  |L12.164|
;;;1442           response_value = JTAG_Transfer(request_value, &data);
0000a4  a901              ADD      r1,sp,#4
0000a6  4650              MOV      r0,r10
0000a8  f7fffffe          BL       JTAG_Transfer
0000ac  4606              MOV      r6,r0
;;;1443         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000ae  2e02              CMP      r6,#2
0000b0  d108              BNE      |L12.196|
0000b2  f1b90000          SUBS     r0,r9,#0
0000b6  f1a90901          SUB      r9,r9,#1
0000ba  d003              BEQ      |L12.196|
0000bc  4836              LDR      r0,|L12.408|
0000be  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0000c0  2800              CMP      r0,#0
0000c2  d0ef              BEQ      |L12.164|
                  |L12.196|
;;;1444         if (response_value != DAP_TRANSFER_OK) {
0000c4  2e01              CMP      r6,#1
0000c6  d000              BEQ      |L12.202|
;;;1445           goto end;
0000c8  e05a              B        |L12.384|
                  |L12.202|
;;;1446         }
;;;1447         // Store data
;;;1448         *response++ = (uint8_t) data;
0000ca  9801              LDR      r0,[sp,#4]
0000cc  f8050b01          STRB     r0,[r5],#1
;;;1449         *response++ = (uint8_t)(data >>  8);
0000d0  9801              LDR      r0,[sp,#4]
0000d2  0a00              LSRS     r0,r0,#8
0000d4  f8050b01          STRB     r0,[r5],#1
;;;1450         *response++ = (uint8_t)(data >> 16);
0000d8  9801              LDR      r0,[sp,#4]
0000da  0c00              LSRS     r0,r0,#16
0000dc  f8050b01          STRB     r0,[r5],#1
;;;1451         *response++ = (uint8_t)(data >> 24);
0000e0  9801              LDR      r0,[sp,#4]
0000e2  0e00              LSRS     r0,r0,#24
0000e4  f8050b01          STRB     r0,[r5],#1
;;;1452         response_count++;
0000e8  f10b0b01          ADD      r11,r11,#1
                  |L12.236|
0000ec  1e38              SUBS     r0,r7,#0              ;1431
0000ee  f1a70701          SUB      r7,r7,#1              ;1431
0000f2  d1ca              BNE      |L12.138|
0000f4  e043              B        |L12.382|
                  |L12.246|
;;;1453       }
;;;1454     } else {
;;;1455       // Write register block
;;;1456       while (request_count--) {
0000f6  e024              B        |L12.322|
                  |L12.248|
;;;1457         // Load data
;;;1458         data = (uint32_t)(*(request+0) <<  0) |
0000f8  7820              LDRB     r0,[r4,#0]
0000fa  7861              LDRB     r1,[r4,#1]
0000fc  ea402001          ORR      r0,r0,r1,LSL #8
000100  78a1              LDRB     r1,[r4,#2]
000102  ea404001          ORR      r0,r0,r1,LSL #16
000106  78e1              LDRB     r1,[r4,#3]
000108  ea406001          ORR      r0,r0,r1,LSL #24
00010c  9001              STR      r0,[sp,#4]
;;;1459                (uint32_t)(*(request+1) <<  8) |
;;;1460                (uint32_t)(*(request+2) << 16) |
;;;1461                (uint32_t)(*(request+3) << 24);
;;;1462         request += 4;
00010e  1d24              ADDS     r4,r4,#4
;;;1463         // Write DP/AP register
;;;1464         retry = DAP_Data.transfer.retry_count;
000110  4822              LDR      r0,|L12.412|
000112  f8b09010          LDRH     r9,[r0,#0x10]
;;;1465         do {
000116  bf00              NOP      
                  |L12.280|
;;;1466           response_value = JTAG_Transfer(request_value, &data);
000118  a901              ADD      r1,sp,#4
00011a  4650              MOV      r0,r10
00011c  f7fffffe          BL       JTAG_Transfer
000120  4606              MOV      r6,r0
;;;1467         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000122  2e02              CMP      r6,#2
000124  d108              BNE      |L12.312|
000126  f1b90000          SUBS     r0,r9,#0
00012a  f1a90901          SUB      r9,r9,#1
00012e  d003              BEQ      |L12.312|
000130  4819              LDR      r0,|L12.408|
000132  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000134  2800              CMP      r0,#0
000136  d0ef              BEQ      |L12.280|
                  |L12.312|
;;;1468         if (response_value != DAP_TRANSFER_OK) {
000138  2e01              CMP      r6,#1
00013a  d000              BEQ      |L12.318|
;;;1469           goto end;
00013c  e020              B        |L12.384|
                  |L12.318|
;;;1470         }
;;;1471         response_count++;
00013e  f10b0b01          ADD      r11,r11,#1
                  |L12.322|
000142  1e38              SUBS     r0,r7,#0              ;1456
000144  f1a70701          SUB      r7,r7,#1              ;1456
000148  d1d6              BNE      |L12.248|
;;;1472       }
;;;1473       // Check last write
;;;1474       if (ir != JTAG_DPACC) {
00014a  9800              LDR      r0,[sp,#0]
00014c  280a              CMP      r0,#0xa
00014e  d002              BEQ      |L12.342|
;;;1475         JTAG_IR(JTAG_DPACC);
000150  200a              MOVS     r0,#0xa
000152  f7fffffe          BL       JTAG_IR
                  |L12.342|
;;;1476       }
;;;1477       retry = DAP_Data.transfer.retry_count;
000156  4811              LDR      r0,|L12.412|
000158  f8b09010          LDRH     r9,[r0,#0x10]
;;;1478       do {
00015c  bf00              NOP      
                  |L12.350|
;;;1479         response_value = JTAG_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
00015e  2100              MOVS     r1,#0
000160  200e              MOVS     r0,#0xe
000162  f7fffffe          BL       JTAG_Transfer
000166  4606              MOV      r6,r0
;;;1480       } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000168  2e02              CMP      r6,#2
00016a  d108              BNE      |L12.382|
00016c  f1b90000          SUBS     r0,r9,#0
000170  f1a90901          SUB      r9,r9,#1
000174  d003              BEQ      |L12.382|
000176  4808              LDR      r0,|L12.408|
000178  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00017a  2800              CMP      r0,#0
00017c  d0ef              BEQ      |L12.350|
                  |L12.382|
;;;1481     }
;;;1482   
;;;1483   end:
00017e  bf00              NOP      
                  |L12.384|
;;;1484     *(response_head+0) = (uint8_t)(response_count >> 0);
000180  f888b000          STRB     r11,[r8,#0]
;;;1485     *(response_head+1) = (uint8_t)(response_count >> 8);
000184  ea4f201b          LSR      r0,r11,#8
000188  f8880001          STRB     r0,[r8,#1]
;;;1486     *(response_head+2) = (uint8_t) response_value;
00018c  f8886002          STRB     r6,[r8,#2]
;;;1487   
;;;1488     return ((uint32_t)(response - response_head));
000190  eba50008          SUB      r0,r5,r8
;;;1489   }
000194  e8bd9ffc          POP      {r2-r12,pc}
;;;1490   #endif
                          ENDP

                  |L12.408|
                          DCD      DAP_TransferAbort
                  |L12.412|
                          DCD      DAP_Data

                          AREA ||i.DAP_JTAG_WriteAbort||, CODE, READONLY, ALIGN=2

                  DAP_JTAG_WriteAbort PROC
;;;1559   #if (DAP_JTAG != 0)
;;;1560   static uint32_t DAP_JTAG_WriteAbort(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1561     uint32_t data;
;;;1562   
;;;1563     // Device index (JTAP TAP)
;;;1564     DAP_Data.jtag_dev.index = *request;
000006  7821              LDRB     r1,[r4,#0]
000008  480f              LDR      r0,|L13.72|
00000a  76c1              STRB     r1,[r0,#0x1b]
;;;1565     if (DAP_Data.jtag_dev.index >= DAP_Data.jtag_dev.count) {
00000c  7ec0              LDRB     r0,[r0,#0x1b]
00000e  490e              LDR      r1,|L13.72|
000010  7e89              LDRB     r1,[r1,#0x1a]  ; DAP_Data
000012  4288              CMP      r0,r1
000014  db03              BLT      |L13.30|
;;;1566       *response = DAP_ERROR;
000016  20ff              MOVS     r0,#0xff
000018  7028              STRB     r0,[r5,#0]
;;;1567       return (1U); 
00001a  2001              MOVS     r0,#1
                  |L13.28|
;;;1568     }
;;;1569   
;;;1570     // Select JTAG chain
;;;1571     JTAG_IR(JTAG_ABORT);
;;;1572   
;;;1573     // Load data
;;;1574     data = (uint32_t)(*(request+1) <<  0) |
;;;1575            (uint32_t)(*(request+2) <<  8) |
;;;1576            (uint32_t)(*(request+3) << 16) |
;;;1577            (uint32_t)(*(request+4) << 24);
;;;1578   
;;;1579     // Write Abort register
;;;1580     JTAG_WriteAbort(data);
;;;1581   
;;;1582     *response = DAP_OK;
;;;1583     return (1U); 
;;;1584   }
00001c  bd70              POP      {r4-r6,pc}
                  |L13.30|
00001e  2008              MOVS     r0,#8                 ;1571
000020  f7fffffe          BL       JTAG_IR
000024  7860              LDRB     r0,[r4,#1]            ;1574
000026  78a1              LDRB     r1,[r4,#2]            ;1574
000028  ea402001          ORR      r0,r0,r1,LSL #8       ;1574
00002c  78e1              LDRB     r1,[r4,#3]            ;1574
00002e  ea404001          ORR      r0,r0,r1,LSL #16      ;1574
000032  7921              LDRB     r1,[r4,#4]            ;1574
000034  ea406601          ORR      r6,r0,r1,LSL #24      ;1574
000038  4630              MOV      r0,r6                 ;1580
00003a  f7fffffe          BL       JTAG_WriteAbort
00003e  2000              MOVS     r0,#0                 ;1582
000040  7028              STRB     r0,[r5,#0]            ;1582
000042  2001              MOVS     r0,#1                 ;1583
000044  e7ea              B        |L13.28|
;;;1585   #endif
                          ENDP

000046  0000              DCW      0x0000
                  |L13.72|
                          DCD      DAP_Data

                          AREA ||i.DAP_ProcessCommand||, CODE, READONLY, ALIGN=1

                  DAP_ProcessCommand PROC
;;;1633   //             number of bytes in request (upper 16 bits)
;;;1634   uint32_t DAP_ProcessCommand(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1635     uint32_t num;
;;;1636   
;;;1637     if ((*request >= ID_DAP_Vendor0) && (*request <= ID_DAP_Vendor31)) {
000006  7828              LDRB     r0,[r5,#0]
000008  2880              CMP      r0,#0x80
00000a  d307              BCC      |L14.28|
00000c  7828              LDRB     r0,[r5,#0]
00000e  289f              CMP      r0,#0x9f
000010  d804              BHI      |L14.28|
;;;1638       return DAP_ProcessVendorCommand(request, response);
000012  4631              MOV      r1,r6
000014  4628              MOV      r0,r5
000016  f7fffffe          BL       DAP_ProcessVendorCommand
                  |L14.26|
;;;1639     }
;;;1640   
;;;1641     *response++ = *request;
;;;1642   
;;;1643     switch (*request++) {
;;;1644       case ID_DAP_Info:
;;;1645         num = DAP_Info(*request, response+1);
;;;1646         *response = (uint8_t)num;
;;;1647         return ((2U << 16) + 2U + num);
;;;1648   
;;;1649       case ID_DAP_HostStatus:
;;;1650         num = DAP_HostStatus(request, response);
;;;1651         break;
;;;1652   
;;;1653       case ID_DAP_Connect:
;;;1654         num = DAP_Connect(request, response);
;;;1655         break;
;;;1656       case ID_DAP_Disconnect:
;;;1657         num = DAP_Disconnect(response);
;;;1658         break;
;;;1659   
;;;1660       case ID_DAP_Delay:
;;;1661         num = DAP_Delay(request, response);
;;;1662         break;
;;;1663   
;;;1664       case ID_DAP_ResetTarget:
;;;1665         num = DAP_ResetTarget(response);
;;;1666         break;
;;;1667   
;;;1668       case ID_DAP_SWJ_Pins:
;;;1669         num = DAP_SWJ_Pins(request, response);
;;;1670         break;
;;;1671       case ID_DAP_SWJ_Clock:
;;;1672         num = DAP_SWJ_Clock(request, response);
;;;1673         break;
;;;1674       case ID_DAP_SWJ_Sequence:
;;;1675         num = DAP_SWJ_Sequence(request, response);
;;;1676         break;
;;;1677   
;;;1678       case ID_DAP_SWD_Configure:
;;;1679         num = DAP_SWD_Configure(request, response);
;;;1680         break;
;;;1681       case ID_DAP_SWD_Sequence:
;;;1682         num = DAP_SWD_Sequence(request, response);
;;;1683         break;
;;;1684   
;;;1685       case ID_DAP_JTAG_Sequence:
;;;1686         num = DAP_JTAG_Sequence(request, response);
;;;1687         break;
;;;1688       case ID_DAP_JTAG_Configure:
;;;1689         num = DAP_JTAG_Configure(request, response);
;;;1690         break;
;;;1691       case ID_DAP_JTAG_IDCODE:
;;;1692         num = DAP_JTAG_IDCode(request, response);
;;;1693         break;
;;;1694   
;;;1695       case ID_DAP_TransferConfigure:
;;;1696         num = DAP_TransferConfigure(request, response);
;;;1697         break;
;;;1698       case ID_DAP_Transfer:
;;;1699         num = DAP_Transfer(request, response);
;;;1700         break;
;;;1701       case ID_DAP_TransferBlock:
;;;1702         num = DAP_TransferBlock(request, response);
;;;1703         break;
;;;1704   
;;;1705       case ID_DAP_WriteABORT:
;;;1706         num = DAP_WriteAbort(request, response);
;;;1707         break;
;;;1708   
;;;1709   #if ((SWO_UART != 0) || (SWO_MANCHESTER != 0))
;;;1710       case ID_DAP_SWO_Transport:
;;;1711         num = SWO_Transport(request, response);
;;;1712         break;
;;;1713       case ID_DAP_SWO_Mode:
;;;1714         num = SWO_Mode(request, response);
;;;1715         break;
;;;1716       case ID_DAP_SWO_Baudrate:
;;;1717         num = SWO_Baudrate(request, response);
;;;1718         break;
;;;1719       case ID_DAP_SWO_Control:
;;;1720         num = SWO_Control(request, response);
;;;1721         break;
;;;1722       case ID_DAP_SWO_Status:
;;;1723         num = SWO_Status(response);
;;;1724         break;
;;;1725       case ID_DAP_SWO_ExtendedStatus:
;;;1726         num = SWO_ExtendedStatus(request, response);
;;;1727         break;
;;;1728       case ID_DAP_SWO_Data:
;;;1729         num = SWO_Data(request, response);
;;;1730         break;
;;;1731   #endif
;;;1732   
;;;1733       default:
;;;1734         *(response-1) = ID_DAP_Invalid;
;;;1735         return ((1U << 16) | 1U);
;;;1736     }
;;;1737   
;;;1738     return ((1U << 16) + 1U + num);
;;;1739   }
00001a  bd70              POP      {r4-r6,pc}
                  |L14.28|
00001c  7828              LDRB     r0,[r5,#0]            ;1641
00001e  f8060b01          STRB     r0,[r6],#1            ;1641
000022  f8150b01          LDRB     r0,[r5],#1            ;1643
000026  281f              CMP      r0,#0x1f              ;1643
000028  d272              BCS      |L14.272|
00002a  e8dff000          TBB      [pc,r0]               ;1643
00002e  1019              DCB      0x10,0x19
000030  1f25656b          DCB      0x1f,0x25,0x65,0x6b
000034  72a7782a          DCB      0x72,0xa7,0x78,0x2a
000038  30a7a7a7          DCB      0x30,0xa7,0xa7,0xa7
00003c  a7a7353b          DCB      0xa7,0xa7,0x35,0x3b
000040  41475359          DCB      0x41,0x47,0x53,0x59
000044  5f7e848a          DCB      0x5f,0x7e,0x84,0x8a
000048  9096a14d          DCB      0x90,0x96,0xa1,0x4d
00004c  9b00              DCB      0x9b,0x00
00004e  7828              LDRB     r0,[r5,#0]            ;1645
000050  1c71              ADDS     r1,r6,#1              ;1645
000052  f7fffffe          BL       DAP_Info
000056  4604              MOV      r4,r0                 ;1645
000058  7034              STRB     r4,[r6,#0]            ;1646
00005a  f1041002          ADD      r0,r4,#0x20002        ;1647
00005e  e7dc              B        |L14.26|
000060  4631              MOV      r1,r6                 ;1650
000062  4628              MOV      r0,r5                 ;1650
000064  f7fffffe          BL       DAP_HostStatus
000068  4604              MOV      r4,r0                 ;1650
00006a  e08d              B        |L14.392|
00006c  4631              MOV      r1,r6                 ;1654
00006e  4628              MOV      r0,r5                 ;1654
000070  f7fffffe          BL       DAP_Connect
000074  4604              MOV      r4,r0                 ;1654
000076  e087              B        |L14.392|
000078  4630              MOV      r0,r6                 ;1657
00007a  f7fffffe          BL       DAP_Disconnect
00007e  4604              MOV      r4,r0                 ;1657
000080  e082              B        |L14.392|
000082  4631              MOV      r1,r6                 ;1661
000084  4628              MOV      r0,r5                 ;1661
000086  f7fffffe          BL       DAP_Delay
00008a  4604              MOV      r4,r0                 ;1661
00008c  e07c              B        |L14.392|
00008e  4630              MOV      r0,r6                 ;1665
000090  f7fffffe          BL       DAP_ResetTarget
000094  4604              MOV      r4,r0                 ;1665
000096  e077              B        |L14.392|
000098  4631              MOV      r1,r6                 ;1669
00009a  4628              MOV      r0,r5                 ;1669
00009c  f7fffffe          BL       DAP_SWJ_Pins
0000a0  4604              MOV      r4,r0                 ;1669
0000a2  e071              B        |L14.392|
0000a4  4631              MOV      r1,r6                 ;1672
0000a6  4628              MOV      r0,r5                 ;1672
0000a8  f7fffffe          BL       DAP_SWJ_Clock
0000ac  4604              MOV      r4,r0                 ;1672
0000ae  e06b              B        |L14.392|
0000b0  4631              MOV      r1,r6                 ;1675
0000b2  4628              MOV      r0,r5                 ;1675
0000b4  f7fffffe          BL       DAP_SWJ_Sequence
0000b8  4604              MOV      r4,r0                 ;1675
0000ba  e065              B        |L14.392|
0000bc  4631              MOV      r1,r6                 ;1679
0000be  4628              MOV      r0,r5                 ;1679
0000c0  f7fffffe          BL       DAP_SWD_Configure
0000c4  4604              MOV      r4,r0                 ;1679
0000c6  e05f              B        |L14.392|
0000c8  4631              MOV      r1,r6                 ;1682
0000ca  4628              MOV      r0,r5                 ;1682
0000cc  f7fffffe          BL       DAP_SWD_Sequence
0000d0  4604              MOV      r4,r0                 ;1682
0000d2  e059              B        |L14.392|
0000d4  4631              MOV      r1,r6                 ;1686
0000d6  4628              MOV      r0,r5                 ;1686
0000d8  f7fffffe          BL       DAP_JTAG_Sequence
0000dc  4604              MOV      r4,r0                 ;1686
0000de  e053              B        |L14.392|
0000e0  4631              MOV      r1,r6                 ;1689
0000e2  4628              MOV      r0,r5                 ;1689
0000e4  f7fffffe          BL       DAP_JTAG_Configure
0000e8  4604              MOV      r4,r0                 ;1689
0000ea  e04d              B        |L14.392|
0000ec  4631              MOV      r1,r6                 ;1692
0000ee  4628              MOV      r0,r5                 ;1692
0000f0  f7fffffe          BL       DAP_JTAG_IDCode
0000f4  4604              MOV      r4,r0                 ;1692
0000f6  e047              B        |L14.392|
0000f8  4631              MOV      r1,r6                 ;1696
0000fa  4628              MOV      r0,r5                 ;1696
0000fc  f7fffffe          BL       DAP_TransferConfigure
000100  4604              MOV      r4,r0                 ;1696
000102  e041              B        |L14.392|
000104  4631              MOV      r1,r6                 ;1699
000106  4628              MOV      r0,r5                 ;1699
000108  f7fffffe          BL       DAP_Transfer
00010c  4604              MOV      r4,r0                 ;1699
00010e  e03b              B        |L14.392|
                  |L14.272|
000110  e034              B        |L14.380|
000112  4631              MOV      r1,r6                 ;1702
000114  4628              MOV      r0,r5                 ;1702
000116  f7fffffe          BL       DAP_TransferBlock
00011a  4604              MOV      r4,r0                 ;1702
00011c  e034              B        |L14.392|
00011e  4631              MOV      r1,r6                 ;1706
000120  4628              MOV      r0,r5                 ;1706
000122  f7fffffe          BL       DAP_WriteAbort
000126  4604              MOV      r4,r0                 ;1706
000128  e02e              B        |L14.392|
00012a  4631              MOV      r1,r6                 ;1711
00012c  4628              MOV      r0,r5                 ;1711
00012e  f7fffffe          BL       SWO_Transport
000132  4604              MOV      r4,r0                 ;1711
000134  e028              B        |L14.392|
000136  4631              MOV      r1,r6                 ;1714
000138  4628              MOV      r0,r5                 ;1714
00013a  f7fffffe          BL       SWO_Mode
00013e  4604              MOV      r4,r0                 ;1714
000140  e022              B        |L14.392|
000142  4631              MOV      r1,r6                 ;1717
000144  4628              MOV      r0,r5                 ;1717
000146  f7fffffe          BL       SWO_Baudrate
00014a  4604              MOV      r4,r0                 ;1717
00014c  e01c              B        |L14.392|
00014e  4631              MOV      r1,r6                 ;1720
000150  4628              MOV      r0,r5                 ;1720
000152  f7fffffe          BL       SWO_Control
000156  4604              MOV      r4,r0                 ;1720
000158  e016              B        |L14.392|
00015a  4630              MOV      r0,r6                 ;1723
00015c  f7fffffe          BL       SWO_Status
000160  4604              MOV      r4,r0                 ;1723
000162  e011              B        |L14.392|
000164  4631              MOV      r1,r6                 ;1726
000166  4628              MOV      r0,r5                 ;1726
000168  f7fffffe          BL       SWO_ExtendedStatus
00016c  4604              MOV      r4,r0                 ;1726
00016e  e00b              B        |L14.392|
000170  4631              MOV      r1,r6                 ;1729
000172  4628              MOV      r0,r5                 ;1729
000174  f7fffffe          BL       SWO_Data
000178  4604              MOV      r4,r0                 ;1729
00017a  e005              B        |L14.392|
                  |L14.380|
00017c  20ff              MOVS     r0,#0xff              ;1734
00017e  f8060c01          STRB     r0,[r6,#-1]           ;1734
000182  f04f1001          MOV      r0,#0x10001           ;1735
000186  e748              B        |L14.26|
                  |L14.392|
000188  bf00              NOP                            ;1651
00018a  f1041001          ADD      r0,r4,#0x10001        ;1738
00018e  e744              B        |L14.26|
;;;1740   
                          ENDP


                          AREA ||i.DAP_ProcessVendorCommand||, CODE, READONLY, ALIGN=1

                  DAP_ProcessVendorCommand PROC
;;;1621   //             number of bytes in request (upper 16 bits)
;;;1622   __WEAK uint32_t DAP_ProcessVendorCommand(const uint8_t *request, uint8_t *response) {
000000  4602              MOV      r2,r0
;;;1623     (void)request;
;;;1624     *response = ID_DAP_Invalid;
000002  20ff              MOVS     r0,#0xff
000004  7008              STRB     r0,[r1,#0]
;;;1625     return ((1U << 16) | 1U);
000006  f04f1001          MOV      r0,#0x10001
;;;1626   }
00000a  4770              BX       lr
;;;1627   
                          ENDP


                          AREA ||i.DAP_ResetTarget||, CODE, READONLY, ALIGN=1

                  DAP_ResetTarget PROC
;;;268    //   return:   number of bytes in response
;;;269    static uint32_t DAP_ResetTarget(uint8_t *response) {
000000  4601              MOV      r1,r0
;;;270    
;;;271      *(response+1) = RESET_TARGET();
000002  bf00              NOP      
000004  2001              MOVS     r0,#1
000006  7048              STRB     r0,[r1,#1]
;;;272      *(response+0) = DAP_OK;
000008  2000              MOVS     r0,#0
00000a  7008              STRB     r0,[r1,#0]
;;;273      return (2U);
00000c  2002              MOVS     r0,#2
;;;274    }
00000e  4770              BX       lr
;;;275    
                          ENDP


                          AREA ||i.DAP_SWD_Configure||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Configure PROC
;;;456    //             number of bytes in request (upper 16 bits)
;;;457    static uint32_t DAP_SWD_Configure(const uint8_t *request, uint8_t *response) {
000000  b510              PUSH     {r4,lr}
000002  4602              MOV      r2,r0
;;;458    #if (DAP_SWD != 0)
;;;459      uint8_t value;
;;;460    
;;;461      value = *request;
000004  7813              LDRB     r3,[r2,#0]
;;;462      DAP_Data.swd_conf.turnaround = (value & 0x03U) + 1U;
000006  f0030003          AND      r0,r3,#3
00000a  1c40              ADDS     r0,r0,#1
00000c  4c05              LDR      r4,|L17.36|
00000e  7620              STRB     r0,[r4,#0x18]
;;;463      DAP_Data.swd_conf.data_phase = (value & 0x04U) ? 1U : 0U;
000010  f3c30480          UBFX     r4,r3,#2,#1
000014  4803              LDR      r0,|L17.36|
000016  7644              STRB     r4,[r0,#0x19]
;;;464      
;;;465      *response = DAP_OK;
000018  2000              MOVS     r0,#0
00001a  7008              STRB     r0,[r1,#0]
;;;466    #else
;;;467      *response = DAP_ERROR;
;;;468    #endif
;;;469    
;;;470      return ((1U << 16) | 1U);
00001c  f04f1001          MOV      r0,#0x10001
;;;471    }
000020  bd10              POP      {r4,pc}
;;;472    
                          ENDP

000022  0000              DCW      0x0000
                  |L17.36|
                          DCD      DAP_Data

                          AREA ||i.DAP_SWD_Sequence||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Sequence PROC
;;;478    //             number of bytes in request (upper 16 bits)
;;;479    static uint32_t DAP_SWD_Sequence(const uint8_t *request, uint8_t *response) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4604              MOV      r4,r0
000006  460e              MOV      r6,r1
;;;480      uint32_t sequence_info;
;;;481      uint32_t sequence_count;
;;;482      uint32_t request_count;
;;;483      uint32_t response_count;
;;;484      uint32_t count;
;;;485    
;;;486    #if (DAP_SWD != 0)
;;;487      *response++ = DAP_OK;
000008  2000              MOVS     r0,#0
00000a  f8060b01          STRB     r0,[r6],#1
;;;488    #else
;;;489      *response++ = DAP_ERROR;
;;;490    #endif
;;;491      request_count  = 1U;
00000e  f04f0801          MOV      r8,#1
;;;492      response_count = 1U;
000012  f04f0901          MOV      r9,#1
;;;493    
;;;494      sequence_count = *request++;
000016  f814ab01          LDRB     r10,[r4],#1
;;;495      while (sequence_count--) {
00001a  e033              B        |L18.132|
                  |L18.28|
;;;496        sequence_info = *request++;
00001c  f8147b01          LDRB     r7,[r4],#1
;;;497        count = sequence_info & SWD_SEQUENCE_CLK;
000020  f007053f          AND      r5,r7,#0x3f
;;;498        if (count == 0U) { 
000024  b905              CBNZ     r5,|L18.40|
;;;499          count = 64U;
000026  2540              MOVS     r5,#0x40
                  |L18.40|
;;;500        }
;;;501        count = (count + 7U) / 8U;
000028  1de8              ADDS     r0,r5,#7
00002a  08c5              LSRS     r5,r0,#3
;;;502    #if (DAP_SWD != 0)
;;;503        if ((sequence_info & SWD_SEQUENCE_DIN) != 0U) {
00002c  f0070080          AND      r0,r7,#0x80
000030  b188              CBZ      r0,|L18.86|
;;;504          PIN_SWDIO_OUT_DISABLE();
000032  bf00              NOP      
000034  bf00              NOP      
000036  bf00              NOP      
000038  4817              LDR      r0,|L18.152|
00003a  6800              LDR      r0,[r0,#0]
00003c  f0206070          BIC      r0,r0,#0xf000000
000040  f0406000          ORR      r0,r0,#0x8000000
000044  4914              LDR      r1,|L18.152|
000046  6008              STR      r0,[r1,#0]
000048  f44f4080          MOV      r0,#0x4000
00004c  4912              LDR      r1,|L18.152|
00004e  310c              ADDS     r1,r1,#0xc
000050  6008              STR      r0,[r1,#0]
000052  bf00              NOP      
000054  e001              B        |L18.90|
                  |L18.86|
;;;505        } else {
;;;506          PIN_SWDIO_OUT_ENABLE();
000056  f7fffffe          BL       PIN_SWDIO_OUT_ENABLE
                  |L18.90|
;;;507        }
;;;508        SWD_Sequence(sequence_info, request, response);
00005a  4632              MOV      r2,r6
00005c  4621              MOV      r1,r4
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       SWD_Sequence
;;;509        if (sequence_count == 0U) {
000064  f1ba0f00          CMP      r10,#0
000068  d101              BNE      |L18.110|
;;;510          PIN_SWDIO_OUT_ENABLE();
00006a  f7fffffe          BL       PIN_SWDIO_OUT_ENABLE
                  |L18.110|
;;;511        }
;;;512    #endif
;;;513        if ((sequence_info & SWD_SEQUENCE_DIN) != 0U) {
00006e  f0070080          AND      r0,r7,#0x80
000072  b120              CBZ      r0,|L18.126|
;;;514          request_count++;
000074  f1080801          ADD      r8,r8,#1
;;;515    #if (DAP_SWD != 0)
;;;516          response += count;
000078  442e              ADD      r6,r6,r5
;;;517          response_count += count;
00007a  44a9              ADD      r9,r9,r5
00007c  e002              B        |L18.132|
                  |L18.126|
;;;518    #endif
;;;519        } else {
;;;520          request += count;
00007e  442c              ADD      r4,r4,r5
;;;521          request_count += count + 1U;
000080  1c68              ADDS     r0,r5,#1
000082  4480              ADD      r8,r8,r0
                  |L18.132|
000084  f1ba0000          SUBS     r0,r10,#0             ;495
000088  f1aa0a01          SUB      r10,r10,#1            ;495
00008c  d1c6              BNE      |L18.28|
;;;522        }
;;;523      }
;;;524    
;;;525      return ((request_count << 16) | response_count);
00008e  ea494008          ORR      r0,r9,r8,LSL #16
;;;526    }
000092  e8bd87f0          POP      {r4-r10,pc}
;;;527    
                          ENDP

000096  0000              DCW      0x0000
                  |L18.152|
                          DCD      0x40010c04

                          AREA ||i.DAP_SWD_Transfer||, CODE, READONLY, ALIGN=2

                  DAP_SWD_Transfer PROC
;;;675    #if (DAP_SWD != 0)
;;;676    static uint32_t DAP_SWD_Transfer(const uint8_t *request, uint8_t *response) {
000000  e92d4ff0          PUSH     {r4-r11,lr}
000004  b087              SUB      sp,sp,#0x1c
000006  4605              MOV      r5,r0
000008  460c              MOV      r4,r1
;;;677      const
;;;678      uint8_t  *request_head;
;;;679      uint32_t  request_count;
;;;680      uint32_t  request_value;
;;;681      uint8_t  *response_head;
;;;682      uint32_t  response_count;
;;;683      uint32_t  response_value;
;;;684      uint32_t  post_read;
;;;685      uint32_t  check_write;
;;;686      uint32_t  match_value;
;;;687      uint32_t  match_retry;
;;;688      uint32_t  retry;
;;;689      uint32_t  data;
;;;690    #if (TIMESTAMP_CLOCK != 0U)
;;;691      uint32_t  timestamp;
;;;692    #endif
;;;693    
;;;694      request_head   = request;
00000a  9506              STR      r5,[sp,#0x18]
;;;695    
;;;696      response_count = 0U;
00000c  2000              MOVS     r0,#0
00000e  9005              STR      r0,[sp,#0x14]
;;;697      response_value = 0U;
000010  2600              MOVS     r6,#0
;;;698      response_head  = response;
000012  46a2              MOV      r10,r4
;;;699      response      += 2;
000014  1ca4              ADDS     r4,r4,#2
;;;700    
;;;701      DAP_TransferAbort = 0U;
000016  49e0              LDR      r1,|L19.920|
000018  7008              STRB     r0,[r1,#0]
;;;702    
;;;703      post_read   = 0U;
00001a  4683              MOV      r11,r0
;;;704      check_write = 0U;
00001c  9004              STR      r0,[sp,#0x10]
;;;705    
;;;706      request++;            // Ignore DAP index
00001e  1c6d              ADDS     r5,r5,#1
;;;707    
;;;708      request_count = *request++;
000020  f8159b01          LDRB     r9,[r5],#1
;;;709    
;;;710      for (; request_count != 0U; request_count--) {
000024  e150              B        |L19.712|
                  |L19.38|
;;;711        request_value = *request++;
000026  f8157b01          LDRB     r7,[r5],#1
;;;712        if ((request_value & DAP_TRANSFER_RnW) != 0U) {
00002a  f0070002          AND      r0,r7,#2
00002e  2800              CMP      r0,#0
000030  d07e              BEQ      |L19.304|
;;;713          // Read register
;;;714          if (post_read) {
000032  f1bb0f00          CMP      r11,#0
000036  d03d              BEQ      |L19.180|
;;;715            // Read was posted before
;;;716            retry = DAP_Data.transfer.retry_count;
000038  48d8              LDR      r0,|L19.924|
00003a  f8b08010          LDRH     r8,[r0,#0x10]
;;;717            if ((request_value & (DAP_TRANSFER_APnDP | DAP_TRANSFER_MATCH_VALUE)) == DAP_TRANSFER_APnDP) {
00003e  f0070011          AND      r0,r7,#0x11
000042  2801              CMP      r0,#1
000044  d111              BNE      |L19.106|
;;;718              // Read previous AP data and post next AP read
;;;719              do {
000046  bf00              NOP      
                  |L19.72|
;;;720                response_value = SWD_Transfer(request_value, &data);
000048  a901              ADD      r1,sp,#4
00004a  4638              MOV      r0,r7
00004c  f7fffffe          BL       SWD_Transfer
000050  4606              MOV      r6,r0
;;;721              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000052  2e02              CMP      r6,#2
000054  d11c              BNE      |L19.144|
000056  f1b80000          SUBS     r0,r8,#0
00005a  f1a80801          SUB      r8,r8,#1
00005e  d017              BEQ      |L19.144|
000060  48cd              LDR      r0,|L19.920|
000062  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000064  2800              CMP      r0,#0
000066  d0ef              BEQ      |L19.72|
000068  e012              B        |L19.144|
                  |L19.106|
;;;722            } else {
;;;723              // Read previous AP data
;;;724              do {
00006a  bf00              NOP      
                  |L19.108|
;;;725                response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
00006c  a901              ADD      r1,sp,#4
00006e  200e              MOVS     r0,#0xe
000070  f7fffffe          BL       SWD_Transfer
000074  4606              MOV      r6,r0
;;;726              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000076  2e02              CMP      r6,#2
000078  d108              BNE      |L19.140|
00007a  f1b80000          SUBS     r0,r8,#0
00007e  f1a80801          SUB      r8,r8,#1
000082  d003              BEQ      |L19.140|
000084  48c4              LDR      r0,|L19.920|
000086  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000088  2800              CMP      r0,#0
00008a  d0ef              BEQ      |L19.108|
                  |L19.140|
;;;727              post_read = 0U;
00008c  f04f0b00          MOV      r11,#0
                  |L19.144|
;;;728            }
;;;729            if (response_value != DAP_TRANSFER_OK) { 
000090  2e01              CMP      r6,#1
000092  d000              BEQ      |L19.150|
;;;730              break;
000094  e11c              B        |L19.720|
                  |L19.150|
;;;731            }
;;;732            // Store previous AP data
;;;733            *response++ = (uint8_t) data;
000096  9801              LDR      r0,[sp,#4]
000098  f8040b01          STRB     r0,[r4],#1
;;;734            *response++ = (uint8_t)(data >>  8);
00009c  9801              LDR      r0,[sp,#4]
00009e  0a00              LSRS     r0,r0,#8
0000a0  f8040b01          STRB     r0,[r4],#1
;;;735            *response++ = (uint8_t)(data >> 16);
0000a4  9801              LDR      r0,[sp,#4]
0000a6  0c00              LSRS     r0,r0,#16
0000a8  f8040b01          STRB     r0,[r4],#1
;;;736            *response++ = (uint8_t)(data >> 24);
0000ac  9801              LDR      r0,[sp,#4]
0000ae  0e00              LSRS     r0,r0,#24
0000b0  f8040b01          STRB     r0,[r4],#1
                  |L19.180|
;;;737    #if (TIMESTAMP_CLOCK != 0U)
;;;738            if (post_read) {
;;;739              // Store Timestamp of next AP read
;;;740              if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;741                timestamp = DAP_Data.timestamp;
;;;742                *response++ = (uint8_t) timestamp;
;;;743                *response++ = (uint8_t)(timestamp >>  8);
;;;744                *response++ = (uint8_t)(timestamp >> 16);
;;;745                *response++ = (uint8_t)(timestamp >> 24);
;;;746              }
;;;747            }
;;;748    #endif
;;;749          }
;;;750          if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
0000b4  f0070010          AND      r0,r7,#0x10
0000b8  2800              CMP      r0,#0
0000ba  d05e              BEQ      |L19.378|
;;;751            // Read with value match
;;;752            match_value = (uint32_t)(*(request+0) <<  0) |
0000bc  7828              LDRB     r0,[r5,#0]
0000be  7869              LDRB     r1,[r5,#1]
0000c0  ea402001          ORR      r0,r0,r1,LSL #8
0000c4  78a9              LDRB     r1,[r5,#2]
0000c6  ea404001          ORR      r0,r0,r1,LSL #16
0000ca  78e9              LDRB     r1,[r5,#3]
0000cc  ea406001          ORR      r0,r0,r1,LSL #24
0000d0  9003              STR      r0,[sp,#0xc]
;;;753                          (uint32_t)(*(request+1) <<  8) |
;;;754                          (uint32_t)(*(request+2) << 16) |
;;;755                          (uint32_t)(*(request+3) << 24);
;;;756            request += 4;
0000d2  1d2d              ADDS     r5,r5,#4
;;;757            match_retry = DAP_Data.transfer.match_retry;
0000d4  48b1              LDR      r0,|L19.924|
0000d6  8a40              LDRH     r0,[r0,#0x12]
0000d8  9002              STR      r0,[sp,#8]
;;;758            if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
0000da  f0070001          AND      r0,r7,#1
0000de  b1b0              CBZ      r0,|L19.270|
;;;759              // Post AP read
;;;760              retry = DAP_Data.transfer.retry_count;
0000e0  48ae              LDR      r0,|L19.924|
0000e2  f8b08010          LDRH     r8,[r0,#0x10]
;;;761              do {
0000e6  bf00              NOP      
                  |L19.232|
;;;762                response_value = SWD_Transfer(request_value, NULL);
0000e8  2100              MOVS     r1,#0
0000ea  4638              MOV      r0,r7
0000ec  f7fffffe          BL       SWD_Transfer
0000f0  4606              MOV      r6,r0
;;;763              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0000f2  2e02              CMP      r6,#2
0000f4  d108              BNE      |L19.264|
0000f6  f1b80000          SUBS     r0,r8,#0
0000fa  f1a80801          SUB      r8,r8,#1
0000fe  d003              BEQ      |L19.264|
000100  48a5              LDR      r0,|L19.920|
000102  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000104  2800              CMP      r0,#0
000106  d0ef              BEQ      |L19.232|
                  |L19.264|
;;;764              if (response_value != DAP_TRANSFER_OK) {
000108  2e01              CMP      r6,#1
00010a  d000              BEQ      |L19.270|
;;;765                break;
00010c  e0e0              B        |L19.720|
                  |L19.270|
;;;766              }
;;;767            }
;;;768            do {
00010e  bf00              NOP      
                  |L19.272|
;;;769              // Read register until its value matches or retry counter expires
;;;770              retry = DAP_Data.transfer.retry_count;
000110  48a2              LDR      r0,|L19.924|
000112  f8b08010          LDRH     r8,[r0,#0x10]
;;;771              do {
000116  bf00              NOP      
                  |L19.280|
;;;772                response_value = SWD_Transfer(request_value, &data);
000118  a901              ADD      r1,sp,#4
00011a  4638              MOV      r0,r7
00011c  f7fffffe          BL       SWD_Transfer
000120  4606              MOV      r6,r0
;;;773              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000122  2e02              CMP      r6,#2
000124  d10a              BNE      |L19.316|
000126  f1b80000          SUBS     r0,r8,#0
00012a  f1a80801          SUB      r8,r8,#1
00012e  e000              B        |L19.306|
                  |L19.304|
000130  e069              B        |L19.518|
                  |L19.306|
000132  d003              BEQ      |L19.316|
000134  4898              LDR      r0,|L19.920|
000136  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000138  2800              CMP      r0,#0
00013a  d0ed              BEQ      |L19.280|
                  |L19.316|
;;;774              if (response_value != DAP_TRANSFER_OK) {
00013c  2e01              CMP      r6,#1
00013e  d000              BEQ      |L19.322|
;;;775                break;
000140  e00e              B        |L19.352|
                  |L19.322|
;;;776              }
;;;777            } while (((data & DAP_Data.transfer.match_mask) != match_value) && match_retry-- && !DAP_TransferAbort);
000142  4896              LDR      r0,|L19.924|
000144  6940              LDR      r0,[r0,#0x14]
000146  9901              LDR      r1,[sp,#4]
000148  4008              ANDS     r0,r0,r1
00014a  9903              LDR      r1,[sp,#0xc]
00014c  4288              CMP      r0,r1
00014e  d007              BEQ      |L19.352|
000150  9802              LDR      r0,[sp,#8]
000152  1e41              SUBS     r1,r0,#1
000154  9102              STR      r1,[sp,#8]
000156  b118              CBZ      r0,|L19.352|
000158  488f              LDR      r0,|L19.920|
00015a  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
00015c  2800              CMP      r0,#0
00015e  d0d7              BEQ      |L19.272|
                  |L19.352|
000160  bf00              NOP                            ;775
;;;778            if ((data & DAP_Data.transfer.match_mask) != match_value) {
000162  488e              LDR      r0,|L19.924|
000164  6940              LDR      r0,[r0,#0x14]
000166  9901              LDR      r1,[sp,#4]
000168  4008              ANDS     r0,r0,r1
00016a  9903              LDR      r1,[sp,#0xc]
00016c  4288              CMP      r0,r1
00016e  d001              BEQ      |L19.372|
;;;779              response_value |= DAP_TRANSFER_MISMATCH;
000170  f0460610          ORR      r6,r6,#0x10
                  |L19.372|
;;;780            }
;;;781            if (response_value != DAP_TRANSFER_OK) {
000174  2e01              CMP      r6,#1
000176  d043              BEQ      |L19.512|
;;;782              break;
000178  e0aa              B        |L19.720|
                  |L19.378|
;;;783            }
;;;784          } else {
;;;785            // Normal read
;;;786            retry = DAP_Data.transfer.retry_count;
00017a  4888              LDR      r0,|L19.924|
00017c  f8b08010          LDRH     r8,[r0,#0x10]
;;;787            if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
000180  f0070001          AND      r0,r7,#1
000184  b1c8              CBZ      r0,|L19.442|
;;;788              // Read AP register
;;;789              if (post_read == 0U) {
000186  f1bb0f00          CMP      r11,#0
00018a  d139              BNE      |L19.512|
;;;790                // Post AP read
;;;791                do {
00018c  bf00              NOP      
                  |L19.398|
;;;792                  response_value = SWD_Transfer(request_value, NULL);
00018e  2100              MOVS     r1,#0
000190  4638              MOV      r0,r7
000192  f7fffffe          BL       SWD_Transfer
000196  4606              MOV      r6,r0
;;;793                } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000198  2e02              CMP      r6,#2
00019a  d108              BNE      |L19.430|
00019c  f1b80000          SUBS     r0,r8,#0
0001a0  f1a80801          SUB      r8,r8,#1
0001a4  d003              BEQ      |L19.430|
0001a6  487c              LDR      r0,|L19.920|
0001a8  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0001aa  2800              CMP      r0,#0
0001ac  d0ef              BEQ      |L19.398|
                  |L19.430|
;;;794                if (response_value != DAP_TRANSFER_OK) {
0001ae  2e01              CMP      r6,#1
0001b0  d000              BEQ      |L19.436|
;;;795                  break;
0001b2  e08d              B        |L19.720|
                  |L19.436|
;;;796                }
;;;797    #if (TIMESTAMP_CLOCK != 0U)
;;;798                // Store Timestamp
;;;799                if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;800                  timestamp = DAP_Data.timestamp;
;;;801                  *response++ = (uint8_t) timestamp;
;;;802                  *response++ = (uint8_t)(timestamp >>  8);
;;;803                  *response++ = (uint8_t)(timestamp >> 16);
;;;804                  *response++ = (uint8_t)(timestamp >> 24);
;;;805                }
;;;806    #endif
;;;807                post_read = 1U;
0001b4  f04f0b01          MOV      r11,#1
0001b8  e022              B        |L19.512|
                  |L19.442|
;;;808              }
;;;809            } else {
;;;810              // Read DP register
;;;811              do {
0001ba  bf00              NOP      
                  |L19.444|
;;;812                response_value = SWD_Transfer(request_value, &data);
0001bc  a901              ADD      r1,sp,#4
0001be  4638              MOV      r0,r7
0001c0  f7fffffe          BL       SWD_Transfer
0001c4  4606              MOV      r6,r0
;;;813              } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
0001c6  2e02              CMP      r6,#2
0001c8  d108              BNE      |L19.476|
0001ca  f1b80000          SUBS     r0,r8,#0
0001ce  f1a80801          SUB      r8,r8,#1
0001d2  d003              BEQ      |L19.476|
0001d4  4870              LDR      r0,|L19.920|
0001d6  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0001d8  2800              CMP      r0,#0
0001da  d0ef              BEQ      |L19.444|
                  |L19.476|
;;;814              if (response_value != DAP_TRANSFER_OK) {
0001dc  2e01              CMP      r6,#1
0001de  d000              BEQ      |L19.482|
;;;815                break;
0001e0  e076              B        |L19.720|
                  |L19.482|
;;;816              }
;;;817    #if (TIMESTAMP_CLOCK != 0U)
;;;818              // Store Timestamp
;;;819              if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;820                timestamp = DAP_Data.timestamp;
;;;821                *response++ = (uint8_t) timestamp;
;;;822                *response++ = (uint8_t)(timestamp >>  8);
;;;823                *response++ = (uint8_t)(timestamp >> 16);
;;;824                *response++ = (uint8_t)(timestamp >> 24);
;;;825              }
;;;826    #endif
;;;827              // Store data
;;;828              *response++ = (uint8_t) data;
0001e2  9801              LDR      r0,[sp,#4]
0001e4  f8040b01          STRB     r0,[r4],#1
;;;829              *response++ = (uint8_t)(data >>  8);
0001e8  9801              LDR      r0,[sp,#4]
0001ea  0a00              LSRS     r0,r0,#8
0001ec  f8040b01          STRB     r0,[r4],#1
;;;830              *response++ = (uint8_t)(data >> 16);
0001f0  9801              LDR      r0,[sp,#4]
0001f2  0c00              LSRS     r0,r0,#16
0001f4  f8040b01          STRB     r0,[r4],#1
;;;831              *response++ = (uint8_t)(data >> 24);
0001f8  9801              LDR      r0,[sp,#4]
0001fa  0e00              LSRS     r0,r0,#24
0001fc  f8040b01          STRB     r0,[r4],#1
                  |L19.512|
;;;832            }
;;;833          }
;;;834          check_write = 0U;
000200  2000              MOVS     r0,#0
000202  9004              STR      r0,[sp,#0x10]
000204  e057              B        |L19.694|
                  |L19.518|
;;;835        } else {
;;;836          // Write register
;;;837          if (post_read) {
000206  f1bb0f00          CMP      r11,#0
00020a  d027              BEQ      |L19.604|
;;;838            // Read previous data
;;;839            retry = DAP_Data.transfer.retry_count;
00020c  4863              LDR      r0,|L19.924|
00020e  f8b08010          LDRH     r8,[r0,#0x10]
;;;840            do {
000212  bf00              NOP      
                  |L19.532|
;;;841              response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000214  a901              ADD      r1,sp,#4
000216  200e              MOVS     r0,#0xe
000218  f7fffffe          BL       SWD_Transfer
00021c  4606              MOV      r6,r0
;;;842            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00021e  2e02              CMP      r6,#2
000220  d108              BNE      |L19.564|
000222  f1b80000          SUBS     r0,r8,#0
000226  f1a80801          SUB      r8,r8,#1
00022a  d003              BEQ      |L19.564|
00022c  485a              LDR      r0,|L19.920|
00022e  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000230  2800              CMP      r0,#0
000232  d0ef              BEQ      |L19.532|
                  |L19.564|
;;;843            if (response_value != DAP_TRANSFER_OK) {
000234  2e01              CMP      r6,#1
000236  d000              BEQ      |L19.570|
;;;844              break;
000238  e04a              B        |L19.720|
                  |L19.570|
;;;845            }
;;;846            // Store previous data
;;;847            *response++ = (uint8_t) data;
00023a  9801              LDR      r0,[sp,#4]
00023c  f8040b01          STRB     r0,[r4],#1
;;;848            *response++ = (uint8_t)(data >>  8);
000240  9801              LDR      r0,[sp,#4]
000242  0a00              LSRS     r0,r0,#8
000244  f8040b01          STRB     r0,[r4],#1
;;;849            *response++ = (uint8_t)(data >> 16);
000248  9801              LDR      r0,[sp,#4]
00024a  0c00              LSRS     r0,r0,#16
00024c  f8040b01          STRB     r0,[r4],#1
;;;850            *response++ = (uint8_t)(data >> 24);
000250  9801              LDR      r0,[sp,#4]
000252  0e00              LSRS     r0,r0,#24
000254  f8040b01          STRB     r0,[r4],#1
;;;851            post_read = 0U;
000258  f04f0b00          MOV      r11,#0
                  |L19.604|
;;;852          }
;;;853          // Load data
;;;854          data = (uint32_t)(*(request+0) <<  0) |
00025c  7828              LDRB     r0,[r5,#0]
00025e  7869              LDRB     r1,[r5,#1]
000260  ea402001          ORR      r0,r0,r1,LSL #8
000264  78a9              LDRB     r1,[r5,#2]
000266  ea404001          ORR      r0,r0,r1,LSL #16
00026a  78e9              LDRB     r1,[r5,#3]
00026c  ea406001          ORR      r0,r0,r1,LSL #24
000270  9001              STR      r0,[sp,#4]
;;;855                 (uint32_t)(*(request+1) <<  8) |
;;;856                 (uint32_t)(*(request+2) << 16) |
;;;857                 (uint32_t)(*(request+3) << 24);
;;;858          request += 4;
000272  1d2d              ADDS     r5,r5,#4
;;;859          if ((request_value & DAP_TRANSFER_MATCH_MASK) != 0U) {
000274  f0070020          AND      r0,r7,#0x20
000278  b120              CBZ      r0,|L19.644|
;;;860            // Write match mask
;;;861            DAP_Data.transfer.match_mask = data;
00027a  4848              LDR      r0,|L19.924|
00027c  9901              LDR      r1,[sp,#4]
00027e  6141              STR      r1,[r0,#0x14]
;;;862            response_value = DAP_TRANSFER_OK;
000280  2601              MOVS     r6,#1
000282  e018              B        |L19.694|
                  |L19.644|
;;;863          } else {
;;;864            // Write DP/AP register
;;;865            retry = DAP_Data.transfer.retry_count;
000284  4845              LDR      r0,|L19.924|
000286  f8b08010          LDRH     r8,[r0,#0x10]
;;;866            do {
00028a  bf00              NOP      
                  |L19.652|
;;;867              response_value = SWD_Transfer(request_value, &data);
00028c  a901              ADD      r1,sp,#4
00028e  4638              MOV      r0,r7
000290  f7fffffe          BL       SWD_Transfer
000294  4606              MOV      r6,r0
;;;868            } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000296  2e02              CMP      r6,#2
000298  d108              BNE      |L19.684|
00029a  f1b80000          SUBS     r0,r8,#0
00029e  f1a80801          SUB      r8,r8,#1
0002a2  d003              BEQ      |L19.684|
0002a4  483c              LDR      r0,|L19.920|
0002a6  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0002a8  2800              CMP      r0,#0
0002aa  d0ef              BEQ      |L19.652|
                  |L19.684|
;;;869            if (response_value != DAP_TRANSFER_OK) {
0002ac  2e01              CMP      r6,#1
0002ae  d000              BEQ      |L19.690|
;;;870              break;
0002b0  e00e              B        |L19.720|
                  |L19.690|
;;;871            }
;;;872    #if (TIMESTAMP_CLOCK != 0U)
;;;873            // Store Timestamp
;;;874            if ((request_value & DAP_TRANSFER_TIMESTAMP) != 0U) {
;;;875              timestamp = DAP_Data.timestamp;
;;;876              *response++ = (uint8_t) timestamp;
;;;877              *response++ = (uint8_t)(timestamp >>  8);
;;;878              *response++ = (uint8_t)(timestamp >> 16);
;;;879              *response++ = (uint8_t)(timestamp >> 24);
;;;880            }
;;;881    #endif
;;;882            check_write = 1U;
0002b2  2001              MOVS     r0,#1
0002b4  9004              STR      r0,[sp,#0x10]
                  |L19.694|
;;;883          }
;;;884        }
;;;885        response_count++;
0002b6  9805              LDR      r0,[sp,#0x14]
0002b8  1c40              ADDS     r0,r0,#1
0002ba  9005              STR      r0,[sp,#0x14]
;;;886        if (DAP_TransferAbort) {
0002bc  4836              LDR      r0,|L19.920|
0002be  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0002c0  b100              CBZ      r0,|L19.708|
;;;887          break;
0002c2  e005              B        |L19.720|
                  |L19.708|
0002c4  f1a90901          SUB      r9,r9,#1              ;710
                  |L19.712|
0002c8  f1b90f00          CMP      r9,#0                 ;710
0002cc  f47faeab          BNE      |L19.38|
                  |L19.720|
0002d0  bf00              NOP                            ;730
;;;888        }
;;;889      }
;;;890    
;;;891      for (; request_count != 0U; request_count--) {
0002d2  e00c              B        |L19.750|
                  |L19.724|
;;;892        // Process canceled requests
;;;893        request_value = *request++;
0002d4  f8157b01          LDRB     r7,[r5],#1
;;;894        if ((request_value & DAP_TRANSFER_RnW) != 0U) {
0002d8  f0070002          AND      r0,r7,#2
0002dc  b120              CBZ      r0,|L19.744|
;;;895          // Read register
;;;896          if ((request_value & DAP_TRANSFER_MATCH_VALUE) != 0U) {
0002de  f0070010          AND      r0,r7,#0x10
0002e2  b110              CBZ      r0,|L19.746|
;;;897            // Read with value match
;;;898            request += 4;
0002e4  1d2d              ADDS     r5,r5,#4
0002e6  e000              B        |L19.746|
                  |L19.744|
;;;899          }
;;;900        } else {
;;;901          // Write register
;;;902          request += 4;
0002e8  1d2d              ADDS     r5,r5,#4
                  |L19.746|
0002ea  f1a90901          SUB      r9,r9,#1              ;891
                  |L19.750|
0002ee  f1b90f00          CMP      r9,#0                 ;891
0002f2  d1ef              BNE      |L19.724|
;;;903        }
;;;904      }
;;;905    
;;;906      if (response_value == DAP_TRANSFER_OK) {
0002f4  2e01              CMP      r6,#1
0002f6  d13f              BNE      |L19.888|
;;;907        if (post_read) {
0002f8  f1bb0f00          CMP      r11,#0
0002fc  d026              BEQ      |L19.844|
;;;908          // Read previous data
;;;909          retry = DAP_Data.transfer.retry_count;
0002fe  4827              LDR      r0,|L19.924|
000300  f8b08010          LDRH     r8,[r0,#0x10]
;;;910          do {
000304  bf00              NOP      
                  |L19.774|
;;;911            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, &data);
000306  a901              ADD      r1,sp,#4
000308  200e              MOVS     r0,#0xe
00030a  f7fffffe          BL       SWD_Transfer
00030e  4606              MOV      r6,r0
;;;912          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000310  2e02              CMP      r6,#2
000312  d108              BNE      |L19.806|
000314  f1b80000          SUBS     r0,r8,#0
000318  f1a80801          SUB      r8,r8,#1
00031c  d003              BEQ      |L19.806|
00031e  481e              LDR      r0,|L19.920|
000320  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000322  2800              CMP      r0,#0
000324  d0ef              BEQ      |L19.774|
                  |L19.806|
;;;913          if (response_value != DAP_TRANSFER_OK) {
000326  2e01              CMP      r6,#1
000328  d000              BEQ      |L19.812|
;;;914            goto end;
00032a  e026              B        |L19.890|
                  |L19.812|
;;;915          }
;;;916          // Store previous data
;;;917          *response++ = (uint8_t) data;
00032c  9801              LDR      r0,[sp,#4]
00032e  f8040b01          STRB     r0,[r4],#1
;;;918          *response++ = (uint8_t)(data >>  8);
000332  9801              LDR      r0,[sp,#4]
000334  0a00              LSRS     r0,r0,#8
000336  f8040b01          STRB     r0,[r4],#1
;;;919          *response++ = (uint8_t)(data >> 16);
00033a  9801              LDR      r0,[sp,#4]
00033c  0c00              LSRS     r0,r0,#16
00033e  f8040b01          STRB     r0,[r4],#1
;;;920          *response++ = (uint8_t)(data >> 24);
000342  9801              LDR      r0,[sp,#4]
000344  0e00              LSRS     r0,r0,#24
000346  f8040b01          STRB     r0,[r4],#1
00034a  e015              B        |L19.888|
                  |L19.844|
;;;921        } else if (check_write) {
00034c  9804              LDR      r0,[sp,#0x10]
00034e  b198              CBZ      r0,|L19.888|
;;;922          // Check last write
;;;923          retry = DAP_Data.transfer.retry_count;
000350  4812              LDR      r0,|L19.924|
000352  f8b08010          LDRH     r8,[r0,#0x10]
;;;924          do {
000356  bf00              NOP      
                  |L19.856|
;;;925            response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
000358  2100              MOVS     r1,#0
00035a  200e              MOVS     r0,#0xe
00035c  f7fffffe          BL       SWD_Transfer
000360  4606              MOV      r6,r0
;;;926          } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000362  2e02              CMP      r6,#2
000364  d108              BNE      |L19.888|
000366  f1b80000          SUBS     r0,r8,#0
00036a  f1a80801          SUB      r8,r8,#1
00036e  d003              BEQ      |L19.888|
000370  4809              LDR      r0,|L19.920|
000372  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000374  2800              CMP      r0,#0
000376  d0ef              BEQ      |L19.856|
                  |L19.888|
;;;927        }
;;;928      }
;;;929    
;;;930    end:
000378  bf00              NOP      
                  |L19.890|
;;;931      *(response_head+0) = (uint8_t)response_count;
00037a  9805              LDR      r0,[sp,#0x14]
00037c  f88a0000          STRB     r0,[r10,#0]
;;;932      *(response_head+1) = (uint8_t)response_value;
000380  f88a6001          STRB     r6,[r10,#1]
;;;933    
;;;934      return (((uint32_t)(request - request_head) << 16) | (uint32_t)(response - response_head));
000384  eba4010a          SUB      r1,r4,r10
000388  9806              LDR      r0,[sp,#0x18]
00038a  1a28              SUBS     r0,r5,r0
00038c  ea414000          ORR      r0,r1,r0,LSL #16
;;;935    }
000390  b007              ADD      sp,sp,#0x1c
000392  e8bd8ff0          POP      {r4-r11,pc}
;;;936    #endif
                          ENDP

000396  0000              DCW      0x0000
                  |L19.920|
                          DCD      DAP_TransferAbort
                  |L19.924|
                          DCD      DAP_Data

                          AREA ||i.DAP_SWD_TransferBlock||, CODE, READONLY, ALIGN=2

                  DAP_SWD_TransferBlock PROC
;;;1285   #if (DAP_SWD != 0)
;;;1286   static uint32_t DAP_SWD_TransferBlock(const uint8_t *request, uint8_t *response) {
000000  e92d4ff8          PUSH     {r3-r11,lr}
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;1287     uint32_t  request_count;
;;;1288     uint32_t  request_value;
;;;1289     uint32_t  response_count;
;;;1290     uint32_t  response_value;
;;;1291     uint8_t  *response_head;
;;;1292     uint32_t  retry;
;;;1293     uint32_t  data;
;;;1294   
;;;1295     response_count = 0U;
000008  f04f0b00          MOV      r11,#0
;;;1296     response_value = 0U;
00000c  2600              MOVS     r6,#0
;;;1297     response_head  = response;
00000e  46a8              MOV      r8,r5
;;;1298     response      += 3;
000010  1ced              ADDS     r5,r5,#3
;;;1299   
;;;1300     DAP_TransferAbort = 0U;
000012  2000              MOVS     r0,#0
000014  4956              LDR      r1,|L20.368|
000016  7008              STRB     r0,[r1,#0]
;;;1301   
;;;1302     request++;            // Ignore DAP index
000018  1c64              ADDS     r4,r4,#1
;;;1303   
;;;1304     request_count = (uint32_t)(*(request+0) << 0) |
00001a  7820              LDRB     r0,[r4,#0]
00001c  7861              LDRB     r1,[r4,#1]
00001e  ea402a01          ORR      r10,r0,r1,LSL #8
;;;1305                     (uint32_t)(*(request+1) << 8);
;;;1306     request += 2;
000022  1ca4              ADDS     r4,r4,#2
;;;1307     if (request_count == 0U) {
000024  f1ba0f00          CMP      r10,#0
000028  d100              BNE      |L20.44|
;;;1308       goto end;
00002a  e095              B        |L20.344|
                  |L20.44|
;;;1309     }
;;;1310   
;;;1311     request_value = *request++;
00002c  f8147b01          LDRB     r7,[r4],#1
;;;1312     if ((request_value & DAP_TRANSFER_RnW) != 0U) {
000030  f0070002          AND      r0,r7,#2
000034  2800              CMP      r0,#0
000036  d04f              BEQ      |L20.216|
;;;1313       // Read register block
;;;1314       if ((request_value & DAP_TRANSFER_APnDP) != 0U) {
000038  f0070001          AND      r0,r7,#1
00003c  b1b0              CBZ      r0,|L20.108|
;;;1315         // Post AP read
;;;1316         retry = DAP_Data.transfer.retry_count;
00003e  484d              LDR      r0,|L20.372|
000040  f8b09010          LDRH     r9,[r0,#0x10]
;;;1317         do {
000044  bf00              NOP      
                  |L20.70|
;;;1318           response_value = SWD_Transfer(request_value, NULL);
000046  2100              MOVS     r1,#0
000048  4638              MOV      r0,r7
00004a  f7fffffe          BL       SWD_Transfer
00004e  4606              MOV      r6,r0
;;;1319         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000050  2e02              CMP      r6,#2
000052  d108              BNE      |L20.102|
000054  f1b90000          SUBS     r0,r9,#0
000058  f1a90901          SUB      r9,r9,#1
00005c  d003              BEQ      |L20.102|
00005e  4844              LDR      r0,|L20.368|
000060  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000062  2800              CMP      r0,#0
000064  d0ef              BEQ      |L20.70|
                  |L20.102|
;;;1320         if (response_value != DAP_TRANSFER_OK) {
000066  2e01              CMP      r6,#1
000068  d000              BEQ      |L20.108|
;;;1321           goto end;
00006a  e075              B        |L20.344|
                  |L20.108|
;;;1322         }
;;;1323       }
;;;1324       while (request_count--) {
00006c  e02e              B        |L20.204|
                  |L20.110|
;;;1325         // Read DP/AP register
;;;1326         if ((request_count == 0U) && ((request_value & DAP_TRANSFER_APnDP) != 0U)) {
00006e  f1ba0f00          CMP      r10,#0
000072  d103              BNE      |L20.124|
000074  f0070001          AND      r0,r7,#1
000078  b100              CBZ      r0,|L20.124|
;;;1327           // Last AP read
;;;1328           request_value = DP_RDBUFF | DAP_TRANSFER_RnW;
00007a  270e              MOVS     r7,#0xe
                  |L20.124|
;;;1329         }
;;;1330         retry = DAP_Data.transfer.retry_count;
00007c  483d              LDR      r0,|L20.372|
00007e  f8b09010          LDRH     r9,[r0,#0x10]
;;;1331         do {
000082  bf00              NOP      
                  |L20.132|
;;;1332           response_value = SWD_Transfer(request_value, &data);
000084  4669              MOV      r1,sp
000086  4638              MOV      r0,r7
000088  f7fffffe          BL       SWD_Transfer
00008c  4606              MOV      r6,r0
;;;1333         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
00008e  2e02              CMP      r6,#2
000090  d108              BNE      |L20.164|
000092  f1b90000          SUBS     r0,r9,#0
000096  f1a90901          SUB      r9,r9,#1
00009a  d003              BEQ      |L20.164|
00009c  4834              LDR      r0,|L20.368|
00009e  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
0000a0  2800              CMP      r0,#0
0000a2  d0ef              BEQ      |L20.132|
                  |L20.164|
;;;1334         if (response_value != DAP_TRANSFER_OK) {
0000a4  2e01              CMP      r6,#1
0000a6  d000              BEQ      |L20.170|
;;;1335           goto end;
0000a8  e056              B        |L20.344|
                  |L20.170|
;;;1336         }
;;;1337         // Store data
;;;1338         *response++ = (uint8_t) data;
0000aa  9800              LDR      r0,[sp,#0]
0000ac  f8050b01          STRB     r0,[r5],#1
;;;1339         *response++ = (uint8_t)(data >>  8);
0000b0  9800              LDR      r0,[sp,#0]
0000b2  0a00              LSRS     r0,r0,#8
0000b4  f8050b01          STRB     r0,[r5],#1
;;;1340         *response++ = (uint8_t)(data >> 16);
0000b8  9800              LDR      r0,[sp,#0]
0000ba  0c00              LSRS     r0,r0,#16
0000bc  f8050b01          STRB     r0,[r5],#1
;;;1341         *response++ = (uint8_t)(data >> 24);
0000c0  9800              LDR      r0,[sp,#0]
0000c2  0e00              LSRS     r0,r0,#24
0000c4  f8050b01          STRB     r0,[r5],#1
;;;1342         response_count++;
0000c8  f10b0b01          ADD      r11,r11,#1
                  |L20.204|
0000cc  f1ba0000          SUBS     r0,r10,#0             ;1324
0000d0  f1aa0a01          SUB      r10,r10,#1            ;1324
0000d4  d1cb              BNE      |L20.110|
0000d6  e03e              B        |L20.342|
                  |L20.216|
;;;1343       }
;;;1344     } else {
;;;1345       // Write register block
;;;1346       while (request_count--) {
0000d8  e024              B        |L20.292|
                  |L20.218|
;;;1347         // Load data
;;;1348         data = (uint32_t)(*(request+0) <<  0) |
0000da  7820              LDRB     r0,[r4,#0]
0000dc  7861              LDRB     r1,[r4,#1]
0000de  ea402001          ORR      r0,r0,r1,LSL #8
0000e2  78a1              LDRB     r1,[r4,#2]
0000e4  ea404001          ORR      r0,r0,r1,LSL #16
0000e8  78e1              LDRB     r1,[r4,#3]
0000ea  ea406001          ORR      r0,r0,r1,LSL #24
0000ee  9000              STR      r0,[sp,#0]
;;;1349                (uint32_t)(*(request+1) <<  8) |
;;;1350                (uint32_t)(*(request+2) << 16) |
;;;1351                (uint32_t)(*(request+3) << 24);
;;;1352         request += 4;
0000f0  1d24              ADDS     r4,r4,#4
;;;1353         // Write DP/AP register
;;;1354         retry = DAP_Data.transfer.retry_count;
0000f2  4820              LDR      r0,|L20.372|
0000f4  f8b09010          LDRH     r9,[r0,#0x10]
;;;1355         do {
0000f8  bf00              NOP      
                  |L20.250|
;;;1356           response_value = SWD_Transfer(request_value, &data);
0000fa  4669              MOV      r1,sp
0000fc  4638              MOV      r0,r7
0000fe  f7fffffe          BL       SWD_Transfer
000102  4606              MOV      r6,r0
;;;1357         } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000104  2e02              CMP      r6,#2
000106  d108              BNE      |L20.282|
000108  f1b90000          SUBS     r0,r9,#0
00010c  f1a90901          SUB      r9,r9,#1
000110  d003              BEQ      |L20.282|
000112  4817              LDR      r0,|L20.368|
000114  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000116  2800              CMP      r0,#0
000118  d0ef              BEQ      |L20.250|
                  |L20.282|
;;;1358         if (response_value != DAP_TRANSFER_OK) {
00011a  2e01              CMP      r6,#1
00011c  d000              BEQ      |L20.288|
;;;1359           goto end;
00011e  e01b              B        |L20.344|
                  |L20.288|
;;;1360         }
;;;1361         response_count++;
000120  f10b0b01          ADD      r11,r11,#1
                  |L20.292|
000124  f1ba0000          SUBS     r0,r10,#0             ;1346
000128  f1aa0a01          SUB      r10,r10,#1            ;1346
00012c  d1d5              BNE      |L20.218|
;;;1362       }
;;;1363       // Check last write
;;;1364       retry = DAP_Data.transfer.retry_count;
00012e  4811              LDR      r0,|L20.372|
000130  f8b09010          LDRH     r9,[r0,#0x10]
;;;1365       do {
000134  bf00              NOP      
                  |L20.310|
;;;1366         response_value = SWD_Transfer(DP_RDBUFF | DAP_TRANSFER_RnW, NULL);
000136  2100              MOVS     r1,#0
000138  200e              MOVS     r0,#0xe
00013a  f7fffffe          BL       SWD_Transfer
00013e  4606              MOV      r6,r0
;;;1367       } while ((response_value == DAP_TRANSFER_WAIT) && retry-- && !DAP_TransferAbort);
000140  2e02              CMP      r6,#2
000142  d108              BNE      |L20.342|
000144  f1b90000          SUBS     r0,r9,#0
000148  f1a90901          SUB      r9,r9,#1
00014c  d003              BEQ      |L20.342|
00014e  4808              LDR      r0,|L20.368|
000150  7800              LDRB     r0,[r0,#0]  ; DAP_TransferAbort
000152  2800              CMP      r0,#0
000154  d0ef              BEQ      |L20.310|
                  |L20.342|
;;;1368     }
;;;1369   
;;;1370   end:
000156  bf00              NOP      
                  |L20.344|
;;;1371     *(response_head+0) = (uint8_t)(response_count >> 0);
000158  f888b000          STRB     r11,[r8,#0]
;;;1372     *(response_head+1) = (uint8_t)(response_count >> 8);
00015c  ea4f201b          LSR      r0,r11,#8
000160  f8880001          STRB     r0,[r8,#1]
;;;1373     *(response_head+2) = (uint8_t) response_value;
000164  f8886002          STRB     r6,[r8,#2]
;;;1374   
;;;1375     return ((uint32_t)(response - response_head));
000168  eba50008          SUB      r0,r5,r8
;;;1376   }
00016c  e8bd8ff8          POP      {r3-r11,pc}
;;;1377   #endif
                          ENDP

                  |L20.368|
                          DCD      DAP_TransferAbort
                  |L20.372|
                          DCD      DAP_Data

                          AREA ||i.DAP_SWD_WriteAbort||, CODE, READONLY, ALIGN=1

                  DAP_SWD_WriteAbort PROC
;;;1536   #if (DAP_SWD != 0)
;;;1537   static uint32_t DAP_SWD_WriteAbort(const uint8_t *request, uint8_t *response) {
000000  b538              PUSH     {r3-r5,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
;;;1538     uint32_t data;
;;;1539   
;;;1540     // Load data (Ignore DAP index)
;;;1541     data = (uint32_t)(*(request+1) <<  0) |
000006  7860              LDRB     r0,[r4,#1]
000008  78a1              LDRB     r1,[r4,#2]
00000a  ea402001          ORR      r0,r0,r1,LSL #8
00000e  78e1              LDRB     r1,[r4,#3]
000010  ea404001          ORR      r0,r0,r1,LSL #16
000014  7921              LDRB     r1,[r4,#4]
000016  ea406001          ORR      r0,r0,r1,LSL #24
00001a  9000              STR      r0,[sp,#0]
;;;1542            (uint32_t)(*(request+2) <<  8) |
;;;1543            (uint32_t)(*(request+3) << 16) |
;;;1544            (uint32_t)(*(request+4) << 24);
;;;1545   
;;;1546     // Write Abort register
;;;1547     SWD_Transfer(DP_ABORT, &data);
00001c  4669              MOV      r1,sp
00001e  2000              MOVS     r0,#0
000020  f7fffffe          BL       SWD_Transfer
;;;1548   
;;;1549     *response = DAP_OK;
000024  2000              MOVS     r0,#0
000026  7028              STRB     r0,[r5,#0]
;;;1550     return (1U);
000028  2001              MOVS     r0,#1
;;;1551   }
00002a  bd38              POP      {r3-r5,pc}
;;;1552   #endif
                          ENDP


                          AREA ||i.DAP_SWJ_Clock||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Clock PROC
;;;384    //             number of bytes in request (upper 16 bits)
;;;385    static uint32_t DAP_SWJ_Clock(const uint8_t *request, uint8_t *response) {
000000  b530              PUSH     {r4,r5,lr}
000002  4602              MOV      r2,r0
000004  460c              MOV      r4,r1
;;;386    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;387      uint32_t clock;
;;;388      uint32_t delay;
;;;389    
;;;390      clock = (uint32_t)(*(request+0) <<  0) |
000006  7810              LDRB     r0,[r2,#0]
000008  7855              LDRB     r5,[r2,#1]
00000a  ea402005          ORR      r0,r0,r5,LSL #8
00000e  7895              LDRB     r5,[r2,#2]
000010  ea404005          ORR      r0,r0,r5,LSL #16
000014  78d5              LDRB     r5,[r2,#3]
000016  ea406305          ORR      r3,r0,r5,LSL #24
;;;391              (uint32_t)(*(request+1) <<  8) |
;;;392              (uint32_t)(*(request+2) << 16) |
;;;393              (uint32_t)(*(request+3) << 24);
;;;394    
;;;395      if (clock == 0U) {
00001a  b91b              CBNZ     r3,|L22.36|
;;;396        *response = DAP_ERROR;
00001c  20ff              MOVS     r0,#0xff
00001e  7020              STRB     r0,[r4,#0]
;;;397        return ((4U << 16) | 1U);
000020  4812              LDR      r0,|L22.108|
                  |L22.34|
;;;398      }
;;;399    
;;;400      if (clock >= MAX_SWJ_CLOCK(DELAY_FAST_CYCLES)) {
;;;401        DAP_Data.fast_clock  = 1U;
;;;402        DAP_Data.clock_delay = 1U;
;;;403      } else {
;;;404        DAP_Data.fast_clock  = 0U;
;;;405    
;;;406        delay = ((CPU_CLOCK/2U) + (clock - 1U)) / clock;
;;;407        if (delay > IO_PORT_WRITE_CYCLES) {
;;;408          delay -= IO_PORT_WRITE_CYCLES;
;;;409          delay  = (delay + (DELAY_SLOW_CYCLES - 1U)) / DELAY_SLOW_CYCLES;
;;;410        } else {
;;;411          delay  = 1U;
;;;412        }
;;;413    
;;;414        DAP_Data.clock_delay = delay;
;;;415      }
;;;416    
;;;417      *response = DAP_OK;
;;;418    #else
;;;419      *response = DAP_ERROR;
;;;420    #endif
;;;421    
;;;422      return ((4U << 16) | 1U);
;;;423    }
000022  bd30              POP      {r4,r5,pc}
                  |L22.36|
000024  4812              LDR      r0,|L22.112|
000026  6800              LDR      r0,[r0,#0]            ;400  ; SystemCoreClock
000028  ebb30f90          CMP      r3,r0,LSR #2          ;400
00002c  d304              BCC      |L22.56|
00002e  2001              MOVS     r0,#1                 ;401
000030  4d10              LDR      r5,|L22.116|
000032  7068              STRB     r0,[r5,#1]            ;401
000034  6068              STR      r0,[r5,#4]            ;402  ; DAP_Data
000036  e014              B        |L22.98|
                  |L22.56|
000038  2000              MOVS     r0,#0                 ;404
00003a  4d0e              LDR      r5,|L22.116|
00003c  7068              STRB     r0,[r5,#1]            ;404
00003e  1e58              SUBS     r0,r3,#1              ;406
000040  4d0b              LDR      r5,|L22.112|
000042  682d              LDR      r5,[r5,#0]            ;406  ; SystemCoreClock
000044  eb000055          ADD      r0,r0,r5,LSR #1       ;406
000048  fbb0f1f3          UDIV     r1,r0,r3              ;406
00004c  2902              CMP      r1,#2                 ;407
00004e  d905              BLS      |L22.92|
000050  1e89              SUBS     r1,r1,#2              ;408
000052  1c88              ADDS     r0,r1,#2              ;409
000054  2503              MOVS     r5,#3                 ;409
000056  fbb0f1f5          UDIV     r1,r0,r5              ;409
00005a  e000              B        |L22.94|
                  |L22.92|
00005c  2101              MOVS     r1,#1                 ;411
                  |L22.94|
00005e  4805              LDR      r0,|L22.116|
000060  6041              STR      r1,[r0,#4]            ;414  ; DAP_Data
                  |L22.98|
000062  2000              MOVS     r0,#0                 ;417
000064  7020              STRB     r0,[r4,#0]            ;417
000066  4801              LDR      r0,|L22.108|
000068  e7db              B        |L22.34|
;;;424    
                          ENDP

00006a  0000              DCW      0x0000
                  |L22.108|
                          DCD      0x00040001
                  |L22.112|
                          DCD      SystemCoreClock
                  |L22.116|
                          DCD      DAP_Data

                          AREA ||i.DAP_SWJ_Pins||, CODE, READONLY, ALIGN=2

                  DAP_SWJ_Pins PROC
;;;281    //             number of bytes in request (upper 16 bits)
;;;282    static uint32_t DAP_SWJ_Pins(const uint8_t *request, uint8_t *response) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
;;;283    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;284      uint32_t value;
;;;285      uint32_t select;
;;;286      uint32_t wait;
;;;287      uint32_t timestamp;
;;;288      
;;;289      value  = (uint32_t) *(request+0);
000008  7834              LDRB     r4,[r6,#0]
;;;290      select = (uint32_t) *(request+1); 
00000a  7875              LDRB     r5,[r6,#1]
;;;291      wait   = (uint32_t)(*(request+2) <<  0) |
00000c  78b0              LDRB     r0,[r6,#2]
00000e  78f1              LDRB     r1,[r6,#3]
000010  ea402001          ORR      r0,r0,r1,LSL #8
000014  7931              LDRB     r1,[r6,#4]
000016  ea404001          ORR      r0,r0,r1,LSL #16
00001a  7971              LDRB     r1,[r6,#5]
00001c  ea406901          ORR      r9,r0,r1,LSL #24
;;;292               (uint32_t)(*(request+3) <<  8) |
;;;293               (uint32_t)(*(request+4) << 16) |
;;;294               (uint32_t)(*(request+5) << 24);
;;;295    
;;;296      if ((select & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
000020  f0050001          AND      r0,r5,#1
000024  b188              CBZ      r0,|L23.74|
;;;297        if ((value & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
000026  f0040001          AND      r0,r4,#1
00002a  b130              CBZ      r0,|L23.58|
;;;298          PIN_SWCLK_TCK_SET();
00002c  bf00              NOP      
00002e  f44f5000          MOV      r0,#0x2000
000032  4952              LDR      r1,|L23.380|
000034  6008              STR      r0,[r1,#0]
000036  bf00              NOP      
000038  e007              B        |L23.74|
                  |L23.58|
;;;299        } else {
;;;300          PIN_SWCLK_TCK_CLR();
00003a  bf00              NOP      
00003c  f44f5000          MOV      r0,#0x2000
000040  494e              LDR      r1,|L23.380|
000042  1d09              ADDS     r1,r1,#4
000044  6008              STR      r0,[r1,#0]
000046  bf00              NOP      
000048  bf00              NOP      
                  |L23.74|
;;;301        }
;;;302      }
;;;303      if ((select & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
00004a  f0050002          AND      r0,r5,#2
00004e  b188              CBZ      r0,|L23.116|
;;;304        if ((value & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
000050  f0040002          AND      r0,r4,#2
000054  b130              CBZ      r0,|L23.100|
;;;305          PIN_SWDIO_TMS_SET();
000056  bf00              NOP      
000058  f44f4080          MOV      r0,#0x4000
00005c  4947              LDR      r1,|L23.380|
00005e  6008              STR      r0,[r1,#0]
000060  bf00              NOP      
000062  e007              B        |L23.116|
                  |L23.100|
;;;306        } else {
;;;307          PIN_SWDIO_TMS_CLR();
000064  bf00              NOP      
000066  f44f4080          MOV      r0,#0x4000
00006a  4944              LDR      r1,|L23.380|
00006c  1d09              ADDS     r1,r1,#4
00006e  6008              STR      r0,[r1,#0]
000070  bf00              NOP      
000072  bf00              NOP      
                  |L23.116|
;;;308        }
;;;309      }
;;;310      if ((select & (1U << DAP_SWJ_TDI)) != 0U) {
000074  f0050004          AND      r0,r5,#4
000078  b170              CBZ      r0,|L23.152|
;;;311        PIN_TDI_OUT(value >> DAP_SWJ_TDI);
00007a  f3c40087          UBFX     r0,r4,#2,#8
00007e  f0000101          AND      r1,r0,#1
000082  b119              CBZ      r1,|L23.140|
000084  2180              MOVS     r1,#0x80
000086  4a3e              LDR      r2,|L23.384|
000088  6011              STR      r1,[r2,#0]
00008a  e003              B        |L23.148|
                  |L23.140|
00008c  2180              MOVS     r1,#0x80
00008e  4a3c              LDR      r2,|L23.384|
000090  1d12              ADDS     r2,r2,#4
000092  6011              STR      r1,[r2,#0]
                  |L23.148|
000094  bf00              NOP      
000096  bf00              NOP      
                  |L23.152|
;;;312      }
;;;313      if ((select & (1U << DAP_SWJ_nTRST)) != 0U) {
000098  f0050020          AND      r0,r5,#0x20
00009c  b118              CBZ      r0,|L23.166|
;;;314        PIN_nTRST_OUT(value >> DAP_SWJ_nTRST);
00009e  f3c41047          UBFX     r0,r4,#5,#8
0000a2  bf00              NOP      
0000a4  bf00              NOP      
                  |L23.166|
;;;315      }
;;;316      if ((select & (1U << DAP_SWJ_nRESET)) != 0U){
0000a6  f0050080          AND      r0,r5,#0x80
0000aa  b118              CBZ      r0,|L23.180|
;;;317        PIN_nRESET_OUT(value >> DAP_SWJ_nRESET);
0000ac  f3c410c7          UBFX     r0,r4,#7,#8
0000b0  f7fffffe          BL       vResetTarget
                  |L23.180|
;;;318      }
;;;319    
;;;320      if (wait != 0U) {
0000b4  f1b90f00          CMP      r9,#0
0000b8  d03e              BEQ      |L23.312|
;;;321    #if (TIMESTAMP_CLOCK != 0U)
;;;322        if (wait > 3000000U) { 
;;;323          wait = 3000000U;
;;;324        }
;;;325    #if (TIMESTAMP_CLOCK >= 1000000U)
;;;326        wait *= TIMESTAMP_CLOCK / 1000000U;
;;;327    #else
;;;328        wait /= 1000000U / TIMESTAMP_CLOCK;
;;;329    #endif
;;;330    #else
;;;331        wait  = 1U;
0000ba  f04f0901          MOV      r9,#1
;;;332    #endif
;;;333        timestamp = TIMESTAMP_GET();
0000be  bf00              NOP      
0000c0  4830              LDR      r0,|L23.388|
0000c2  6847              LDR      r7,[r0,#4]
0000c4  bf00              NOP      
;;;334        do {
0000c6  bf00              NOP      
                  |L23.200|
;;;335          if ((select & (1U << DAP_SWJ_SWCLK_TCK)) != 0U) {
0000c8  f0050001          AND      r0,r5,#1
0000cc  b120              CBZ      r0,|L23.216|
;;;336            if ((value >> DAP_SWJ_SWCLK_TCK) ^ PIN_SWCLK_TCK_IN()) {
0000ce  f7fffffe          BL       PIN_SWCLK_TCK_IN
0000d2  4060              EORS     r0,r0,r4
0000d4  b100              CBZ      r0,|L23.216|
;;;337              continue;
0000d6  e028              B        |L23.298|
                  |L23.216|
;;;338            }
;;;339          }
;;;340          if ((select & (1U << DAP_SWJ_SWDIO_TMS)) != 0U) {
0000d8  f0050002          AND      r0,r5,#2
0000dc  b128              CBZ      r0,|L23.234|
;;;341            if ((value >> DAP_SWJ_SWDIO_TMS) ^ PIN_SWDIO_TMS_IN()) {
0000de  f7fffffe          BL       PIN_SWDIO_TMS_IN
0000e2  ea800054          EOR      r0,r0,r4,LSR #1
0000e6  b100              CBZ      r0,|L23.234|
;;;342              continue;
0000e8  e01f              B        |L23.298|
                  |L23.234|
;;;343            }
;;;344          }
;;;345          if ((select & (1U << DAP_SWJ_TDI)) != 0U) {
0000ea  f0050004          AND      r0,r5,#4
0000ee  b128              CBZ      r0,|L23.252|
;;;346            if ((value >> DAP_SWJ_TDI) ^ PIN_TDI_IN()) {
0000f0  f7fffffe          BL       PIN_TDI_IN
0000f4  ea800094          EOR      r0,r0,r4,LSR #2
0000f8  b100              CBZ      r0,|L23.252|
;;;347              continue;
0000fa  e016              B        |L23.298|
                  |L23.252|
;;;348            }
;;;349          }
;;;350          if ((select & (1U << DAP_SWJ_nTRST)) != 0U) {
0000fc  f0050020          AND      r0,r5,#0x20
000100  b128              CBZ      r0,|L23.270|
;;;351            if ((value >> DAP_SWJ_nTRST) ^ PIN_nTRST_IN()) {
000102  bf00              NOP      
000104  2000              MOVS     r0,#0
000106  ea801054          EOR      r0,r0,r4,LSR #5
00010a  b100              CBZ      r0,|L23.270|
;;;352              continue;
00010c  e00d              B        |L23.298|
                  |L23.270|
;;;353            }
;;;354          }
;;;355          if ((select & (1U << DAP_SWJ_nRESET)) != 0U) {
00010e  f0050080          AND      r0,r5,#0x80
000112  b148              CBZ      r0,|L23.296|
;;;356            if ((value >> DAP_SWJ_nRESET) ^ PIN_nRESET_IN()) {
000114  bf00              NOP      
000116  4819              LDR      r0,|L23.380|
000118  3808              SUBS     r0,r0,#8
00011a  6800              LDR      r0,[r0,#0]
00011c  f0000001          AND      r0,r0,#1
000120  ea8010d4          EOR      r0,r0,r4,LSR #7
000124  b100              CBZ      r0,|L23.296|
;;;357              continue;
000126  e000              B        |L23.298|
                  |L23.296|
;;;358            }
;;;359          }
;;;360          break;
000128  e005              B        |L23.310|
                  |L23.298|
;;;361        } while ((TIMESTAMP_GET() - timestamp) < wait);
00012a  bf00              NOP      
00012c  4815              LDR      r0,|L23.388|
00012e  6840              LDR      r0,[r0,#4]
000130  1bc0              SUBS     r0,r0,r7
000132  4548              CMP      r0,r9
000134  d3c8              BCC      |L23.200|
                  |L23.310|
000136  bf00              NOP                            ;360
                  |L23.312|
;;;362      }
;;;363    
;;;364      value = (PIN_SWCLK_TCK_IN() << DAP_SWJ_SWCLK_TCK) |
000138  f7fffffe          BL       PIN_SWCLK_TCK_IN
00013c  4682              MOV      r10,r0
00013e  f7fffffe          BL       PIN_SWDIO_TMS_IN
000142  ea4a0a40          ORR      r10,r10,r0,LSL #1
000146  f7fffffe          BL       PIN_TDI_IN
00014a  ea4a0180          ORR      r1,r10,r0,LSL #2
00014e  480c              LDR      r0,|L23.384|
000150  3808              SUBS     r0,r0,#8
000152  6800              LDR      r0,[r0,#0]
000154  f3c01040          UBFX     r0,r0,#5,#1
000158  ea4100c0          ORR      r0,r1,r0,LSL #3
00015c  2100              MOVS     r1,#0
00015e  ea401141          ORR      r1,r0,r1,LSL #5
000162  4806              LDR      r0,|L23.380|
000164  3808              SUBS     r0,r0,#8
000166  6800              LDR      r0,[r0,#0]
000168  f0000001          AND      r0,r0,#1
00016c  ea4114c0          ORR      r4,r1,r0,LSL #7
;;;365              (PIN_SWDIO_TMS_IN() << DAP_SWJ_SWDIO_TMS) |
;;;366              (PIN_TDI_IN()       << DAP_SWJ_TDI)       |
;;;367              (PIN_TDO_IN()       << DAP_SWJ_TDO)       |
;;;368              (PIN_nTRST_IN()     << DAP_SWJ_nTRST)     |
;;;369              (PIN_nRESET_IN()    << DAP_SWJ_nRESET);
;;;370    
;;;371      *response = (uint8_t)value;
000170  f8884000          STRB     r4,[r8,#0]
;;;372    #else
;;;373      *response = 0U;
;;;374    #endif
;;;375    
;;;376      return ((6U << 16) | 1U);
000174  4804              LDR      r0,|L23.392|
;;;377    }
000176  e8bd87f0          POP      {r4-r10,pc}
;;;378    
                          ENDP

00017a  0000              DCW      0x0000
                  |L23.380|
                          DCD      0x40010c10
                  |L23.384|
                          DCD      0x40010810
                  |L23.388|
                          DCD      0xe0001000
                  |L23.392|
                          DCD      0x00060001

                          AREA ||i.DAP_SWJ_Sequence||, CODE, READONLY, ALIGN=1

                  DAP_SWJ_Sequence PROC
;;;430    //             number of bytes in request (upper 16 bits)
;;;431    static uint32_t DAP_SWJ_Sequence(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460e              MOV      r6,r1
;;;432      uint32_t count;
;;;433    
;;;434      count = *request++;
000006  f8145b01          LDRB     r5,[r4],#1
;;;435      if (count == 0U) { 
00000a  b90d              CBNZ     r5,|L24.16|
;;;436        count = 256U;
00000c  f44f7580          MOV      r5,#0x100
                  |L24.16|
;;;437      }
;;;438    
;;;439    #if ((DAP_SWD != 0) || (DAP_JTAG != 0))
;;;440      SWJ_Sequence(count, request);
000010  4621              MOV      r1,r4
000012  4628              MOV      r0,r5
000014  f7fffffe          BL       SWJ_Sequence
;;;441      *response = DAP_OK;
000018  2000              MOVS     r0,#0
00001a  7030              STRB     r0,[r6,#0]
;;;442    #else
;;;443      *response = DAP_ERROR;
;;;444    #endif
;;;445    
;;;446      count = (count + 7U) >> 3;
00001c  1de8              ADDS     r0,r5,#7
00001e  08c5              LSRS     r5,r0,#3
;;;447    
;;;448      return (((count + 1U) << 16) | 1U);
000020  1c68              ADDS     r0,r5,#1
000022  0400              LSLS     r0,r0,#16
000024  1c40              ADDS     r0,r0,#1
;;;449    }
000026  bd70              POP      {r4-r6,pc}
;;;450    
                          ENDP


                          AREA ||i.DAP_Setup||, CODE, READONLY, ALIGN=2

                  DAP_Setup PROC
;;;1768   // Setup DAP
;;;1769   void DAP_Setup(void) {
000000  b510              PUSH     {r4,lr}
;;;1770   
;;;1771     // Default settings
;;;1772     DAP_Data.debug_port  = 0U;
000002  2000              MOVS     r0,#0
000004  490f              LDR      r1,|L25.68|
000006  7008              STRB     r0,[r1,#0]
;;;1773     DAP_Data.fast_clock  = 0U;
000008  7048              STRB     r0,[r1,#1]
;;;1774     DAP_Data.clock_delay = CLOCK_DELAY(DAP_DEFAULT_SWJ_CLOCK);
00000a  480f              LDR      r0,|L25.72|
00000c  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
00000e  0840              LSRS     r0,r0,#1
000010  490e              LDR      r1,|L25.76|
000012  fbb0f0f1          UDIV     r0,r0,r1
000016  1e80              SUBS     r0,r0,#2
000018  490a              LDR      r1,|L25.68|
00001a  6048              STR      r0,[r1,#4]  ; DAP_Data
;;;1775     DAP_Data.transfer.idle_cycles = 0U;
00001c  2000              MOVS     r0,#0
00001e  7308              STRB     r0,[r1,#0xc]
;;;1776     DAP_Data.transfer.retry_count = 100U;
000020  2164              MOVS     r1,#0x64
000022  4808              LDR      r0,|L25.68|
000024  8201              STRH     r1,[r0,#0x10]
;;;1777     DAP_Data.transfer.match_retry = 0U;
000026  2100              MOVS     r1,#0
000028  8241              STRH     r1,[r0,#0x12]
;;;1778     DAP_Data.transfer.match_mask  = 0x00000000U;
00002a  6141              STR      r1,[r0,#0x14]
;;;1779   #if (DAP_SWD != 0)
;;;1780     DAP_Data.swd_conf.turnaround  = 1U;
00002c  2001              MOVS     r0,#1
00002e  4905              LDR      r1,|L25.68|
000030  7608              STRB     r0,[r1,#0x18]
;;;1781     DAP_Data.swd_conf.data_phase  = 0U;
000032  2100              MOVS     r1,#0
000034  4803              LDR      r0,|L25.68|
000036  7641              STRB     r1,[r0,#0x19]
;;;1782   #endif
;;;1783   #if (DAP_JTAG != 0)
;;;1784     DAP_Data.jtag_dev.count = 0U;
000038  2000              MOVS     r0,#0
00003a  4902              LDR      r1,|L25.68|
00003c  7688              STRB     r0,[r1,#0x1a]
;;;1785   #endif
;;;1786   
;;;1787     DAP_SETUP();  // Device specific setup
00003e  f7fffffe          BL       PORT_OFF
;;;1788   }
000042  bd10              POP      {r4,pc}
                          ENDP

                  |L25.68|
                          DCD      DAP_Data
                  |L25.72|
                          DCD      SystemCoreClock
                  |L25.76|
                          DCD      0x00989680

                          AREA ||i.DAP_Transfer||, CODE, READONLY, ALIGN=2

                  DAP_Transfer PROC
;;;1257   //             number of bytes in request (upper 16 bits)
;;;1258   static uint32_t DAP_Transfer(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1259     uint32_t num;
;;;1260   
;;;1261     switch (DAP_Data.debug_port) {
000006  480e              LDR      r0,|L26.64|
000008  7800              LDRB     r0,[r0,#0]  ; DAP_Data
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L26.20|
00000e  2802              CMP      r0,#2
000010  d10c              BNE      |L26.44|
000012  e005              B        |L26.32|
                  |L26.20|
;;;1262   #if (DAP_SWD != 0)
;;;1263       case DAP_PORT_SWD:
;;;1264         num = DAP_SWD_Transfer(request, response);
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       DAP_SWD_Transfer
00001c  4604              MOV      r4,r0
;;;1265         break;
00001e  e00b              B        |L26.56|
                  |L26.32|
;;;1266   #endif
;;;1267   #if (DAP_JTAG != 0)
;;;1268       case DAP_PORT_JTAG:
;;;1269         num = DAP_JTAG_Transfer(request, response);
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DAP_JTAG_Transfer
000028  4604              MOV      r4,r0
;;;1270         break;
00002a  e005              B        |L26.56|
                  |L26.44|
;;;1271   #endif
;;;1272       default:
;;;1273         num = DAP_Dummy_Transfer(request, response);
00002c  4631              MOV      r1,r6
00002e  4628              MOV      r0,r5
000030  f7fffffe          BL       DAP_Dummy_Transfer
000034  4604              MOV      r4,r0
;;;1274         break;
000036  bf00              NOP      
                  |L26.56|
000038  bf00              NOP                            ;1265
;;;1275     }
;;;1276   
;;;1277     return (num);
00003a  4620              MOV      r0,r4
;;;1278   }
00003c  bd70              POP      {r4-r6,pc}
;;;1279   
                          ENDP

00003e  0000              DCW      0x0000
                  |L26.64|
                          DCD      DAP_Data

                          AREA ||i.DAP_TransferBlock||, CODE, READONLY, ALIGN=2

                  DAP_TransferBlock PROC
;;;1497   //             number of bytes in request (upper 16 bits)
;;;1498   static uint32_t DAP_TransferBlock(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460e              MOV      r6,r1
;;;1499     uint32_t num;
;;;1500   
;;;1501     switch (DAP_Data.debug_port) {
000006  4816              LDR      r0,|L27.96|
000008  7800              LDRB     r0,[r0,#0]  ; DAP_Data
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L27.20|
00000e  2802              CMP      r0,#2
000010  d10c              BNE      |L27.44|
000012  e005              B        |L27.32|
                  |L27.20|
;;;1502   #if (DAP_SWD != 0)
;;;1503       case DAP_PORT_SWD:
;;;1504         num = DAP_SWD_TransferBlock (request, response);
000014  4631              MOV      r1,r6
000016  4628              MOV      r0,r5
000018  f7fffffe          BL       DAP_SWD_TransferBlock
00001c  4604              MOV      r4,r0
;;;1505         break;
00001e  e00b              B        |L27.56|
                  |L27.32|
;;;1506   #endif
;;;1507   #if (DAP_JTAG != 0)
;;;1508       case DAP_PORT_JTAG:
;;;1509         num = DAP_JTAG_TransferBlock(request, response);
000020  4631              MOV      r1,r6
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       DAP_JTAG_TransferBlock
000028  4604              MOV      r4,r0
;;;1510         break;
00002a  e005              B        |L27.56|
                  |L27.44|
;;;1511   #endif
;;;1512       default:
;;;1513         *(response+0) = 0U;       // Response count [7:0]
00002c  2000              MOVS     r0,#0
00002e  7030              STRB     r0,[r6,#0]
;;;1514         *(response+1) = 0U;       // Response count[15:8]
000030  7070              STRB     r0,[r6,#1]
;;;1515         *(response+2) = 0U;       // Response value
000032  70b0              STRB     r0,[r6,#2]
;;;1516         num = 3U;
000034  2403              MOVS     r4,#3
;;;1517         break;
000036  bf00              NOP      
                  |L27.56|
000038  bf00              NOP                            ;1505
;;;1518     }
;;;1519   
;;;1520     if ((*(request+3) & DAP_TRANSFER_RnW) != 0U) {
00003a  78e8              LDRB     r0,[r5,#3]
00003c  f0000002          AND      r0,r0,#2
000040  b110              CBZ      r0,|L27.72|
;;;1521       // Read register block
;;;1522       num |=  4U << 16;
000042  f4442480          ORR      r4,r4,#0x40000
000046  e008              B        |L27.90|
                  |L27.72|
;;;1523     } else {
;;;1524       // Write register block
;;;1525       num |= (4U + (((uint32_t)(*(request+1)) | (uint32_t)(*(request+2) << 8)) * 4)) << 16;
000048  7868              LDRB     r0,[r5,#1]
00004a  78a9              LDRB     r1,[r5,#2]
00004c  ea402001          ORR      r0,r0,r1,LSL #8
000050  2104              MOVS     r1,#4
000052  eb010080          ADD      r0,r1,r0,LSL #2
000056  ea444400          ORR      r4,r4,r0,LSL #16
                  |L27.90|
;;;1526     }
;;;1527   
;;;1528     return (num);
00005a  4620              MOV      r0,r4
;;;1529   }
00005c  bd70              POP      {r4-r6,pc}
;;;1530   
                          ENDP

00005e  0000              DCW      0x0000
                  |L27.96|
                          DCD      DAP_Data

                          AREA ||i.DAP_TransferConfigure||, CODE, READONLY, ALIGN=2

                  DAP_TransferConfigure PROC
;;;656    //             number of bytes in request (upper 16 bits)
;;;657    static uint32_t DAP_TransferConfigure(const uint8_t *request, uint8_t *response) {
000000  4602              MOV      r2,r0
;;;658    
;;;659      DAP_Data.transfer.idle_cycles =            *(request+0);
000002  7810              LDRB     r0,[r2,#0]
000004  4b08              LDR      r3,|L28.40|
000006  7318              STRB     r0,[r3,#0xc]
;;;660      DAP_Data.transfer.retry_count = (uint16_t) *(request+1) |
000008  7850              LDRB     r0,[r2,#1]
00000a  7893              LDRB     r3,[r2,#2]
00000c  ea402303          ORR      r3,r0,r3,LSL #8
000010  4805              LDR      r0,|L28.40|
000012  8203              STRH     r3,[r0,#0x10]
;;;661                                      (uint16_t)(*(request+2) << 8);
;;;662      DAP_Data.transfer.match_retry = (uint16_t) *(request+3) | 
000014  78d0              LDRB     r0,[r2,#3]
000016  7913              LDRB     r3,[r2,#4]
000018  ea402303          ORR      r3,r0,r3,LSL #8
00001c  4802              LDR      r0,|L28.40|
00001e  8243              STRH     r3,[r0,#0x12]
;;;663                                      (uint16_t)(*(request+4) << 8);
;;;664    
;;;665      *response = DAP_OK;
000020  2000              MOVS     r0,#0
000022  7008              STRB     r0,[r1,#0]
;;;666      return ((5U << 16) | 1U); 
000024  4801              LDR      r0,|L28.44|
;;;667    }
000026  4770              BX       lr
;;;668    
                          ENDP

                  |L28.40|
                          DCD      DAP_Data
                  |L28.44|
                          DCD      0x00050001

                          AREA ||i.DAP_WriteAbort||, CODE, READONLY, ALIGN=2

                  DAP_WriteAbort PROC
;;;1592   //             number of bytes in request (upper 16 bits)
;;;1593   static uint32_t DAP_WriteAbort(const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460d              MOV      r5,r1
;;;1594     uint32_t num;
;;;1595   
;;;1596     switch (DAP_Data.debug_port) {
000006  480d              LDR      r0,|L29.60|
000008  7800              LDRB     r0,[r0,#0]  ; DAP_Data
00000a  2801              CMP      r0,#1
00000c  d002              BEQ      |L29.20|
00000e  2802              CMP      r0,#2
000010  d10c              BNE      |L29.44|
000012  e005              B        |L29.32|
                  |L29.20|
;;;1597   #if (DAP_SWD != 0)
;;;1598       case DAP_PORT_SWD:
;;;1599         num = DAP_SWD_WriteAbort (request, response);
000014  4629              MOV      r1,r5
000016  4630              MOV      r0,r6
000018  f7fffffe          BL       DAP_SWD_WriteAbort
00001c  4604              MOV      r4,r0
;;;1600         break;
00001e  e009              B        |L29.52|
                  |L29.32|
;;;1601   #endif
;;;1602   #if (DAP_JTAG != 0)
;;;1603       case DAP_PORT_JTAG:
;;;1604         num = DAP_JTAG_WriteAbort(request, response);
000020  4629              MOV      r1,r5
000022  4630              MOV      r0,r6
000024  f7fffffe          BL       DAP_JTAG_WriteAbort
000028  4604              MOV      r4,r0
;;;1605         break;
00002a  e003              B        |L29.52|
                  |L29.44|
;;;1606   #endif
;;;1607       default:
;;;1608         *response = DAP_ERROR;
00002c  20ff              MOVS     r0,#0xff
00002e  7028              STRB     r0,[r5,#0]
;;;1609         num = 1U;
000030  2401              MOVS     r4,#1
;;;1610         break;
000032  bf00              NOP      
                  |L29.52|
000034  bf00              NOP                            ;1600
;;;1611     }
;;;1612     return ((5U << 16) | num);
000036  f44420a0          ORR      r0,r4,#0x50000
;;;1613   }
00003a  bd70              POP      {r4-r6,pc}
;;;1614   
                          ENDP

                  |L29.60|
                          DCD      DAP_Data

                          AREA ||i.Delayms||, CODE, READONLY, ALIGN=2

                  Delayms PROC
;;;166    //    delay:  delay time in ms
;;;167    void Delayms(uint32_t delay) {
000000  4907              LDR      r1,|L30.32|
;;;168    	delay *= (CPU_CLOCK/(DELAY_SLOW_CYCLES*3000)); //aligned for 72MHz
000002  6809              LDR      r1,[r1,#0]  ; SystemCoreClock
000004  f2423228          MOV      r2,#0x2328
000008  fbb1f1f2          UDIV     r1,r1,r2
00000c  4348              MULS     r0,r1,r0
;;;169      PIN_DELAY_SLOW(delay);
00000e  4601              MOV      r1,r0
000010  460a              MOV      r2,r1
000012  bf00              NOP      
000014  bf00              NOP      
                  |L30.22|
000016  1e53              SUBS     r3,r2,#1
000018  1e1a              SUBS     r2,r3,#0
00001a  d1fc              BNE      |L30.22|
00001c  bf00              NOP      
;;;170    }
00001e  4770              BX       lr
;;;171    
                          ENDP

                  |L30.32|
                          DCD      SystemCoreClock

                          AREA ||i.PIN_SWCLK_TCK_IN||, CODE, READONLY, ALIGN=2

                  PIN_SWCLK_TCK_IN PROC
;;;595    */
;;;596    __STATIC_INLINE uint8_t PIN_SWCLK_TCK_IN(void)
000000  4802              LDR      r0,|L31.12|
;;;597    {
;;;598    #if defined ( BLUEPILL ) && defined ( SWD_REMAP )
;;;599      AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_DISABLE;
;;;600    #endif
;;;601      
;;;602      return (PIN_SWCLK_TCK_PORT->ODR & PIN_SWCLK_TCK_MASK) ? 1 : 0;
000002  6800              LDR      r0,[r0,#0]
000004  f3c03040          UBFX     r0,r0,#13,#1
;;;603    }
000008  4770              BX       lr
;;;604    
                          ENDP

00000a  0000              DCW      0x0000
                  |L31.12|
                          DCD      0x40010c0c

                          AREA ||i.PIN_SWDIO_OUT_ENABLE||, CODE, READONLY, ALIGN=2

                  PIN_SWDIO_OUT_ENABLE PROC
;;;699    */
;;;700    __STATIC_INLINE void PIN_SWDIO_OUT_ENABLE(void)
000000  bf00              NOP      
;;;701    {
;;;702    #if defined ( BLUEPILL ) && defined ( SWD_REMAP )
;;;703      AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_DISABLE;
;;;704    #endif
;;;705      
;;;706      PIN_SWDIO_TMS_OUT_ENABLE();
000002  4807              LDR      r0,|L32.32|
000004  6800              LDR      r0,[r0,#0]
000006  f0206070          BIC      r0,r0,#0xf000000
00000a  f0407040          ORR      r0,r0,#0x3000000
00000e  4904              LDR      r1,|L32.32|
000010  6008              STR      r0,[r1,#0]
000012  f44f4080          MOV      r0,#0x4000
000016  4902              LDR      r1,|L32.32|
000018  3110              ADDS     r1,r1,#0x10
00001a  6008              STR      r0,[r1,#0]
00001c  bf00              NOP      
;;;707    }
00001e  4770              BX       lr
;;;708    
                          ENDP

                  |L32.32|
                          DCD      0x40010c04

                          AREA ||i.PIN_SWDIO_TMS_IN||, CODE, READONLY, ALIGN=2

                  PIN_SWDIO_TMS_IN PROC
;;;633    */
;;;634    __STATIC_INLINE uint8_t PIN_SWDIO_TMS_IN(void)
000000  4802              LDR      r0,|L33.12|
;;;635    {
;;;636    #if defined ( BLUEPILL ) && defined ( SWD_REMAP )
;;;637      AFIO->MAPR |= AFIO_MAPR_SWJ_CFG_DISABLE;
;;;638    #endif
;;;639      
;;;640      return (PIN_SWDIO_TMS_PORT->IDR & PIN_SWDIO_TMS_MASK) ? 1 : 0;
000002  6800              LDR      r0,[r0,#0]
000004  f3c03080          UBFX     r0,r0,#14,#1
;;;641    }
000008  4770              BX       lr
;;;642    
                          ENDP

00000a  0000              DCW      0x0000
                  |L33.12|
                          DCD      0x40010c08

                          AREA ||i.PIN_TDI_IN||, CODE, READONLY, ALIGN=2

                  PIN_TDI_IN PROC
;;;726    */
;;;727    __STATIC_INLINE uint8_t PIN_TDI_IN(void)
000000  4802              LDR      r0,|L34.12|
;;;728    {
;;;729    #if ( DAP_JTAG != 0 )
;;;730      return (PIN_TDI_PORT->ODR & PIN_TDI_MASK) ? 1 : 0;
000002  6800              LDR      r0,[r0,#0]
000004  f3c010c0          UBFX     r0,r0,#7,#1
;;;731    #else
;;;732      return (0);
;;;733    #endif
;;;734    }
000008  4770              BX       lr
;;;735    
                          ENDP

00000a  0000              DCW      0x0000
                  |L34.12|
                          DCD      0x4001080c

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  DAP_Data
                          %        68

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  DAP_FW_Ver
000000  322e302e          DCB      0x32,0x2e,0x30,0x2e
000004  3000              DCB      0x30,0x00

                          AREA ||.data||, DATA, ALIGN=0

                  DAP_TransferAbort
000000  00                DCB      0x00

;*** Start embedded assembler ***

#line 1 "CMSIS-DAP\\DAP.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___5_DAP_c_Delayms____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____REVSH|
#line 507
|__asm___5_DAP_c_Delayms____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_DAP_c_Delayms____RRX|
#line 694
|__asm___5_DAP_c_Delayms____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
