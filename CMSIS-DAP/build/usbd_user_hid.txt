; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\usbd_user_hid.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\usbd_user_hid.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\usbd_user_hid.crf USB\usbd_user_hid.c]
                          THUMB

                          AREA ||i.HID_ProcessCommand||, CODE, READONLY, ALIGN=2

                  HID_ProcessCommand PROC
;;;123    
;;;124    void HID_ProcessCommand(uint8_t *request, uint8_t *response)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;125    {
000004  4604              MOV      r4,r0
000006  460d              MOV      r5,r1
;;;126    	uint8_t result   = 0xFF; //! DAP_OK;
000008  f04f0aff          MOV      r10,#0xff
;;;127    	uint16_t data;
;;;128    	uint16_t length;
;;;129    	uint32_t address;
;;;130    	uint8_t *p_address;
;;;131    
;;;132    	if ((*request >= HID_Command0) && (*request <= HID_Command7))
00000c  7820              LDRB     r0,[r4,#0]
00000e  28d0              CMP      r0,#0xd0
000010  db72              BLT      |L1.248|
000012  7820              LDRB     r0,[r4,#0]
000014  28d7              CMP      r0,#0xd7
000016  dc6f              BGT      |L1.248|
;;;133    	{
;;;134    //		DEBUG("REQ:%2X\n", *request);
;;;135    
;;;136    		*response++ = *request;
000018  7820              LDRB     r0,[r4,#0]
00001a  f8050b01          STRB     r0,[r5],#1
;;;137    		switch (*request++)
00001e  f8140b01          LDRB     r0,[r4],#1
000022  38d0              SUBS     r0,r0,#0xd0
000024  2808              CMP      r0,#8
000026  d268              BCS      |L1.250|
000028  e8dff000          TBB      [pc,r0]
00002c  04121518          DCB      0x04,0x12,0x15,0x18
000030  21335672          DCB      0x21,0x33,0x56,0x72
;;;138    		{
;;;139    		// Get device info
;;;140    		case HID_Command0:
;;;141    			address = DBGMCU->IDCODE;
000034  4856              LDR      r0,|L1.400|
000036  6807              LDR      r7,[r0,#0]
;;;142    			*response++ = (address >>  0) & 0xFF;
000038  f8057b01          STRB     r7,[r5],#1
;;;143    			*response++ = (address >>  8) & 0xFF;
00003c  0a38              LSRS     r0,r7,#8
00003e  f8050b01          STRB     r0,[r5],#1
;;;144    			*response++ = (address >> 16) & 0xFF;
000042  0c38              LSRS     r0,r7,#16
000044  f8050b01          STRB     r0,[r5],#1
;;;145    			*response++ = (address >> 24) & 0xFF;
000048  0e38              LSRS     r0,r7,#24
00004a  f8050b01          STRB     r0,[r5],#1
;;;146    			break;
00004e  e081              B        |L1.340|
;;;147    		// Unlock flash
;;;148    		case HID_Command1:
;;;149    			FLASH_Unlock();
000050  f7fffffe          BL       FLASH_Unlock
;;;150    			break;
000054  e07e              B        |L1.340|
;;;151    		// Lock flash
;;;152    		case HID_Command2:
;;;153    			FLASH_Lock();
000056  f7fffffe          BL       FLASH_Lock
;;;154    			break;
00005a  e07b              B        |L1.340|
;;;155    		// Erase page
;;;156    		case HID_Command3:
;;;157    			address = PACK_DATA_LONG(0);
00005c  6827              LDR      r7,[r4,#0]
;;;158    			if (FLASH_ErasePage(address) != FLASH_COMPLETE)
00005e  4638              MOV      r0,r7
000060  f7fffffe          BL       FLASH_ErasePage
000064  2804              CMP      r0,#4
000066  d001              BEQ      |L1.108|
;;;159    				result = DAP_ERROR;
000068  f04f0aff          MOV      r10,#0xff
                  |L1.108|
;;;160    			break;
00006c  e072              B        |L1.340|
;;;161    		// Check for blank (0xFF)
;;;162    		case HID_Command4:
;;;163    			p_address = PACK_DATA_PBYTE(0);
00006e  f8d48000          LDR      r8,[r4,#0]
;;;164    			length  = PACK_DATA_WORD(4);
000072  88a6              LDRH     r6,[r4,#4]
;;;165    			while (length-- != 0)
000074  e006              B        |L1.132|
                  |L1.118|
;;;166    				if (*p_address++ != 0xFF)
000076  f8181b01          LDRB     r1,[r8],#1
00007a  29ff              CMP      r1,#0xff
00007c  d002              BEQ      |L1.132|
;;;167    				{
;;;168    					result = DAP_ERROR;
00007e  f04f0aff          MOV      r10,#0xff
;;;169    					break;
000082  e004              B        |L1.142|
                  |L1.132|
000084  1e30              SUBS     r0,r6,#0              ;165
000086  f1a60101          SUB      r1,r6,#1              ;165
00008a  b28e              UXTH     r6,r1                 ;165
00008c  d1f3              BNE      |L1.118|
                  |L1.142|
00008e  bf00              NOP      
;;;170    				}
;;;171    			break;
000090  e060              B        |L1.340|
;;;172    		// Write to flash
;;;173    		case HID_Command5:
;;;174    			address = PACK_DATA_LONG(0);
000092  6827              LDR      r7,[r4,#0]
;;;175    			length  = PACK_DATA_WORD(4);
000094  88a6              LDRH     r6,[r4,#4]
;;;176    			if (length > (DAP_PACKET_SIZE - (6+2)))	// Check for maximum data payload
000096  2e38              CMP      r6,#0x38
000098  dd02              BLE      |L1.160|
;;;177    				result = DAP_ERROR;
00009a  f04f0aff          MOV      r10,#0xff
00009e  e01a              B        |L1.214|
                  |L1.160|
;;;178    			else
;;;179    			{
;;;180    				request += 6;
0000a0  1da4              ADDS     r4,r4,#6
;;;181    				while (length-- != 0)
0000a2  e012              B        |L1.202|
                  |L1.164|
;;;182    				{
;;;183    					data = *request++;
0000a4  f8149b01          LDRB     r9,[r4],#1
;;;184    					if (length != 0)
0000a8  b12e              CBZ      r6,|L1.182|
;;;185    					{
;;;186    						data |= ((uint16_t)(*request++) << 8);
0000aa  f8141b01          LDRB     r1,[r4],#1
0000ae  ea492901          ORR      r9,r9,r1,LSL #8
;;;187    						length--;
0000b2  1e70              SUBS     r0,r6,#1
0000b4  b286              UXTH     r6,r0
                  |L1.182|
;;;188    					}
;;;189    					if (FLASH_ProgramHalfWord(address, data) != FLASH_COMPLETE)
0000b6  4649              MOV      r1,r9
0000b8  4638              MOV      r0,r7
0000ba  f7fffffe          BL       FLASH_ProgramHalfWord
0000be  2804              CMP      r0,#4
0000c0  d002              BEQ      |L1.200|
;;;190    					{
;;;191    						result = DAP_ERROR;
0000c2  f04f0aff          MOV      r10,#0xff
;;;192    						break;
0000c6  e005              B        |L1.212|
                  |L1.200|
;;;193    					}
;;;194    					address += 2;
0000c8  1cbf              ADDS     r7,r7,#2
                  |L1.202|
0000ca  1e30              SUBS     r0,r6,#0              ;181
0000cc  f1a60101          SUB      r1,r6,#1              ;181
0000d0  b28e              UXTH     r6,r1                 ;181
0000d2  d1e7              BNE      |L1.164|
                  |L1.212|
0000d4  bf00              NOP                            ;192
                  |L1.214|
;;;195    				}
;;;196    			}
;;;197    			break;
0000d6  e03d              B        |L1.340|
;;;198    		// Read from flash
;;;199    		case HID_Command6:
;;;200    			{
;;;201    				p_address = PACK_DATA_PBYTE(0);
0000d8  f8d48000          LDR      r8,[r4,#0]
;;;202    				length  = PACK_DATA_WORD(4);
0000dc  88a6              LDRH     r6,[r4,#4]
;;;203    				if (length > (DAP_PACKET_SIZE - (2)))	// Check for maximum data payload
0000de  2e3e              CMP      r6,#0x3e
0000e0  dd02              BLE      |L1.232|
;;;204    					result = DAP_ERROR;
0000e2  f04f0aff          MOV      r10,#0xff
0000e6  e012              B        |L1.270|
                  |L1.232|
;;;205    				else
;;;206    				{
;;;207    					*response++ = DAP_OK;
0000e8  2000              MOVS     r0,#0
0000ea  f8050b01          STRB     r0,[r5],#1
;;;208    					while (length-- != 0)
0000ee  e009              B        |L1.260|
                  |L1.240|
;;;209    					{
;;;210    						if (length == 0)
0000f0  b926              CBNZ     r6,|L1.252|
;;;211    							result = *p_address;
0000f2  f898a000          LDRB     r10,[r8,#0]
0000f6  e005              B        |L1.260|
                  |L1.248|
0000f8  e030              B        |L1.348|
                  |L1.250|
0000fa  e027              B        |L1.332|
                  |L1.252|
;;;212    						else
;;;213    							*response++ = *p_address++;
0000fc  f8180b01          LDRB     r0,[r8],#1
000100  f8050b01          STRB     r0,[r5],#1
                  |L1.260|
000104  1e30              SUBS     r0,r6,#0              ;208
000106  f1a60101          SUB      r1,r6,#1              ;208
00010a  b28e              UXTH     r6,r1                 ;208
00010c  d1f0              BNE      |L1.240|
                  |L1.270|
;;;214    					}
;;;215    				}
;;;216    			}
;;;217    			break;
00010e  e021              B        |L1.340|
;;;218    		// Reset device
;;;219    		case HID_Command7:
;;;220    			NVIC_SystemReset();
000110  bf00              NOP      
000112  bf00              NOP      
000114  bf00              NOP      
000116  bf00              NOP      
000118  bf00              NOP      
00011a  f3bf8f4f          DSB      
00011e  bf00              NOP      
000120  bf00              NOP      
000122  bf00              NOP      
000124  481b              LDR      r0,|L1.404|
000126  6800              LDR      r0,[r0,#0]
000128  f40060e0          AND      r0,r0,#0x700
00012c  491a              LDR      r1,|L1.408|
00012e  4308              ORRS     r0,r0,r1
000130  1d00              ADDS     r0,r0,#4
000132  4918              LDR      r1,|L1.404|
000134  6008              STR      r0,[r1,#0]
000136  bf00              NOP      
000138  bf00              NOP      
00013a  bf00              NOP      
00013c  f3bf8f4f          DSB      
000140  bf00              NOP      
000142  bf00              NOP      
000144  bf00              NOP      
000146  bf00              NOP      
                  |L1.328|
000148  bf00              NOP      
00014a  e7fd              B        |L1.328|
                  |L1.332|
;;;221    			break;
;;;222    		default:
;;;223    			--response;
00014c  1e6d              SUBS     r5,r5,#1
;;;224    			result = ID_DAP_Invalid;
00014e  f04f0aff          MOV      r10,#0xff
000152  bf00              NOP                            ;137
                  |L1.340|
000154  bf00              NOP                            ;146
;;;225    		}
;;;226    		*response = result;
000156  f885a000          STRB     r10,[r5,#0]
00015a  e017              B        |L1.396|
                  |L1.348|
;;;227    	}
;;;228    	else
;;;229    	{
;;;230    		if (pUserAppDescriptor != NULL)
00015c  480f              LDR      r0,|L1.412|
00015e  6800              LDR      r0,[r0,#0]  ; pUserAppDescriptor
000160  b190              CBZ      r0,|L1.392|
;;;231    		{
;;;232    			pUserAppDescriptor->UserProcess(USB_Request[USB_RequestOut], USB_Response[USB_ResponseIn]);
000162  4b0f              LDR      r3,|L1.416|
000164  f8dfc03c          LDR      r12,|L1.420|
000168  f8dcc000          LDR      r12,[r12,#0]  ; USB_ResponseIn
00016c  eb03118c          ADD      r1,r3,r12,LSL #6
000170  4b0d              LDR      r3,|L1.424|
000172  f8dfc038          LDR      r12,|L1.428|
000176  f8dcc000          LDR      r12,[r12,#0]  ; USB_RequestOut
00017a  eb03108c          ADD      r0,r3,r12,LSL #6
00017e  4b07              LDR      r3,|L1.412|
000180  681b              LDR      r3,[r3,#0]  ; pUserAppDescriptor
000182  685a              LDR      r2,[r3,#4]
000184  4790              BLX      r2
000186  e001              B        |L1.396|
                  |L1.392|
;;;233    		}
;;;234    		else
;;;235    		{
;;;236    //			DEBUG("REQ:%02X no app\n", *request);
;;;237    			*response = ID_DAP_Invalid;
000188  20ff              MOVS     r0,#0xff
00018a  7028              STRB     r0,[r5,#0]
                  |L1.396|
;;;238    		}
;;;239    	}
;;;240    
;;;241    //	DEBUG("RES:%2X\n", *response);
;;;242    }
00018c  e8bd87f0          POP      {r4-r10,pc}
;;;243    
                          ENDP

                  |L1.400|
                          DCD      0xe0042000
                  |L1.404|
                          DCD      0xe000ed0c
                  |L1.408|
                          DCD      0x05fa0000
                  |L1.412|
                          DCD      pUserAppDescriptor
                  |L1.416|
                          DCD      USB_Response
                  |L1.420|
                          DCD      USB_ResponseIn
                  |L1.424|
                          DCD      USB_Request
                  |L1.428|
                          DCD      USB_RequestOut

                          AREA ||i.usbd_hid_get_report||, CODE, READONLY, ALIGN=2

                  usbd_hid_get_report PROC
;;;46     // USB HID Callback: when data needs to be prepared for the host
;;;47     int usbd_hid_get_report (U8 rtype, U8 rid, U8 *buf, U8 req)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;48     {
000004  4604              MOV      r4,r0
000006  460f              MOV      r7,r1
000008  4615              MOV      r5,r2
00000a  461e              MOV      r6,r3
;;;49     	switch (rtype)
00000c  2c01              CMP      r4,#1
00000e  d002              BEQ      |L2.22|
000010  2c03              CMP      r4,#3
000012  d138              BNE      |L2.134|
000014  e036              B        |L2.132|
                  |L2.22|
;;;50     	{
;;;51     	case HID_REPORT_INPUT:
;;;52     		switch (req)
000016  b126              CBZ      r6,|L2.34|
000018  2e01              CMP      r6,#1
00001a  d004              BEQ      |L2.38|
00001c  2e02              CMP      r6,#2
00001e  d12f              BNE      |L2.128|
000020  e000              B        |L2.36|
                  |L2.34|
;;;53     		{
;;;54     		case USBD_HID_REQ_EP_CTRL:
;;;55     		case USBD_HID_REQ_PERIOD_UPDATE:
000022  bf00              NOP      
                  |L2.36|
;;;56     			break;
000024  e02c              B        |L2.128|
                  |L2.38|
;;;57     		case USBD_HID_REQ_EP_INT:
;;;58     			if ((USB_ResponseOut != USB_ResponseIn) || USB_ResponseFlag)
000026  4819              LDR      r0,|L2.140|
000028  6800              LDR      r0,[r0,#0]  ; USB_ResponseOut
00002a  4919              LDR      r1,|L2.144|
00002c  6809              LDR      r1,[r1,#0]  ; USB_ResponseIn
00002e  4288              CMP      r0,r1
000030  d102              BNE      |L2.56|
000032  4818              LDR      r0,|L2.148|
000034  7800              LDRB     r0,[r0,#0]  ; USB_ResponseFlag
000036  b1f8              CBZ      r0,|L2.120|
                  |L2.56|
;;;59     			{
;;;60     				memcpy(buf, USB_Response[USB_ResponseOut], DAP_PACKET_SIZE);
000038  4817              LDR      r0,|L2.152|
00003a  4a14              LDR      r2,|L2.140|
00003c  6812              LDR      r2,[r2,#0]  ; USB_ResponseOut
00003e  eb001182          ADD      r1,r0,r2,LSL #6
000042  2240              MOVS     r2,#0x40
000044  4628              MOV      r0,r5
000046  f7fffffe          BL       __aeabi_memcpy
;;;61     				USB_ResponseOut++;
00004a  4810              LDR      r0,|L2.140|
00004c  6800              LDR      r0,[r0,#0]  ; USB_ResponseOut
00004e  1c40              ADDS     r0,r0,#1
000050  490e              LDR      r1,|L2.140|
000052  6008              STR      r0,[r1,#0]  ; USB_ResponseOut
;;;62     				if (USB_ResponseOut == DAP_PACKET_COUNT)
000054  4608              MOV      r0,r1
000056  6800              LDR      r0,[r0,#0]  ; USB_ResponseOut
000058  2840              CMP      r0,#0x40
00005a  d101              BNE      |L2.96|
;;;63     					USB_ResponseOut = 0;
00005c  2000              MOVS     r0,#0
00005e  6008              STR      r0,[r1,#0]  ; USB_ResponseOut
                  |L2.96|
;;;64     				if (USB_ResponseOut == USB_ResponseIn)
000060  480a              LDR      r0,|L2.140|
000062  6800              LDR      r0,[r0,#0]  ; USB_ResponseOut
000064  490a              LDR      r1,|L2.144|
000066  6809              LDR      r1,[r1,#0]  ; USB_ResponseIn
000068  4288              CMP      r0,r1
00006a  d102              BNE      |L2.114|
;;;65     					USB_ResponseFlag = 0;
00006c  2000              MOVS     r0,#0
00006e  4909              LDR      r1,|L2.148|
000070  7008              STRB     r0,[r1,#0]
                  |L2.114|
;;;66     				return (DAP_PACKET_SIZE);
000072  2040              MOVS     r0,#0x40
                  |L2.116|
;;;67     			}
;;;68     			else
;;;69     				USB_ResponseIdle = 1;
;;;70     			break;
;;;71     		}
;;;72     		break;
;;;73     	case HID_REPORT_FEATURE:
;;;74     		break;
;;;75     	}
;;;76     	return (0);
;;;77     }
000074  e8bd81f0          POP      {r4-r8,pc}
                  |L2.120|
000078  2001              MOVS     r0,#1                 ;69
00007a  4908              LDR      r1,|L2.156|
00007c  7008              STRB     r0,[r1,#0]            ;69
00007e  bf00              NOP                            ;70
                  |L2.128|
000080  bf00              NOP                            ;56
000082  e000              B        |L2.134|
                  |L2.132|
000084  bf00              NOP                            ;74
                  |L2.134|
000086  bf00              NOP                            ;72
000088  2000              MOVS     r0,#0                 ;76
00008a  e7f3              B        |L2.116|
;;;78     
                          ENDP

                  |L2.140|
                          DCD      USB_ResponseOut
                  |L2.144|
                          DCD      USB_ResponseIn
                  |L2.148|
                          DCD      USB_ResponseFlag
                  |L2.152|
                          DCD      USB_Response
                  |L2.156|
                          DCD      USB_ResponseIdle

                          AREA ||i.usbd_hid_init||, CODE, READONLY, ALIGN=2

                  usbd_hid_init PROC
;;;34     // USB HID Callback: when system initializes
;;;35     void usbd_hid_init (void)
000000  2000              MOVS     r0,#0
;;;36     {
;;;37     	USB_RequestFlag   = 0;
000002  4908              LDR      r1,|L3.36|
000004  7008              STRB     r0,[r1,#0]
;;;38     	USB_RequestIn     = 0;
000006  4908              LDR      r1,|L3.40|
000008  6008              STR      r0,[r1,#0]  ; USB_RequestIn
;;;39     	USB_RequestOut    = 0;
00000a  4908              LDR      r1,|L3.44|
00000c  6008              STR      r0,[r1,#0]  ; USB_RequestOut
;;;40     	USB_ResponseIdle  = 1;
00000e  2001              MOVS     r0,#1
000010  4907              LDR      r1,|L3.48|
000012  7008              STRB     r0,[r1,#0]
;;;41     	USB_ResponseFlag  = 0;
000014  2000              MOVS     r0,#0
000016  4907              LDR      r1,|L3.52|
000018  7008              STRB     r0,[r1,#0]
;;;42     	USB_ResponseIn    = 0;
00001a  4907              LDR      r1,|L3.56|
00001c  6008              STR      r0,[r1,#0]  ; USB_ResponseIn
;;;43     	USB_ResponseOut   = 0;
00001e  4907              LDR      r1,|L3.60|
000020  6008              STR      r0,[r1,#0]  ; USB_ResponseOut
;;;44     }
000022  4770              BX       lr
;;;45     
                          ENDP

                  |L3.36|
                          DCD      USB_RequestFlag
                  |L3.40|
                          DCD      USB_RequestIn
                  |L3.44|
                          DCD      USB_RequestOut
                  |L3.48|
                          DCD      USB_ResponseIdle
                  |L3.52|
                          DCD      USB_ResponseFlag
                  |L3.56|
                          DCD      USB_ResponseIn
                  |L3.60|
                          DCD      USB_ResponseOut

                          AREA ||i.usbd_hid_process||, CODE, READONLY, ALIGN=2

                  usbd_hid_process PROC
;;;244    // Process USB HID Data
;;;245    uint8_t usbd_hid_process (void)
000000  b510              PUSH     {r4,lr}
;;;246    {
;;;247    	uint32_t n;
;;;248    
;;;249    	// Process pending requests
;;;250    	if ((USB_RequestOut != USB_RequestIn) || USB_RequestFlag)
000002  4825              LDR      r0,|L4.152|
000004  6800              LDR      r0,[r0,#0]  ; USB_RequestOut
000006  4925              LDR      r1,|L4.156|
000008  6809              LDR      r1,[r1,#0]  ; USB_RequestIn
00000a  4288              CMP      r0,r1
00000c  d103              BNE      |L4.22|
00000e  4824              LDR      r0,|L4.160|
000010  7800              LDRB     r0,[r0,#0]  ; USB_RequestFlag
000012  2800              CMP      r0,#0
000014  d03d              BEQ      |L4.146|
                  |L4.22|
;;;251    	{
;;;252    		HID_ProcessCommand(USB_Request[USB_RequestOut], USB_Response[USB_ResponseIn]);
000016  4a23              LDR      r2,|L4.164|
000018  4b23              LDR      r3,|L4.168|
00001a  681b              LDR      r3,[r3,#0]  ; USB_ResponseIn
00001c  eb021183          ADD      r1,r2,r3,LSL #6
000020  4a22              LDR      r2,|L4.172|
000022  4b1d              LDR      r3,|L4.152|
000024  681b              LDR      r3,[r3,#0]  ; USB_RequestOut
000026  eb021083          ADD      r0,r2,r3,LSL #6
00002a  f7fffffe          BL       HID_ProcessCommand
;;;253    
;;;254    		// Update request index and flag
;;;255    		n = USB_RequestOut + 1;
00002e  481a              LDR      r0,|L4.152|
000030  6800              LDR      r0,[r0,#0]  ; USB_RequestOut
000032  1c44              ADDS     r4,r0,#1
;;;256    		if (n == DAP_PACKET_COUNT)
000034  2c40              CMP      r4,#0x40
000036  d100              BNE      |L4.58|
;;;257    			n = 0;
000038  2400              MOVS     r4,#0
                  |L4.58|
;;;258    		USB_RequestOut = n;
00003a  4817              LDR      r0,|L4.152|
00003c  6004              STR      r4,[r0,#0]  ; USB_RequestOut
;;;259    
;;;260    		if (USB_RequestOut == USB_RequestIn)
00003e  6800              LDR      r0,[r0,#0]  ; USB_RequestOut
000040  4916              LDR      r1,|L4.156|
000042  6809              LDR      r1,[r1,#0]  ; USB_RequestIn
000044  4288              CMP      r0,r1
000046  d102              BNE      |L4.78|
;;;261    			USB_RequestFlag = 0;
000048  2000              MOVS     r0,#0
00004a  4915              LDR      r1,|L4.160|
00004c  7008              STRB     r0,[r1,#0]
                  |L4.78|
;;;262    
;;;263    		if (USB_ResponseIdle)
00004e  4818              LDR      r0,|L4.176|
000050  7800              LDRB     r0,[r0,#0]  ; USB_ResponseIdle
000052  b160              CBZ      r0,|L4.110|
;;;264    		{	// Request that data is send back to host
;;;265    			USB_ResponseIdle = 0;
000054  2000              MOVS     r0,#0
000056  4916              LDR      r1,|L4.176|
000058  7008              STRB     r0,[r1,#0]
;;;266    			usbd_hid_get_report_trigger(0, USB_Response[USB_ResponseIn], DAP_PACKET_SIZE);
00005a  4812              LDR      r0,|L4.164|
00005c  4a12              LDR      r2,|L4.168|
00005e  6812              LDR      r2,[r2,#0]  ; USB_ResponseIn
000060  eb001182          ADD      r1,r0,r2,LSL #6
000064  2240              MOVS     r2,#0x40
000066  2000              MOVS     r0,#0
000068  f7fffffe          BL       usbd_hid_get_report_trigger
00006c  e00f              B        |L4.142|
                  |L4.110|
;;;267    		}
;;;268    		else
;;;269    		{	// Update response index and flag
;;;270    			n = USB_ResponseIn + 1;
00006e  480e              LDR      r0,|L4.168|
000070  6800              LDR      r0,[r0,#0]  ; USB_ResponseIn
000072  1c44              ADDS     r4,r0,#1
;;;271    			if (n == DAP_PACKET_COUNT)
000074  2c40              CMP      r4,#0x40
000076  d100              BNE      |L4.122|
;;;272    				n = 0;
000078  2400              MOVS     r4,#0
                  |L4.122|
;;;273    			USB_ResponseIn = n;
00007a  480b              LDR      r0,|L4.168|
00007c  6004              STR      r4,[r0,#0]  ; USB_ResponseIn
;;;274    
;;;275    			if (USB_ResponseIn == USB_ResponseOut)
00007e  6800              LDR      r0,[r0,#0]  ; USB_ResponseIn
000080  490c              LDR      r1,|L4.180|
000082  6809              LDR      r1,[r1,#0]  ; USB_ResponseOut
000084  4288              CMP      r0,r1
000086  d102              BNE      |L4.142|
;;;276    				USB_ResponseFlag = 1;
000088  2001              MOVS     r0,#1
00008a  490b              LDR      r1,|L4.184|
00008c  7008              STRB     r0,[r1,#0]
                  |L4.142|
;;;277    		}
;;;278    		return 1;
00008e  2001              MOVS     r0,#1
                  |L4.144|
;;;279    	}
;;;280    	return 0;
;;;281    }
000090  bd10              POP      {r4,pc}
                  |L4.146|
000092  2000              MOVS     r0,#0                 ;280
000094  e7fc              B        |L4.144|
                          ENDP

000096  0000              DCW      0x0000
                  |L4.152|
                          DCD      USB_RequestOut
                  |L4.156|
                          DCD      USB_RequestIn
                  |L4.160|
                          DCD      USB_RequestFlag
                  |L4.164|
                          DCD      USB_Response
                  |L4.168|
                          DCD      USB_ResponseIn
                  |L4.172|
                          DCD      USB_Request
                  |L4.176|
                          DCD      USB_ResponseIdle
                  |L4.180|
                          DCD      USB_ResponseOut
                  |L4.184|
                          DCD      USB_ResponseFlag

                          AREA ||i.usbd_hid_set_report||, CODE, READONLY, ALIGN=2

                  usbd_hid_set_report PROC
;;;79     // USB HID Callback: when data is received from the host
;;;80     void usbd_hid_set_report (U8 rtype, U8 rid, U8 *buf, int len, U8 req)
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;81     {
000004  4606              MOV      r6,r0
000006  4688              MOV      r8,r1
000008  4614              MOV      r4,r2
00000a  461d              MOV      r5,r3
00000c  9f06              LDR      r7,[sp,#0x18]
;;;82     	switch (rtype)
00000e  2e02              CMP      r6,#2
000010  d002              BEQ      |L5.24|
000012  2e03              CMP      r6,#3
000014  d136              BNE      |L5.132|
000016  e034              B        |L5.130|
                  |L5.24|
;;;83     	{
;;;84     	case HID_REPORT_OUTPUT:
;;;85     		if (len == 0)
000018  b905              CBNZ     r5,|L5.28|
;;;86     			break;
00001a  e033              B        |L5.132|
                  |L5.28|
;;;87     		if (buf[0] == ID_DAP_TransferAbort)
00001c  7820              LDRB     r0,[r4,#0]
00001e  2807              CMP      r0,#7
000020  d107              BNE      |L5.50|
;;;88     		{
;;;89     			if (pUserAppDescriptor != NULL)
000022  481a              LDR      r0,|L5.140|
000024  6800              LDR      r0,[r0,#0]  ; pUserAppDescriptor
000026  b118              CBZ      r0,|L5.48|
;;;90     				pUserAppDescriptor->UserAbort();
000028  4918              LDR      r1,|L5.140|
00002a  6809              LDR      r1,[r1,#0]  ; pUserAppDescriptor
00002c  6888              LDR      r0,[r1,#8]
00002e  4780              BLX      r0
                  |L5.48|
;;;91     			break;
000030  e028              B        |L5.132|
                  |L5.50|
;;;92     		}
;;;93     		if (USB_RequestFlag && (USB_RequestIn == USB_RequestOut))
000032  4817              LDR      r0,|L5.144|
000034  7800              LDRB     r0,[r0,#0]  ; USB_RequestFlag
000036  b130              CBZ      r0,|L5.70|
000038  4816              LDR      r0,|L5.148|
00003a  6800              LDR      r0,[r0,#0]  ; USB_RequestIn
00003c  4916              LDR      r1,|L5.152|
00003e  6809              LDR      r1,[r1,#0]  ; USB_RequestOut
000040  4288              CMP      r0,r1
000042  d100              BNE      |L5.70|
;;;94     			break;  // Discard packet when buffer is full
000044  e01e              B        |L5.132|
                  |L5.70|
;;;95     
;;;96     		// Store data into request packet buffer
;;;97     		memcpy(USB_Request[USB_RequestIn], buf, len);
000046  4915              LDR      r1,|L5.156|
000048  4a12              LDR      r2,|L5.148|
00004a  6812              LDR      r2,[r2,#0]  ; USB_RequestIn
00004c  eb011082          ADD      r0,r1,r2,LSL #6
000050  462a              MOV      r2,r5
000052  4621              MOV      r1,r4
000054  f7fffffe          BL       __aeabi_memcpy
;;;98     
;;;99     		USB_RequestIn++;
000058  480e              LDR      r0,|L5.148|
00005a  6800              LDR      r0,[r0,#0]  ; USB_RequestIn
00005c  1c40              ADDS     r0,r0,#1
00005e  490d              LDR      r1,|L5.148|
000060  6008              STR      r0,[r1,#0]  ; USB_RequestIn
;;;100    		if (USB_RequestIn == DAP_PACKET_COUNT)
000062  4608              MOV      r0,r1
000064  6800              LDR      r0,[r0,#0]  ; USB_RequestIn
000066  2840              CMP      r0,#0x40
000068  d101              BNE      |L5.110|
;;;101    			USB_RequestIn = 0;
00006a  2000              MOVS     r0,#0
00006c  6008              STR      r0,[r1,#0]  ; USB_RequestIn
                  |L5.110|
;;;102    		if (USB_RequestIn == USB_RequestOut)
00006e  4809              LDR      r0,|L5.148|
000070  6800              LDR      r0,[r0,#0]  ; USB_RequestIn
000072  4909              LDR      r1,|L5.152|
000074  6809              LDR      r1,[r1,#0]  ; USB_RequestOut
000076  4288              CMP      r0,r1
000078  d102              BNE      |L5.128|
;;;103    			USB_RequestFlag = 1;
00007a  2001              MOVS     r0,#1
00007c  4904              LDR      r1,|L5.144|
00007e  7008              STRB     r0,[r1,#0]
                  |L5.128|
;;;104    		break;
000080  e000              B        |L5.132|
                  |L5.130|
;;;105    	case HID_REPORT_FEATURE:
;;;106    		break;
000082  bf00              NOP      
                  |L5.132|
000084  bf00              NOP                            ;86
;;;107    	}
;;;108    }
000086  e8bd81f0          POP      {r4-r8,pc}
;;;109    
                          ENDP

00008a  0000              DCW      0x0000
                  |L5.140|
                          DCD      pUserAppDescriptor
                  |L5.144|
                          DCD      USB_RequestFlag
                  |L5.148|
                          DCD      USB_RequestIn
                  |L5.152|
                          DCD      USB_RequestOut
                  |L5.156|
                          DCD      USB_Request

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  USB_Request
                          %        4096
                  USB_Response
                          %        4096

                          AREA ||.data||, DATA, ALIGN=2

                  USB_RequestFlag
000000  00000000          DCB      0x00,0x00,0x00,0x00
                  USB_RequestIn
                          DCD      0x00000000
                  USB_RequestOut
                          DCD      0x00000000
                  USB_ResponseIdle
00000c  00                DCB      0x00
                  USB_ResponseFlag
00000d  000000            DCB      0x00,0x00,0x00
                  USB_ResponseIn
                          DCD      0x00000000
                  USB_ResponseOut
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "USB\\usbd_user_hid.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_55124343____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___15_usbd_user_hid_c_55124343____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_55124343____REVSH|
#line 507
|__asm___15_usbd_user_hid_c_55124343____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___15_usbd_user_hid_c_55124343____RRX|
#line 694
|__asm___15_usbd_user_hid_c_55124343____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
