; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\usbd_stm32f103.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\usbd_stm32f103.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\usbd_stm32f103.crf USB\usbd_STM32F103.c]
                          THUMB

                          AREA ||i.EP_Reset||, CODE, READONLY, ALIGN=2

                  EP_Reset PROC
;;;40      */
;;;41     void EP_Reset (U32 EPNum)
000000  b530              PUSH     {r4,r5,lr}
;;;42     {
;;;43     	U32 num, val;
;;;44     
;;;45     	num = EPNum & 0x0F;
000002  f000010f          AND      r1,r0,#0xf
;;;46     	val = EPxREG(num);
000006  4c0d              LDR      r4,|L1.60|
000008  eb040381          ADD      r3,r4,r1,LSL #2
00000c  f8d32c00          LDR      r2,[r3,#0xc00]
;;;47     
;;;48     	if (EPNum & 0x80)
000010  f0000380          AND      r3,r0,#0x80
000014  b143              CBZ      r3,|L1.40|
;;;49     	{	// IN Endpoint
;;;50     		EPxREG(num) = val & (EP_MASK | EP_DTOG_TX);
000016  f64873cf          MOV      r3,#0x8fcf
00001a  4013              ANDS     r3,r3,r2
00001c  4625              MOV      r5,r4
00001e  eb050481          ADD      r4,r5,r1,LSL #2
000022  f8c43c00          STR      r3,[r4,#0xc00]
000026  e007              B        |L1.56|
                  |L1.40|
;;;51     	}
;;;52     	else
;;;53     	{	// OUT Endpoint
;;;54     		EPxREG(num) = val & (EP_MASK | EP_DTOG_RX);
000028  f64c738f          MOV      r3,#0xcf8f
00002c  4013              ANDS     r3,r3,r2
00002e  4d03              LDR      r5,|L1.60|
000030  eb050481          ADD      r4,r5,r1,LSL #2
000034  f8c43c00          STR      r3,[r4,#0xc00]
                  |L1.56|
;;;55     	}
;;;56     }
000038  bd30              POP      {r4,r5,pc}
;;;57     
                          ENDP

00003a  0000              DCW      0x0000
                  |L1.60|
                          DCD      0x40005000

                          AREA ||i.EP_Status||, CODE, READONLY, ALIGN=2

                  EP_Status PROC
;;;65      */
;;;66     void EP_Status (U32 EPNum, U32 stat)
000000  b570              PUSH     {r4-r6,lr}
;;;67     {
;;;68     	U32 num, val;
;;;69     
;;;70     	num = EPNum & 0x0F;
000002  f000020f          AND      r2,r0,#0xf
;;;71     	val = EPxREG(num);
000006  4d10              LDR      r5,|L2.72|
000008  eb050482          ADD      r4,r5,r2,LSL #2
00000c  f8d43c00          LDR      r3,[r4,#0xc00]
;;;72     	if (EPNum & 0x80)
000010  f0000480          AND      r4,r0,#0x80
000014  b15c              CBZ      r4,|L2.46|
;;;73     	{	/* IN Endpoint						*/
;;;74     		EPxREG(num) = (val ^ (stat & EP_STAT_TX)) & (EP_MASK | EP_STAT_TX);
000016  f0010430          AND      r4,r1,#0x30
00001a  405c              EORS     r4,r4,r3
00001c  f64875bf          MOV      r5,#0x8fbf
000020  402c              ANDS     r4,r4,r5
000022  4e09              LDR      r6,|L2.72|
000024  eb060582          ADD      r5,r6,r2,LSL #2
000028  f8c54c00          STR      r4,[r5,#0xc00]
00002c  e00a              B        |L2.68|
                  |L2.46|
;;;75     	}
;;;76     	else
;;;77     	{	/* OUT Endpoint						*/
;;;78     		EPxREG(num) = (val ^ (stat & EP_STAT_RX)) & (EP_MASK | EP_STAT_RX);
00002e  f4015440          AND      r4,r1,#0x3000
000032  405c              EORS     r4,r4,r3
000034  f64b758f          MOV      r5,#0xbf8f
000038  402c              ANDS     r4,r4,r5
00003a  4e03              LDR      r6,|L2.72|
00003c  eb060582          ADD      r5,r6,r2,LSL #2
000040  f8c54c00          STR      r4,[r5,#0xc00]
                  |L2.68|
;;;79     	}
;;;80     }
000044  bd70              POP      {r4-r6,pc}
;;;81     
                          ENDP

000046  0000              DCW      0x0000
                  |L2.72|
                          DCD      0x40005000

                          AREA ||i.USBD_ClearEPBuf||, CODE, READONLY, ALIGN=1

                  USBD_ClearEPBuf PROC
;;;388     */
;;;389    void USBD_ClearEPBuf (U32 EPNum)
000000  4770              BX       lr
;;;390    {
;;;391    	;
;;;392    }
;;;393    
                          ENDP


                          AREA ||i.USBD_ClrStallEP||, CODE, READONLY, ALIGN=1

                  USBD_ClrStallEP PROC
;;;374     */
;;;375    void USBD_ClrStallEP (U32 EPNum)
000000  b510              PUSH     {r4,lr}
;;;376    {
000002  4604              MOV      r4,r0
;;;377    	EP_Reset(EPNum);	/* reset DTog Bits	*/
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       EP_Reset
;;;378    	EP_Status(EPNum, EP_TX_VALID | EP_RX_VALID);
00000a  f2430130          MOV      r1,#0x3030
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       EP_Status
;;;379    }
000014  bd10              POP      {r4,pc}
;;;380    
                          ENDP


                          AREA ||i.USBD_ConfigEP||, CODE, READONLY, ALIGN=2

                  USBD_ConfigEP PROC
;;;256     */
;;;257    void USBD_ConfigEP (USB_ENDPOINT_DESCRIPTOR *pEPD)
000000  b510              PUSH     {r4,lr}
;;;258    {
000002  4602              MOV      r2,r0
;;;259    	/* Double Buffering is not yet supported									*/
;;;260    	U32 num, val;
;;;261    
;;;262    	num = pEPD->bEndpointAddress & 0x0F;
000004  7893              LDRB     r3,[r2,#2]
000006  f003010f          AND      r1,r3,#0xf
;;;263    
;;;264    	val = pEPD->wMaxPacketSize;
00000a  8890              LDRH     r0,[r2,#4]
;;;265    	if (pEPD->bEndpointAddress & USB_ENDPOINT_DIRECTION_MASK)
00000c  7893              LDRB     r3,[r2,#2]
00000e  f0030380          AND      r3,r3,#0x80
000012  b153              CBZ      r3,|L5.42|
;;;266    	{
;;;267    		(pBUF_DSCR + num)->ADDR_TX = FreeBufAddr;
000014  4b29              LDR      r3,|L5.188|
000016  881b              LDRH     r3,[r3,#0]  ; FreeBufAddr
000018  4c29              LDR      r4,|L5.192|
00001a  6824              LDR      r4,[r4,#0]  ; pBUF_DSCR
00001c  eb041401          ADD      r4,r4,r1,LSL #4
000020  6023              STR      r3,[r4,#0]
;;;268    		val = (val + 1) & ~1;
000022  1c43              ADDS     r3,r0,#1
000024  f0230001          BIC      r0,r3,#1
000028  e020              B        |L5.108|
                  |L5.42|
;;;269    	}
;;;270    	else
;;;271    	{
;;;272    		(pBUF_DSCR + num)->ADDR_RX = FreeBufAddr;
00002a  4b24              LDR      r3,|L5.188|
00002c  881b              LDRH     r3,[r3,#0]  ; FreeBufAddr
00002e  4c24              LDR      r4,|L5.192|
000030  6824              LDR      r4,[r4,#0]  ; pBUF_DSCR
000032  eb041401          ADD      r4,r4,r1,LSL #4
000036  60a3              STR      r3,[r4,#8]
;;;273    		if (val > 62)
000038  283e              CMP      r0,#0x3e
00003a  d90e              BLS      |L5.90|
;;;274    		{
;;;275    			val = (val + 31) & ~31;
00003c  f100031f          ADD      r3,r0,#0x1f
000040  f023001f          BIC      r0,r3,#0x1f
;;;276    			(pBUF_DSCR + num)->COUNT_RX = ((val << 5) - 1) | 0x8000;
000044  2301              MOVS     r3,#1
000046  ebc31340          RSB      r3,r3,r0,LSL #5
00004a  f4434300          ORR      r3,r3,#0x8000
00004e  4c1c              LDR      r4,|L5.192|
000050  6824              LDR      r4,[r4,#0]  ; pBUF_DSCR
000052  eb041401          ADD      r4,r4,r1,LSL #4
000056  60e3              STR      r3,[r4,#0xc]
000058  e008              B        |L5.108|
                  |L5.90|
;;;277    		}
;;;278    		else
;;;279    		{
;;;280    			val = (val + 1)  & ~1;
00005a  1c43              ADDS     r3,r0,#1
00005c  f0230001          BIC      r0,r3,#1
;;;281    			(pBUF_DSCR + num)->COUNT_RX =	val << 9;
000060  0243              LSLS     r3,r0,#9
000062  4c17              LDR      r4,|L5.192|
000064  6824              LDR      r4,[r4,#0]  ; pBUF_DSCR
000066  eb041401          ADD      r4,r4,r1,LSL #4
00006a  60e3              STR      r3,[r4,#0xc]
                  |L5.108|
;;;282    		}
;;;283    	}
;;;284    	FreeBufAddr += val;
00006c  4b13              LDR      r3,|L5.188|
00006e  881b              LDRH     r3,[r3,#0]  ; FreeBufAddr
000070  4403              ADD      r3,r3,r0
000072  4c12              LDR      r4,|L5.188|
000074  8023              STRH     r3,[r4,#0]
;;;285    
;;;286    	switch (pEPD->bmAttributes & USB_ENDPOINT_TYPE_MASK)
000076  78d3              LDRB     r3,[r2,#3]
000078  f0030303          AND      r3,r3,#3
00007c  b133              CBZ      r3,|L5.140|
00007e  2b01              CMP      r3,#1
000080  d007              BEQ      |L5.146|
000082  2b02              CMP      r3,#2
000084  d008              BEQ      |L5.152|
000086  2b03              CMP      r3,#3
000088  d10f              BNE      |L5.170|
00008a  e00b              B        |L5.164|
                  |L5.140|
;;;287    	{
;;;288    	case USB_ENDPOINT_TYPE_CONTROL:
;;;289    		val = EP_CONTROL;
00008c  f44f7000          MOV      r0,#0x200
;;;290    		break;
000090  e00b              B        |L5.170|
                  |L5.146|
;;;291    	case USB_ENDPOINT_TYPE_ISOCHRONOUS:
;;;292    		val = EP_ISOCHRONOUS;
000092  f44f6080          MOV      r0,#0x400
;;;293    		break;
000096  e008              B        |L5.170|
                  |L5.152|
;;;294    	case USB_ENDPOINT_TYPE_BULK:
;;;295    		val = EP_BULK;
000098  2000              MOVS     r0,#0
;;;296    		if (USB_DBL_BUF_EP & (1 << num))
00009a  2300              MOVS     r3,#0
00009c  b10b              CBZ      r3,|L5.162|
;;;297    		{
;;;298    			val |= EP_KIND;
00009e  f4407080          ORR      r0,r0,#0x100
                  |L5.162|
;;;299    		}
;;;300    		break;
0000a2  e002              B        |L5.170|
                  |L5.164|
;;;301    	case USB_ENDPOINT_TYPE_INTERRUPT:
;;;302    		val = EP_INTERRUPT;
0000a4  f44f60c0          MOV      r0,#0x600
;;;303    		break;
0000a8  bf00              NOP      
                  |L5.170|
0000aa  bf00              NOP                            ;290
;;;304    	}
;;;305    	val |= num;
0000ac  4308              ORRS     r0,r0,r1
;;;306    	EPxREG(num) = val;
0000ae  4c05              LDR      r4,|L5.196|
0000b0  eb040381          ADD      r3,r4,r1,LSL #2
0000b4  f8c30c00          STR      r0,[r3,#0xc00]
;;;307    }
0000b8  bd10              POP      {r4,pc}
;;;308    
                          ENDP

0000ba  0000              DCW      0x0000
                  |L5.188|
                          DCD      FreeBufAddr
                  |L5.192|
                          DCD      pBUF_DSCR
                  |L5.196|
                          DCD      0x40005000

                          AREA ||i.USBD_Configure||, CODE, READONLY, ALIGN=2

                  USBD_Configure PROC
;;;241     */
;;;242    void USBD_Configure (BOOL cfg)
000000  b930              CBNZ     r0,|L6.16|
;;;243    {
;;;244    	if (cfg == __FALSE)
;;;245    	{
;;;246    		FreeBufAddr  = EP_BUF_ADDR;
000002  2140              MOVS     r1,#0x40
000004  4a03              LDR      r2,|L6.20|
000006  8011              STRH     r1,[r2,#0]
;;;247    		FreeBufAddr += 2 * USBD_MAX_PACKET0;	/* reset Buffer address	*/
000008  4611              MOV      r1,r2
00000a  8809              LDRH     r1,[r1,#0]  ; FreeBufAddr
00000c  3180              ADDS     r1,r1,#0x80
00000e  8011              STRH     r1,[r2,#0]
                  |L6.16|
;;;248    	}
;;;249    }
000010  4770              BX       lr
;;;250    
                          ENDP

000012  0000              DCW      0x0000
                  |L6.20|
                          DCD      FreeBufAddr

                          AREA ||i.USBD_Connect||, CODE, READONLY, ALIGN=2

                  USBD_Connect PROC
;;;116     */
;;;117    void USBD_Connect (BOOL con)
000000  b170              CBZ      r0,|L7.32|
;;;118    {
;;;119    	if (con)
;;;120    	{
;;;121    		CNTR = CNTR_FRES;				/* Force USB Reset						*/
000002  2101              MOVS     r1,#1
000004  4a0a              LDR      r2,|L7.48|
000006  6011              STR      r1,[r2,#0]
;;;122    		CNTR = 0;
000008  2100              MOVS     r1,#0
00000a  6011              STR      r1,[r2,#0]
;;;123    		ISTR = 0;						/* Clear Interrupt Status				*/
00000c  1d12              ADDS     r2,r2,#4
00000e  6011              STR      r1,[r2,#0]
;;;124    		CNTR = CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM;	/* USB Interrupt Mask	*/
000010  f44f51e0          MOV      r1,#0x1c00
000014  1f12              SUBS     r2,r2,#4
000016  6011              STR      r1,[r2,#0]
;;;125    
;;;126    		PIN_USB_CONNECT_ON();
000018  13d1              ASRS     r1,r2,#15
00001a  4a06              LDR      r2,|L7.52|
00001c  6011              STR      r1,[r2,#0]
00001e  e006              B        |L7.46|
                  |L7.32|
;;;127    	}
;;;128    	else
;;;129    	{
;;;130    		CNTR = CNTR_FRES | CNTR_PDWN;	/* Switch Off USB Device			  */
000020  2103              MOVS     r1,#3
000022  4a03              LDR      r2,|L7.48|
000024  6011              STR      r1,[r2,#0]
;;;131    		PIN_USB_CONNECT_OFF();
000026  13d1              ASRS     r1,r2,#15
000028  4a02              LDR      r2,|L7.52|
00002a  1f12              SUBS     r2,r2,#4
00002c  6011              STR      r1,[r2,#0]
                  |L7.46|
;;;132    	}
;;;133    }
00002e  4770              BX       lr
;;;134    
                          ENDP

                  |L7.48|
                          DCD      0x40005c40
                  |L7.52|
                          DCD      0x40010c14

                          AREA ||i.USBD_DirCtrlEP||, CODE, READONLY, ALIGN=1

                  USBD_DirCtrlEP PROC
;;;313     */
;;;314    void USBD_DirCtrlEP (U32 dir)
000000  4770              BX       lr
;;;315    {
;;;316    	/* Not needed */
;;;317    }
;;;318    
                          ENDP


                          AREA ||i.USBD_DisableEP||, CODE, READONLY, ALIGN=1

                  USBD_DisableEP PROC
;;;337     */
;;;338    void USBD_DisableEP (U32 EPNum)
000000  b510              PUSH     {r4,lr}
;;;339    {
000002  4604              MOV      r4,r0
;;;340    	EP_Status(EPNum, EP_TX_DIS | EP_RX_DIS);
000004  2100              MOVS     r1,#0
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       EP_Status
;;;341    }
00000c  bd10              POP      {r4,pc}
;;;342    
                          ENDP


                          AREA ||i.USBD_EnableEP||, CODE, READONLY, ALIGN=1

                  USBD_EnableEP PROC
;;;325     */
;;;326    void USBD_EnableEP (U32 EPNum)
000000  b510              PUSH     {r4,lr}
;;;327    {
000002  4604              MOV      r4,r0
;;;328    	EP_Status(EPNum, EP_TX_NAK | EP_RX_VALID);	/* EP is able to receive */
000004  f2430120          MOV      r1,#0x3020
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       EP_Status
;;;329    }
00000e  bd10              POP      {r4,pc}
;;;330    
                          ENDP


                          AREA ||i.USBD_GetFrame||, CODE, READONLY, ALIGN=2

                  USBD_GetFrame PROC
;;;461     */
;;;462    U32 USBD_GetFrame (void)
000000  4802              LDR      r0,|L11.12|
;;;463    {
;;;464    	return (FNR & FNR_FN);
000002  6800              LDR      r0,[r0,#0]
000004  f3c0000a          UBFX     r0,r0,#0,#11
;;;465    }
000008  4770              BX       lr
;;;466    
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      0x40005c48

                          AREA ||i.USBD_Init||, CODE, READONLY, ALIGN=2

                  USBD_Init PROC
;;;102     */
;;;103    void USBD_Init (void)
000000  b510              PUSH     {r4,lr}
;;;104    {
;;;105    	RCC->APB1ENR |= RCC_APB1ENR_USBEN;
000002  4805              LDR      r0,|L12.24|
000004  69c0              LDR      r0,[r0,#0x1c]
000006  f4400000          ORR      r0,r0,#0x800000
00000a  4903              LDR      r1,|L12.24|
00000c  61c8              STR      r0,[r1,#0x1c]
;;;106    
;;;107    	USBD_IntrEna ();			/* Enable USB Interrupts */
00000e  f7fffffe          BL       USBD_IntrEna
;;;108    	PORT_USB_CONNECT_SETUP();
000012  f7fffffe          BL       PORT_USB_CONNECT_SETUP
;;;109    }
000016  bd10              POP      {r4,pc}
;;;110    
                          ENDP

                  |L12.24|
                          DCD      0x40021000

                          AREA ||i.USBD_IntrEna||, CODE, READONLY, ALIGN=1

                  USBD_IntrEna PROC
;;;91     #else
;;;92     void		  USBD_IntrEna (void)
000000  2014              MOVS     r0,#0x14
000002  2800              CMP      r0,#0
000004  db0d              BLT      |L13.34|
000006  bf00              NOP      
000008  bf00              NOP      
00000a  f000021f          AND      r2,r0,#0x1f
00000e  2101              MOVS     r1,#1
000010  4091              LSLS     r1,r1,r2
000012  0942              LSRS     r2,r0,#5
000014  0092              LSLS     r2,r2,#2
000016  f10222e0          ADD      r2,r2,#0xe000e000
00001a  f8c21100          STR      r1,[r2,#0x100]
00001e  bf00              NOP      
000020  bf00              NOP      
                  |L13.34|
000022  bf00              NOP      
;;;93     {
;;;94     #endif
;;;95     	NVIC_EnableIRQ(USB_LP_CAN1_RX0_IRQn);
;;;96     }
000024  4770              BX       lr
;;;97     
                          ENDP


                          AREA ||i.USBD_ReadEP||, CODE, READONLY, ALIGN=2

                  USBD_ReadEP PROC
;;;402     */
;;;403    U32 USBD_ReadEP (U32 EPNum, U8 *pData)
000000  e92d43f0          PUSH     {r4-r9,lr}
;;;404    {
000004  4605              MOV      r5,r0
000006  460c              MOV      r4,r1
;;;405    	/* Double Buffering is not yet supported	*/
;;;406    	U32 num, cnt, *pv, n;
;;;407    
;;;408    	num = EPNum & 0x0F;
000008  f005060f          AND      r6,r5,#0xf
;;;409    
;;;410    	pv  = (U32 *)(USB_PMA_ADDR + 2 * ((pBUF_DSCR + num)->ADDR_RX));
00000c  4812              LDR      r0,|L14.88|
00000e  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
000010  eb001006          ADD      r0,r0,r6,LSL #4
000014  6880              LDR      r0,[r0,#8]
000016  4911              LDR      r1,|L14.92|
000018  2202              MOVS     r2,#2
00001a  fb021900          MLA      r9,r2,r0,r1
;;;411    	cnt = (pBUF_DSCR + num)->COUNT_RX & EP_COUNT_MASK;
00001e  480e              LDR      r0,|L14.88|
000020  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
000022  eb001006          ADD      r0,r0,r6,LSL #4
000026  8980              LDRH     r0,[r0,#0xc]
000028  f3c00709          UBFX     r7,r0,#0,#10
;;;412    	for (n = 0; n < (cnt + 1) / 2; n++)
00002c  f04f0800          MOV      r8,#0
000030  e005              B        |L14.62|
                  |L14.50|
;;;413    	{
;;;414    		*((__packed U16 *)pData) = *pv++;
000032  f8391b04          LDRH     r1,[r9],#4
000036  8021              STRH     r1,[r4,#0]
;;;415    		pData += 2;
000038  1ca4              ADDS     r4,r4,#2
00003a  f1080801          ADD      r8,r8,#1              ;412
                  |L14.62|
00003e  1c78              ADDS     r0,r7,#1              ;412
000040  ebb80f50          CMP      r8,r0,LSR #1          ;412
000044  d3f5              BCC      |L14.50|
;;;416    	}
;;;417    	EP_Status(EPNum, EP_RX_VALID);
000046  f44f5140          MOV      r1,#0x3000
00004a  4628              MOV      r0,r5
00004c  f7fffffe          BL       EP_Status
;;;418    
;;;419    	return (cnt);
000050  4638              MOV      r0,r7
;;;420    }
000052  e8bd83f0          POP      {r4-r9,pc}
;;;421    
                          ENDP

000056  0000              DCW      0x0000
                  |L14.88|
                          DCD      pBUF_DSCR
                  |L14.92|
                          DCD      0x40006000

                          AREA ||i.USBD_Reset||, CODE, READONLY, ALIGN=2

                  USBD_Reset PROC
;;;139     */
;;;140    void USBD_Reset (void)
000000  2000              MOVS     r0,#0
;;;141    {
;;;142    	/* Double Buffering is not yet supported	*/
;;;143    
;;;144    	ISTR = 0;	/* Clear Interrupt Status		*/
000002  4927              LDR      r1,|L15.160|
000004  6008              STR      r0,[r1,#0]
;;;145    
;;;146    	CNTR = CNTR_CTRM | CNTR_RESETM | CNTR_SUSPM | CNTR_WKUPM
000006  4827              LDR      r0,|L15.164|
000008  6800              LDR      r0,[r0,#0]  ; USBD_P_Error_Event
00000a  b108              CBZ      r0,|L15.16|
;;;147    #ifdef __RTX
;;;148    			| ((USBD_RTX_DevTask	!= 0) ? CNTR_ERRM	: 0)
;;;149    			| ((USBD_RTX_DevTask	!= 0) ? CNTR_PMAOVRM : 0)
;;;150    			| ((USBD_RTX_DevTask	!= 0) ? CNTR_SOFM	: 0)
;;;151    			| ((USBD_RTX_DevTask	!= 0) ? CNTR_ESOFM	: 0);
;;;152    #else
;;;153    			| ((USBD_P_Error_Event != 0) ? CNTR_ERRM	: 0)
00000c  1448              ASRS     r0,r1,#17
00000e  e000              B        |L15.18|
                  |L15.16|
000010  2000              MOVS     r0,#0
                  |L15.18|
000012  f440401c          ORR      r0,r0,#0x9c00
000016  4923              LDR      r1,|L15.164|
000018  6809              LDR      r1,[r1,#0]  ; USBD_P_Error_Event
00001a  b111              CBZ      r1,|L15.34|
;;;154    			| ((USBD_P_Error_Event != 0) ? CNTR_PMAOVRM : 0)
00001c  f44f4180          MOV      r1,#0x4000
000020  e000              B        |L15.36|
                  |L15.34|
000022  2100              MOVS     r1,#0
                  |L15.36|
000024  4308              ORRS     r0,r0,r1
000026  4920              LDR      r1,|L15.168|
000028  6809              LDR      r1,[r1,#0]  ; USBD_P_SOF_Event
00002a  b111              CBZ      r1,|L15.50|
;;;155    			| ((USBD_P_SOF_Event	!= 0) ? CNTR_SOFM	: 0)
00002c  f44f7100          MOV      r1,#0x200
000030  e000              B        |L15.52|
                  |L15.50|
000032  2100              MOVS     r1,#0
                  |L15.52|
000034  4308              ORRS     r0,r0,r1
000036  491c              LDR      r1,|L15.168|
000038  6809              LDR      r1,[r1,#0]  ; USBD_P_SOF_Event
00003a  b111              CBZ      r1,|L15.66|
;;;156    			| ((USBD_P_SOF_Event	!= 0) ? CNTR_ESOFM	: 0);
00003c  f44f7180          MOV      r1,#0x100
000040  e000              B        |L15.68|
                  |L15.66|
000042  2100              MOVS     r1,#0
                  |L15.68|
000044  4308              ORRS     r0,r0,r1
000046  4916              LDR      r1,|L15.160|
000048  1f09              SUBS     r1,r1,#4
00004a  6008              STR      r0,[r1,#0]
;;;157    #endif
;;;158    
;;;159    	FreeBufAddr = EP_BUF_ADDR;
00004c  2040              MOVS     r0,#0x40
00004e  4917              LDR      r1,|L15.172|
000050  8008              STRH     r0,[r1,#0]
;;;160    
;;;161    	BTABLE = 0x00;	/* set BTABLE Address		*/
000052  2000              MOVS     r0,#0
000054  4912              LDR      r1,|L15.160|
000056  310c              ADDS     r1,r1,#0xc
000058  6008              STR      r0,[r1,#0]
;;;162    
;;;163    	/* Setup Control Endpoint 0 */
;;;164    	pBUF_DSCR->ADDR_TX = FreeBufAddr;
00005a  4814              LDR      r0,|L15.172|
00005c  8800              LDRH     r0,[r0,#0]  ; FreeBufAddr
00005e  4914              LDR      r1,|L15.176|
000060  6809              LDR      r1,[r1,#0]  ; pBUF_DSCR
000062  6008              STR      r0,[r1,#0]
;;;165    	FreeBufAddr += USBD_MAX_PACKET0;
000064  4811              LDR      r0,|L15.172|
000066  8800              LDRH     r0,[r0,#0]  ; FreeBufAddr
000068  3040              ADDS     r0,r0,#0x40
00006a  4910              LDR      r1,|L15.172|
00006c  8008              STRH     r0,[r1,#0]
;;;166    
;;;167    	pBUF_DSCR->ADDR_RX = FreeBufAddr;
00006e  4608              MOV      r0,r1
000070  8800              LDRH     r0,[r0,#0]  ; FreeBufAddr
000072  490f              LDR      r1,|L15.176|
000074  6809              LDR      r1,[r1,#0]  ; pBUF_DSCR
000076  6088              STR      r0,[r1,#8]
;;;168    	FreeBufAddr += USBD_MAX_PACKET0;
000078  480c              LDR      r0,|L15.172|
00007a  8800              LDRH     r0,[r0,#0]  ; FreeBufAddr
00007c  3040              ADDS     r0,r0,#0x40
00007e  490b              LDR      r1,|L15.172|
000080  8008              STRH     r0,[r1,#0]
;;;169    
;;;170    	if (USBD_MAX_PACKET0 > 62)
;;;171    	{
;;;172    		pBUF_DSCR->COUNT_RX = ((USBD_MAX_PACKET0 << 5) - 1) | 0x8000;
000082  f24870ff          MOV      r0,#0x87ff
000086  490a              LDR      r1,|L15.176|
000088  6809              LDR      r1,[r1,#0]  ; pBUF_DSCR
00008a  60c8              STR      r0,[r1,#0xc]
;;;173    	}
;;;174    	else
;;;175    	{
;;;176    		pBUF_DSCR->COUNT_RX =	USBD_MAX_PACKET0 << 9;
;;;177    	}
;;;178    	EPxREG(0) = EP_CONTROL | EP_RX_VALID;
00008c  f44f5048          MOV      r0,#0x3200
000090  4903              LDR      r1,|L15.160|
000092  3944              SUBS     r1,r1,#0x44
000094  6008              STR      r0,[r1,#0]
;;;179    
;;;180    	DADDR = DADDR_EF | 0;	/* Enable USB Default Address	*/
000096  2080              MOVS     r0,#0x80
000098  4901              LDR      r1,|L15.160|
00009a  3108              ADDS     r1,r1,#8
00009c  6008              STR      r0,[r1,#0]
;;;181    }
00009e  4770              BX       lr
;;;182    
                          ENDP

                  |L15.160|
                          DCD      0x40005c44
                  |L15.164|
                          DCD      USBD_P_Error_Event
                  |L15.168|
                          DCD      USBD_P_SOF_Event
                  |L15.172|
                          DCD      FreeBufAddr
                  |L15.176|
                          DCD      pBUF_DSCR

                          AREA ||i.USBD_ResetEP||, CODE, READONLY, ALIGN=1

                  USBD_ResetEP PROC
;;;349     */
;;;350    void USBD_ResetEP (U32 EPNum)
000000  b510              PUSH     {r4,lr}
;;;351    {
000002  4604              MOV      r4,r0
;;;352    	EP_Reset(EPNum);
000004  4620              MOV      r0,r4
000006  f7fffffe          BL       EP_Reset
;;;353    }
00000a  bd10              POP      {r4,pc}
;;;354    
                          ENDP


                          AREA ||i.USBD_Resume||, CODE, READONLY, ALIGN=1

                  USBD_Resume PROC
;;;198     */
;;;199    void USBD_Resume (void)
000000  4770              BX       lr
;;;200    {
;;;201    	/* Performed by Hardware	*/
;;;202    }
;;;203    
                          ENDP


                          AREA ||i.USBD_SetAddress||, CODE, READONLY, ALIGN=2

                  USBD_SetAddress PROC
;;;229     */
;;;230    void USBD_SetAddress (U32 adr, U32 setup)
000000  b101              CBZ      r1,|L18.4|
                  |L18.2|
;;;231    {
;;;232    	if (setup)
;;;233    		return;
;;;234    	DADDR = DADDR_EF | adr;
;;;235    }
000002  4770              BX       lr
                  |L18.4|
000004  f0400280          ORR      r2,r0,#0x80           ;234
000008  4b01              LDR      r3,|L18.16|
00000a  601a              STR      r2,[r3,#0]            ;234
00000c  bf00              NOP      
00000e  e7f8              B        |L18.2|
;;;236    
                          ENDP

                  |L18.16|
                          DCD      0x40005c4c

                          AREA ||i.USBD_SetStallEP||, CODE, READONLY, ALIGN=1

                  USBD_SetStallEP PROC
;;;362     */
;;;363    void USBD_SetStallEP (U32 EPNum)
000000  b510              PUSH     {r4,lr}
;;;364    {
000002  4604              MOV      r4,r0
;;;365    	EP_Status(EPNum, EP_TX_STALL | EP_RX_STALL);
000004  f2410110          MOV      r1,#0x1010
000008  4620              MOV      r0,r4
00000a  f7fffffe          BL       EP_Status
;;;366    }
00000e  bd10              POP      {r4,pc}
;;;367    
                          ENDP


                          AREA ||i.USBD_Suspend||, CODE, READONLY, ALIGN=2

                  USBD_Suspend PROC
;;;187     */
;;;188    void USBD_Suspend (void)
000000  4805              LDR      r0,|L20.24|
;;;189    {
;;;190    	CNTR |= CNTR_FSUSP;		/* Force Suspend	*/
000002  6800              LDR      r0,[r0,#0]
000004  f0400008          ORR      r0,r0,#8
000008  4903              LDR      r1,|L20.24|
00000a  6008              STR      r0,[r1,#0]
;;;191    	CNTR |= CNTR_LPMODE;	/* Low Power Mode	*/
00000c  4608              MOV      r0,r1
00000e  6800              LDR      r0,[r0,#0]
000010  f0400004          ORR      r0,r0,#4
000014  6008              STR      r0,[r1,#0]
;;;192    }
000016  4770              BX       lr
;;;193    
                          ENDP

                  |L20.24|
                          DCD      0x40005c40

                          AREA ||i.USBD_WakeUp||, CODE, READONLY, ALIGN=2

                  USBD_WakeUp PROC
;;;208     */
;;;209    void USBD_WakeUp (void)
000000  4803              LDR      r0,|L21.16|
;;;210    {
;;;211    	CNTR &= ~CNTR_FSUSP;	/* Clear Suspend	*/
000002  6800              LDR      r0,[r0,#0]
000004  f0200008          BIC      r0,r0,#8
000008  4901              LDR      r1,|L21.16|
00000a  6008              STR      r0,[r1,#0]
;;;212    }
00000c  4770              BX       lr
;;;213    
                          ENDP

00000e  0000              DCW      0x0000
                  |L21.16|
                          DCD      0x40005c40

                          AREA ||i.USBD_WakeUpCfg||, CODE, READONLY, ALIGN=1

                  USBD_WakeUpCfg PROC
;;;218     */
;;;219    void USBD_WakeUpCfg (BOOL cfg)
000000  4770              BX       lr
;;;220    {
;;;221    	/* Not needed */
;;;222    }
;;;223    
                          ENDP


                          AREA ||i.USBD_WriteEP||, CODE, READONLY, ALIGN=2

                  USBD_WriteEP PROC
;;;431    
;;;432    U32 USBD_WriteEP (U32 EPNum, U8 *pData, U32 cnt)
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;433    {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;434    	/* Double Buffering is not yet supported									*/
;;;435    	U32 num, *pv, n;
;;;436    	U16 statusEP;
;;;437    
;;;438    	num = EPNum & 0x0F;
00000a  f007060f          AND      r6,r7,#0xf
;;;439    
;;;440    	pv  = (U32 *)(USB_PMA_ADDR + 2 * ((pBUF_DSCR + num)->ADDR_TX));
00000e  4816              LDR      r0,|L23.104|
000010  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
000012  eb001006          ADD      r0,r0,r6,LSL #4
000016  6800              LDR      r0,[r0,#0]
000018  4914              LDR      r1,|L23.108|
00001a  2202              MOVS     r2,#2
00001c  fb021a00          MLA      r10,r2,r0,r1
;;;441    	for (n = 0; n < (cnt + 1) / 2; n++)
000020  f04f0800          MOV      r8,#0
000024  e005              B        |L23.50|
                  |L23.38|
;;;442    	{
;;;443    		*pv++ = *((__packed U16 *)pData);
000026  8828              LDRH     r0,[r5,#0]
000028  f84a0b04          STR      r0,[r10],#4
;;;444    		pData += 2;
00002c  1cad              ADDS     r5,r5,#2
00002e  f1080801          ADD      r8,r8,#1              ;441
                  |L23.50|
000032  1c60              ADDS     r0,r4,#1              ;441
000034  ebb80f50          CMP      r8,r0,LSR #1          ;441
000038  d3f5              BCC      |L23.38|
;;;445    	}
;;;446    	(pBUF_DSCR + num)->COUNT_TX = cnt;
00003a  480b              LDR      r0,|L23.104|
00003c  6800              LDR      r0,[r0,#0]  ; pBUF_DSCR
00003e  eb001006          ADD      r0,r0,r6,LSL #4
000042  6044              STR      r4,[r0,#4]
;;;447    
;;;448    	statusEP = EPxREG(num);
000044  490a              LDR      r1,|L23.112|
000046  eb010086          ADD      r0,r1,r6,LSL #2
00004a  f8d00c00          LDR      r0,[r0,#0xc00]
00004e  fa1ff980          UXTH     r9,r0
;;;449    	if ((statusEP & EP_STAT_TX) != EP_TX_STALL)
000052  f0090030          AND      r0,r9,#0x30
000056  2810              CMP      r0,#0x10
000058  d003              BEQ      |L23.98|
;;;450    	{	/* do not make EP valid if stalled */
;;;451    		EP_Status(EPNum, EP_TX_VALID);
00005a  2130              MOVS     r1,#0x30
00005c  4638              MOV      r0,r7
00005e  f7fffffe          BL       EP_Status
                  |L23.98|
;;;452    	}
;;;453    
;;;454    	return (cnt);
000062  4620              MOV      r0,r4
;;;455    }
000064  e8bd87f0          POP      {r4-r10,pc}
;;;456    
                          ENDP

                  |L23.104|
                          DCD      pBUF_DSCR
                  |L23.108|
                          DCD      0x40006000
                  |L23.112|
                          DCD      0x40005000

                          AREA ||i.USB_LP_CAN1_RX0_IRQHandler||, CODE, READONLY, ALIGN=2

                  USB_LP_CAN1_RX0_IRQHandler PROC
;;;483     */
;;;484    void USB_LP_CAN1_RX0_IRQHandler(void)
000000  b570              PUSH     {r4-r6,lr}
;;;485    {
;;;486    	U32 istr, num, val;
;;;487    
;;;488    	istr = ISTR;
000002  4850              LDR      r0,|L24.324|
000004  6805              LDR      r5,[r0,#0]
;;;489    
;;;490    	if (istr & ISTR_RESET)
000006  f4056080          AND      r0,r5,#0x400
00000a  b168              CBZ      r0,|L24.40|
;;;491    	{	/* USB Reset Request */
;;;492    		USBD_Reset();
00000c  f7fffffe          BL       USBD_Reset
;;;493    		usbd_reset_core();
000010  f7fffffe          BL       usbd_reset_core
;;;494    #ifdef __RTX
;;;495    		if (USBD_RTX_DevTask)
;;;496    		{
;;;497    			isr_evt_set(USBD_EVT_RESET, USBD_RTX_DevTask);
;;;498    		}
;;;499    #else
;;;500    		if (USBD_P_Reset_Event)
000014  484c              LDR      r0,|L24.328|
000016  6800              LDR      r0,[r0,#0]  ; USBD_P_Reset_Event
000018  b110              CBZ      r0,|L24.32|
;;;501    		{
;;;502    			USBD_P_Reset_Event();
00001a  484b              LDR      r0,|L24.328|
00001c  6800              LDR      r0,[r0,#0]  ; USBD_P_Reset_Event
00001e  4780              BLX      r0
                  |L24.32|
;;;503    		}
;;;504    #endif
;;;505    		ISTR = ~ISTR_RESET;
000020  f46f6080          MVN      r0,#0x400
000024  4947              LDR      r1,|L24.324|
000026  6008              STR      r0,[r1,#0]
                  |L24.40|
;;;506    	}
;;;507    
;;;508    	if (istr & ISTR_SUSP)
000028  f4056000          AND      r0,r5,#0x800
00002c  b158              CBZ      r0,|L24.70|
;;;509    	{	/* USB Suspend Request */
;;;510    		USBD_Suspend();
00002e  f7fffffe          BL       USBD_Suspend
;;;511    #ifdef __RTX
;;;512    		if (USBD_RTX_DevTask)
;;;513    		{
;;;514    			isr_evt_set(USBD_EVT_SUSPEND, USBD_RTX_DevTask);
;;;515    		}
;;;516    #else
;;;517    		if (USBD_P_Suspend_Event)
000032  4846              LDR      r0,|L24.332|
000034  6800              LDR      r0,[r0,#0]  ; USBD_P_Suspend_Event
000036  b110              CBZ      r0,|L24.62|
;;;518    		{
;;;519    			USBD_P_Suspend_Event();
000038  4844              LDR      r0,|L24.332|
00003a  6800              LDR      r0,[r0,#0]  ; USBD_P_Suspend_Event
00003c  4780              BLX      r0
                  |L24.62|
;;;520    		}
;;;521    #endif
;;;522    		ISTR = ~ISTR_SUSP;
00003e  f46f6000          MVN      r0,#0x800
000042  4940              LDR      r1,|L24.324|
000044  6008              STR      r0,[r1,#0]
                  |L24.70|
;;;523    	}
;;;524    
;;;525    	if (istr & ISTR_WKUP)
000046  f4055080          AND      r0,r5,#0x1000
00004a  b158              CBZ      r0,|L24.100|
;;;526    	{	/* USB Wakeup */
;;;527    		USBD_WakeUp();
00004c  f7fffffe          BL       USBD_WakeUp
;;;528    #ifdef __RTX
;;;529    		if (USBD_RTX_DevTask)
;;;530    		{
;;;531    			isr_evt_set(USBD_EVT_RESUME,  USBD_RTX_DevTask);
;;;532    		}
;;;533    #else
;;;534    		if (USBD_P_Resume_Event)
000050  483f              LDR      r0,|L24.336|
000052  6800              LDR      r0,[r0,#0]  ; USBD_P_Resume_Event
000054  b110              CBZ      r0,|L24.92|
;;;535    		{
;;;536    			USBD_P_Resume_Event();
000056  483e              LDR      r0,|L24.336|
000058  6800              LDR      r0,[r0,#0]  ; USBD_P_Resume_Event
00005a  4780              BLX      r0
                  |L24.92|
;;;537    		}
;;;538    #endif
;;;539    		ISTR = ~ISTR_WKUP;
00005c  f46f5080          MVN      r0,#0x1000
000060  4938              LDR      r1,|L24.324|
000062  6008              STR      r0,[r1,#0]
                  |L24.100|
;;;540    	}
;;;541    
;;;542    	if (istr & ISTR_SOF)
000064  f4057000          AND      r0,r5,#0x200
000068  b148              CBZ      r0,|L24.126|
;;;543    	{	/* Start of Frame */
;;;544    #ifdef __RTX
;;;545    		if (USBD_RTX_DevTask)
;;;546    		{
;;;547    			isr_evt_set(USBD_EVT_SOF, USBD_RTX_DevTask);
;;;548    		}
;;;549    #else
;;;550    		if (USBD_P_SOF_Event)
00006a  483a              LDR      r0,|L24.340|
00006c  6800              LDR      r0,[r0,#0]  ; USBD_P_SOF_Event
00006e  b110              CBZ      r0,|L24.118|
;;;551    		{
;;;552    			USBD_P_SOF_Event();
000070  4838              LDR      r0,|L24.340|
000072  6800              LDR      r0,[r0,#0]  ; USBD_P_SOF_Event
000074  4780              BLX      r0
                  |L24.118|
;;;553    		}
;;;554    #endif
;;;555    		ISTR = ~ISTR_SOF;
000076  f46f7000          MVN      r0,#0x200
00007a  4932              LDR      r1,|L24.324|
00007c  6008              STR      r0,[r1,#0]
                  |L24.126|
;;;556    	}
;;;557    
;;;558    	if (istr & ISTR_PMAOVR)
00007e  f4054080          AND      r0,r5,#0x4000
000082  b150              CBZ      r0,|L24.154|
;;;559    	{
;;;560    #ifdef __RTX
;;;561    		LastError = 2;
;;;562    		if (USBD_RTX_DevTask)
;;;563    		{	/* PMA Over/underrun */
;;;564    			isr_evt_set(USBD_EVT_ERROR, USBD_RTX_DevTask);
;;;565    		}
;;;566    #else
;;;567    		if (USBD_P_Error_Event)
000084  4834              LDR      r0,|L24.344|
000086  6800              LDR      r0,[r0,#0]  ; USBD_P_Error_Event
000088  b118              CBZ      r0,|L24.146|
;;;568    		{
;;;569    			USBD_P_Error_Event(2);
00008a  2002              MOVS     r0,#2
00008c  4932              LDR      r1,|L24.344|
00008e  6809              LDR      r1,[r1,#0]  ; USBD_P_Error_Event
000090  4788              BLX      r1
                  |L24.146|
;;;570    		}
;;;571    #endif
;;;572    		ISTR = ~ISTR_PMAOVR;
000092  f46f4080          MVN      r0,#0x4000
000096  492b              LDR      r1,|L24.324|
000098  6008              STR      r0,[r1,#0]
                  |L24.154|
;;;573    	}
;;;574    
;;;575    	if (istr & ISTR_ERR)
00009a  f4055000          AND      r0,r5,#0x2000
00009e  b150              CBZ      r0,|L24.182|
;;;576    	{	/* Error: No Answer, CRC Error, Bit Stuff Error, Frame Format Error */
;;;577    #ifdef __RTX
;;;578    		LastError = 1;
;;;579    		if (USBD_RTX_DevTask)
;;;580    		{
;;;581    			isr_evt_set(USBD_EVT_ERROR, USBD_RTX_DevTask);
;;;582    		}
;;;583    #else
;;;584    		if (USBD_P_Error_Event)
0000a0  482d              LDR      r0,|L24.344|
0000a2  6800              LDR      r0,[r0,#0]  ; USBD_P_Error_Event
0000a4  b118              CBZ      r0,|L24.174|
;;;585    		{
;;;586    			USBD_P_Error_Event(1);
0000a6  2001              MOVS     r0,#1
0000a8  492b              LDR      r1,|L24.344|
0000aa  6809              LDR      r1,[r1,#0]  ; USBD_P_Error_Event
0000ac  4788              BLX      r1
                  |L24.174|
;;;587    		}
;;;588    #endif
;;;589    		ISTR = ~ISTR_ERR;
0000ae  f46f5000          MVN      r0,#0x2000
0000b2  4924              LDR      r1,|L24.324|
0000b4  6008              STR      r0,[r1,#0]
                  |L24.182|
;;;590    	}
;;;591    
;;;592    	while ((istr = ISTR) & ISTR_CTR)
0000b6  e03c              B        |L24.306|
                  |L24.184|
;;;593    	{	/* Endpoint Interrupts */
;;;594    		ISTR = ~ISTR_CTR;
0000b8  f46f4000          MVN      r0,#0x8000
0000bc  4921              LDR      r1,|L24.324|
0000be  6008              STR      r0,[r1,#0]
;;;595    
;;;596    		num = istr & ISTR_EP_ID;
0000c0  f005040f          AND      r4,r5,#0xf
;;;597    
;;;598    		val = EPxREG(num);
0000c4  4925              LDR      r1,|L24.348|
0000c6  eb010084          ADD      r0,r1,r4,LSL #2
0000ca  f8d06c00          LDR      r6,[r0,#0xc00]
;;;599    		if (val & EP_CTR_RX)
0000ce  f4064000          AND      r0,r6,#0x8000
0000d2  b1c0              CBZ      r0,|L24.262|
;;;600    		{
;;;601    			EPxREG(num) = val & ~EP_CTR_RX & EP_MASK;
0000d4  f4264000          BIC      r0,r6,#0x8000
0000d8  f648718f          MOV      r1,#0x8f8f
0000dc  4008              ANDS     r0,r0,r1
0000de  4a1f              LDR      r2,|L24.348|
0000e0  eb020184          ADD      r1,r2,r4,LSL #2
0000e4  f8c10c00          STR      r0,[r1,#0xc00]
;;;602    #ifdef __RTX
;;;603    			if (USBD_RTX_EPTask[num])
;;;604    			{
;;;605    				isr_evt_set((val & EP_SETUP) ? USBD_EVT_SETUP : USBD_EVT_OUT, USBD_RTX_EPTask[num]);
;;;606    			}
;;;607    #else
;;;608    			if (USBD_P_EP[num])
0000e8  481d              LDR      r0,|L24.352|
0000ea  f8500024          LDR      r0,[r0,r4,LSL #2]
0000ee  b150              CBZ      r0,|L24.262|
;;;609    			{
;;;610    				USBD_P_EP[num]((val & EP_SETUP) ? USBD_EVT_SETUP : USBD_EVT_OUT);
0000f0  f4066200          AND      r2,r6,#0x800
0000f4  b10a              CBZ      r2,|L24.250|
0000f6  2202              MOVS     r2,#2
0000f8  e000              B        |L24.252|
                  |L24.250|
0000fa  2204              MOVS     r2,#4
                  |L24.252|
0000fc  4610              MOV      r0,r2
0000fe  4a18              LDR      r2,|L24.352|
000100  f8521024          LDR      r1,[r2,r4,LSL #2]
000104  4788              BLX      r1
                  |L24.262|
;;;611    			}
;;;612    #endif
;;;613    		}
;;;614    		if (val & EP_CTR_TX)
000106  f0060080          AND      r0,r6,#0x80
00010a  b190              CBZ      r0,|L24.306|
;;;615    		{
;;;616    			EPxREG(num) = val & ~EP_CTR_TX & EP_MASK;
00010c  f0260080          BIC      r0,r6,#0x80
000110  f648718f          MOV      r1,#0x8f8f
000114  4008              ANDS     r0,r0,r1
000116  4a11              LDR      r2,|L24.348|
000118  eb020184          ADD      r1,r2,r4,LSL #2
00011c  f8c10c00          STR      r0,[r1,#0xc00]
;;;617    #ifdef __RTX
;;;618    			if (USBD_RTX_EPTask[num])
;;;619    			{
;;;620    				isr_evt_set(USBD_EVT_IN,  USBD_RTX_EPTask[num]);
;;;621    			}
;;;622    #else
;;;623    			if (USBD_P_EP[num])
000120  480f              LDR      r0,|L24.352|
000122  f8500024          LDR      r0,[r0,r4,LSL #2]
000126  b120              CBZ      r0,|L24.306|
;;;624    			{
;;;625    				USBD_P_EP[num](USBD_EVT_IN);
000128  480d              LDR      r0,|L24.352|
00012a  f8501024          LDR      r1,[r0,r4,LSL #2]
00012e  2008              MOVS     r0,#8
000130  4788              BLX      r1
                  |L24.306|
000132  4804              LDR      r0,|L24.324|
000134  6800              LDR      r0,[r0,#0]            ;592
000136  4605              MOV      r5,r0                 ;592
000138  f4004000          AND      r0,r0,#0x8000         ;592
00013c  2800              CMP      r0,#0                 ;592
00013e  d1bb              BNE      |L24.184|
;;;626    			}
;;;627    #endif
;;;628    		}
;;;629    	}
;;;630    }
000140  bd70              POP      {r4-r6,pc}
                          ENDP

000142  0000              DCW      0x0000
                  |L24.324|
                          DCD      0x40005c44
                  |L24.328|
                          DCD      USBD_P_Reset_Event
                  |L24.332|
                          DCD      USBD_P_Suspend_Event
                  |L24.336|
                          DCD      USBD_P_Resume_Event
                  |L24.340|
                          DCD      USBD_P_SOF_Event
                  |L24.344|
                          DCD      USBD_P_Error_Event
                  |L24.348|
                          DCD      0x40005000
                  |L24.352|
                          DCD      USBD_P_EP

                          AREA ||.data||, DATA, ALIGN=2

                  pBUF_DSCR
                          DCD      0x40006000
                  FreeBufAddr
000004  0000              DCB      0x00,0x00

;*** Start embedded assembler ***

#line 1 "USB\\usbd_STM32F103.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___16_usbd_STM32F103_c_4b00160d____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____REVSH|
#line 507
|__asm___16_usbd_STM32F103_c_4b00160d____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___16_usbd_STM32F103_c_4b00160d____RRX|
#line 694
|__asm___16_usbd_STM32F103_c_4b00160d____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
