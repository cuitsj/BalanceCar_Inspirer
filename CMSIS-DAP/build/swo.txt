; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\swo.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\swo.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\swo.crf CMSIS-DAP\SWO.c]
                          THUMB

                          AREA ||i.ClearTrace||, CODE, READONLY, ALIGN=2

                  ClearTrace PROC
;;;316    // Clear Trace Errors and Data
;;;317    static void ClearTrace (void) {
000000  2000              MOVS     r0,#0
;;;318    
;;;319    #if (SWO_STREAM != 0)
;;;320      if (TraceTransport == 2U) {
;;;321        if (TransferBusy != 0U) {
;;;322          SWO_AbortTransfer();
;;;323          TransferBusy = 0U;
;;;324        }
;;;325      }
;;;326    #endif
;;;327    
;;;328      TraceError[0] = 0U;
000002  4905              LDR      r1,|L1.24|
000004  7008              STRB     r0,[r1,#0]
;;;329      TraceError[1] = 0U;
000006  7048              STRB     r0,[r1,#1]
;;;330      TraceError_n  = 0U;
000008  4904              LDR      r1,|L1.28|
00000a  7008              STRB     r0,[r1,#0]
;;;331      TraceIndexI   = 0U;
00000c  4904              LDR      r1,|L1.32|
00000e  6008              STR      r0,[r1,#0]  ; TraceIndexI
;;;332      TraceIndexO   = 0U;
000010  4904              LDR      r1,|L1.36|
000012  6008              STR      r0,[r1,#0]  ; TraceIndexO
;;;333    
;;;334    #if (TIMESTAMP_CLOCK != 0U) 
;;;335      TraceTimestamp.index = 0U;
;;;336      TraceTimestamp.tick  = 0U;
;;;337    #endif
;;;338    }
000014  4770              BX       lr
;;;339    
                          ENDP

000016  0000              DCW      0x0000
                  |L1.24|
                          DCD      TraceError
                  |L1.28|
                          DCD      TraceError_n
                  |L1.32|
                          DCD      TraceIndexI
                  |L1.36|
                          DCD      TraceIndexO

                          AREA ||i.GetTraceCount||, CODE, READONLY, ALIGN=2

                  GetTraceCount PROC
;;;371    //   return: number of available data bytes in trace buffer
;;;372    static uint32_t GetTraceCount (void) {
000000  b510              PUSH     {r4,lr}
;;;373      uint32_t count;
;;;374    
;;;375      if (TraceStatus == DAP_SWO_CAPTURE_ACTIVE) {
000002  4811              LDR      r0,|L2.72|
000004  7800              LDRB     r0,[r0,#0]  ; TraceStatus
000006  2801              CMP      r0,#1
000008  d117              BNE      |L2.58|
;;;376        do {
00000a  bf00              NOP      
                  |L2.12|
;;;377          TraceUpdate = 0U;
00000c  2000              MOVS     r0,#0
00000e  490f              LDR      r1,|L2.76|
000010  7008              STRB     r0,[r1,#0]
;;;378          count = TraceIndexI - TraceIndexO;
000012  480f              LDR      r0,|L2.80|
000014  6800              LDR      r0,[r0,#0]  ; TraceIndexI
000016  490f              LDR      r1,|L2.84|
000018  6809              LDR      r1,[r1,#0]  ; TraceIndexO
00001a  1a44              SUBS     r4,r0,r1
;;;379          switch (TraceMode) {
00001c  480e              LDR      r0,|L2.88|
00001e  7800              LDRB     r0,[r0,#0]  ; TraceMode
000020  2801              CMP      r0,#1
000022  d103              BNE      |L2.44|
;;;380    #if (SWO_UART != 0)
;;;381            case DAP_SWO_UART:
;;;382              count += UART_SWO_GetCount();
000024  f7fffffe          BL       UART_SWO_GetCount
000028  4404              ADD      r4,r4,r0
;;;383              break;
00002a  e000              B        |L2.46|
                  |L2.44|
;;;384    #endif
;;;385    #if (SWO_MANCHESTER != 0)
;;;386            case DAP_SWO_MANCHESTER:
;;;387              count += Manchester_SWO_GetCount();
;;;388              break;
;;;389    #endif
;;;390            default:
;;;391              break;
00002c  bf00              NOP      
                  |L2.46|
00002e  bf00              NOP                            ;383
;;;392          }
;;;393        } while (TraceUpdate != 0U);
000030  4806              LDR      r0,|L2.76|
000032  7800              LDRB     r0,[r0,#0]  ; TraceUpdate
000034  2800              CMP      r0,#0
000036  d1e9              BNE      |L2.12|
000038  e004              B        |L2.68|
                  |L2.58|
;;;394      } else {
;;;395        count = TraceIndexI - TraceIndexO;
00003a  4805              LDR      r0,|L2.80|
00003c  6800              LDR      r0,[r0,#0]  ; TraceIndexI
00003e  4905              LDR      r1,|L2.84|
000040  6809              LDR      r1,[r1,#0]  ; TraceIndexO
000042  1a44              SUBS     r4,r0,r1
                  |L2.68|
;;;396      }
;;;397    
;;;398      return (count);
000044  4620              MOV      r0,r4
;;;399    }
000046  bd10              POP      {r4,pc}
;;;400    
                          ENDP

                  |L2.72|
                          DCD      TraceStatus
                  |L2.76|
                          DCD      TraceUpdate
                  |L2.80|
                          DCD      TraceIndexI
                  |L2.84|
                          DCD      TraceIndexO
                  |L2.88|
                          DCD      TraceMode

                          AREA ||i.GetTraceStatus||, CODE, READONLY, ALIGN=2

                  GetTraceStatus PROC
;;;402    //   return: Trace Status (Active flag and Error flags)
;;;403    static uint8_t GetTraceStatus (void) {
000000  4a08              LDR      r2,|L3.36|
;;;404      uint8_t  status;
;;;405      uint32_t n;
;;;406    
;;;407      n = TraceError_n;
000002  7811              LDRB     r1,[r2,#0]  ; TraceError_n
;;;408      TraceError_n ^= 1U;
000004  7812              LDRB     r2,[r2,#0]  ; TraceError_n
000006  f0820201          EOR      r2,r2,#1
00000a  4b06              LDR      r3,|L3.36|
00000c  701a              STRB     r2,[r3,#0]
;;;409      status = TraceStatus | TraceError[n];
00000e  4a06              LDR      r2,|L3.40|
000010  5c52              LDRB     r2,[r2,r1]
000012  4b06              LDR      r3,|L3.44|
000014  781b              LDRB     r3,[r3,#0]  ; TraceStatus
000016  ea420003          ORR      r0,r2,r3
;;;410      TraceError[n] = 0U;
00001a  2200              MOVS     r2,#0
00001c  4b02              LDR      r3,|L3.40|
00001e  545a              STRB     r2,[r3,r1]
;;;411    
;;;412      return (status);
;;;413    }
000020  4770              BX       lr
;;;414    
                          ENDP

000022  0000              DCW      0x0000
                  |L3.36|
                          DCD      TraceError_n
                  |L3.40|
                          DCD      TraceError
                  |L3.44|
                          DCD      TraceStatus

                          AREA ||i.ResumeTrace||, CODE, READONLY, ALIGN=2

                  ResumeTrace PROC
;;;340    // Resume Trace Capture
;;;341    static void ResumeTrace (void) {
000000  b570              PUSH     {r4-r6,lr}
;;;342      uint32_t index_i;
;;;343      uint32_t index_o;
;;;344    
;;;345      if (TraceStatus == (DAP_SWO_CAPTURE_ACTIVE | DAP_SWO_CAPTURE_PAUSED)) {
000002  480e              LDR      r0,|L4.60|
000004  7800              LDRB     r0,[r0,#0]  ; TraceStatus
000006  2803              CMP      r0,#3
000008  d117              BNE      |L4.58|
;;;346        index_i = TraceIndexI;
00000a  480d              LDR      r0,|L4.64|
00000c  6804              LDR      r4,[r0,#0]  ; TraceIndexI
;;;347        index_o = TraceIndexO;
00000e  480d              LDR      r0,|L4.68|
000010  6805              LDR      r5,[r0,#0]  ; TraceIndexO
;;;348        if ((index_i - index_o) < SWO_BUFFER_SIZE) {
000012  1b60              SUBS     r0,r4,r5
000014  f5b05f80          CMP      r0,#0x1000
000018  d20f              BCS      |L4.58|
;;;349          index_i &= SWO_BUFFER_SIZE - 1U;
00001a  f3c4040b          UBFX     r4,r4,#0,#12
;;;350          switch (TraceMode) {
00001e  480a              LDR      r0,|L4.72|
000020  7800              LDRB     r0,[r0,#0]  ; TraceMode
000022  2801              CMP      r0,#1
000024  d107              BNE      |L4.54|
;;;351    #if (SWO_UART != 0)
;;;352            case DAP_SWO_UART:
;;;353              TraceStatus = DAP_SWO_CAPTURE_ACTIVE;
000026  4905              LDR      r1,|L4.60|
000028  7008              STRB     r0,[r1,#0]
;;;354              UART_SWO_Capture(&TraceBuf[index_i], 1U);
00002a  4908              LDR      r1,|L4.76|
00002c  1908              ADDS     r0,r1,r4
00002e  2101              MOVS     r1,#1
000030  f7fffffe          BL       UART_SWO_Capture
;;;355              break;
000034  e000              B        |L4.56|
                  |L4.54|
;;;356    #endif
;;;357    #if (SWO_MANCHESTER != 0)
;;;358            case DAP_SWO_MANCHESTER:
;;;359              TraceStatus = DAP_SWO_CAPTURE_ACTIVE;
;;;360              Manchester_SWO_Capture(&TraceBuf[index_i], 1U);
;;;361              break;
;;;362    #endif
;;;363            default:
;;;364              break;
000036  bf00              NOP      
                  |L4.56|
000038  bf00              NOP                            ;355
                  |L4.58|
;;;365          }
;;;366        }
;;;367      }
;;;368    }
00003a  bd70              POP      {r4-r6,pc}
;;;369    
                          ENDP

                  |L4.60|
                          DCD      TraceStatus
                  |L4.64|
                          DCD      TraceIndexI
                  |L4.68|
                          DCD      TraceIndexO
                  |L4.72|
                          DCD      TraceMode
                  |L4.76|
                          DCD      TraceBuf

                          AREA ||i.SWO_Baudrate||, CODE, READONLY, ALIGN=2

                  SWO_Baudrate PROC
;;;526    //             number of bytes in request (upper 16 bits)
;;;527    uint32_t SWO_Baudrate (const uint8_t *request, uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4606              MOV      r6,r0
000004  460c              MOV      r4,r1
;;;528      uint32_t baudrate;
;;;529    
;;;530      baudrate = (uint32_t)(*(request+0) <<  0) |
000006  7830              LDRB     r0,[r6,#0]
000008  7871              LDRB     r1,[r6,#1]
00000a  ea402001          ORR      r0,r0,r1,LSL #8
00000e  78b1              LDRB     r1,[r6,#2]
000010  ea404001          ORR      r0,r0,r1,LSL #16
000014  78f1              LDRB     r1,[r6,#3]
000016  ea406501          ORR      r5,r0,r1,LSL #24
;;;531                 (uint32_t)(*(request+1) <<  8) |
;;;532                 (uint32_t)(*(request+2) << 16) |
;;;533                 (uint32_t)(*(request+3) << 24);
;;;534    
;;;535      switch (TraceMode) {
00001a  480e              LDR      r0,|L5.84|
00001c  7800              LDRB     r0,[r0,#0]  ; TraceMode
00001e  2801              CMP      r0,#1
000020  d104              BNE      |L5.44|
;;;536    #if (SWO_UART != 0)
;;;537        case DAP_SWO_UART:
;;;538          baudrate = UART_SWO_Baudrate(baudrate);
000022  4628              MOV      r0,r5
000024  f7fffffe          BL       UART_SWO_Baudrate
000028  4605              MOV      r5,r0
;;;539          break;
00002a  e001              B        |L5.48|
                  |L5.44|
;;;540    #endif
;;;541    #if (SWO_MANCHESTER != 0)
;;;542        case DAP_SWO_MANCHESTER:
;;;543          baudrate = Manchester_SWO_Baudrate(baudrate);
;;;544          break;
;;;545    #endif
;;;546        default:
;;;547          baudrate = 0U;
00002c  2500              MOVS     r5,#0
;;;548          break;
00002e  bf00              NOP      
                  |L5.48|
000030  bf00              NOP                            ;539
;;;549      }
;;;550    
;;;551      if (baudrate == 0U) {
000032  b915              CBNZ     r5,|L5.58|
;;;552        TraceStatus = 0U;
000034  2000              MOVS     r0,#0
000036  4908              LDR      r1,|L5.88|
000038  7008              STRB     r0,[r1,#0]
                  |L5.58|
;;;553      }
;;;554    
;;;555      *response++ = (uint8_t)(baudrate >>  0);
00003a  f8045b01          STRB     r5,[r4],#1
;;;556      *response++ = (uint8_t)(baudrate >>  8);
00003e  0a28              LSRS     r0,r5,#8
000040  f8040b01          STRB     r0,[r4],#1
;;;557      *response++ = (uint8_t)(baudrate >> 16);
000044  0c28              LSRS     r0,r5,#16
000046  f8040b01          STRB     r0,[r4],#1
;;;558      *response   = (uint8_t)(baudrate >> 24);
00004a  0e28              LSRS     r0,r5,#24
00004c  7020              STRB     r0,[r4,#0]
;;;559    
;;;560      return ((4U << 16) | 4U);
00004e  f04f1004          MOV      r0,#0x40004
;;;561    }
000052  bd70              POP      {r4-r6,pc}
;;;562    
                          ENDP

                  |L5.84|
                          DCD      TraceMode
                  |L5.88|
                          DCD      TraceStatus

                          AREA ||i.SWO_Control||, CODE, READONLY, ALIGN=2

                  SWO_Control PROC
;;;568    //             number of bytes in request (upper 16 bits)
;;;569    uint32_t SWO_Control (const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4607              MOV      r7,r0
000006  460e              MOV      r6,r1
;;;570      uint8_t  active;
;;;571      uint32_t result;
;;;572    
;;;573      active = *request & DAP_SWO_CAPTURE_ACTIVE;
000008  7838              LDRB     r0,[r7,#0]
00000a  f0000501          AND      r5,r0,#1
;;;574    
;;;575      if (active != (TraceStatus & DAP_SWO_CAPTURE_ACTIVE)) {
00000e  4812              LDR      r0,|L6.88|
000010  7800              LDRB     r0,[r0,#0]  ; TraceStatus
000012  f0000001          AND      r0,r0,#1
000016  42a8              CMP      r0,r5
000018  d012              BEQ      |L6.64|
;;;576        if (active) {
00001a  b10d              CBZ      r5,|L6.32|
;;;577          ClearTrace();
00001c  f7fffffe          BL       ClearTrace
                  |L6.32|
;;;578        }
;;;579        switch (TraceMode) {
000020  480e              LDR      r0,|L6.92|
000022  7800              LDRB     r0,[r0,#0]  ; TraceMode
000024  2801              CMP      r0,#1
000026  d104              BNE      |L6.50|
;;;580    #if (SWO_UART != 0)
;;;581          case DAP_SWO_UART:
;;;582            result = UART_SWO_Control(active);
000028  4628              MOV      r0,r5
00002a  f7fffffe          BL       UART_SWO_Control
00002e  4604              MOV      r4,r0
;;;583            break;
000030  e001              B        |L6.54|
                  |L6.50|
;;;584    #endif
;;;585    #if (SWO_MANCHESTER != 0)
;;;586          case DAP_SWO_MANCHESTER:
;;;587            result = Manchester_SWO_Control(active);
;;;588            break;
;;;589    #endif
;;;590          default:
;;;591            result = 0U;
000032  2400              MOVS     r4,#0
;;;592            break;
000034  bf00              NOP      
                  |L6.54|
000036  bf00              NOP                            ;583
;;;593        }
;;;594        if (result != 0U) {
000038  b11c              CBZ      r4,|L6.66|
;;;595          TraceStatus = active;
00003a  4807              LDR      r0,|L6.88|
00003c  7005              STRB     r5,[r0,#0]
00003e  e000              B        |L6.66|
                  |L6.64|
;;;596    #if (SWO_STREAM != 0)
;;;597          if (TraceTransport == 2U) {
;;;598            osThreadFlagsSet(SWO_ThreadId, 1U);
;;;599          }
;;;600    #endif
;;;601        }
;;;602      } else {
;;;603        result = 1U;
000040  2401              MOVS     r4,#1
                  |L6.66|
;;;604      }
;;;605    
;;;606      if (result != 0U) {
000042  b114              CBZ      r4,|L6.74|
;;;607        *response = DAP_OK;
000044  2000              MOVS     r0,#0
000046  7030              STRB     r0,[r6,#0]
000048  e001              B        |L6.78|
                  |L6.74|
;;;608      } else {
;;;609        *response = DAP_ERROR;
00004a  20ff              MOVS     r0,#0xff
00004c  7030              STRB     r0,[r6,#0]
                  |L6.78|
;;;610      }
;;;611    
;;;612      return ((1U << 16) | 1U);
00004e  f04f1001          MOV      r0,#0x10001
;;;613    }
000052  e8bd81f0          POP      {r4-r8,pc}
;;;614    
                          ENDP

000056  0000              DCW      0x0000
                  |L6.88|
                          DCD      TraceStatus
                  |L6.92|
                          DCD      TraceMode

                          AREA ||i.SWO_Data||, CODE, READONLY, ALIGN=2

                  SWO_Data PROC
;;;696    //             number of bytes in request (upper 16 bits)
;;;697    uint32_t SWO_Data (const uint8_t *request, uint8_t *response) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;698      uint8_t  status;
;;;699      uint32_t count;
;;;700      uint32_t index;
;;;701      uint32_t n, i;
;;;702    
;;;703      status = GetTraceStatus();
000008  f7fffffe          BL       GetTraceStatus
00000c  4682              MOV      r10,r0
;;;704      count  = GetTraceCount();
00000e  f7fffffe          BL       GetTraceCount
000012  4605              MOV      r5,r0
;;;705    
;;;706      if (TraceTransport == 1U) {
000014  481c              LDR      r0,|L7.136|
000016  7800              LDRB     r0,[r0,#0]  ; TraceTransport
000018  2801              CMP      r0,#1
00001a  d10c              BNE      |L7.54|
;;;707        n = (uint32_t)(*(request+0) << 0) |
00001c  f8980000          LDRB     r0,[r8,#0]
000020  f8981001          LDRB     r1,[r8,#1]
000024  ea402601          ORR      r6,r0,r1,LSL #8
;;;708            (uint32_t)(*(request+1) << 8);
;;;709        if (n > (DAP_PACKET_SIZE - 4U)) {
000028  2e3c              CMP      r6,#0x3c
00002a  d900              BLS      |L7.46|
;;;710          n = DAP_PACKET_SIZE - 4U;
00002c  263c              MOVS     r6,#0x3c
                  |L7.46|
;;;711        }
;;;712        if (count > n) {
00002e  42b5              CMP      r5,r6
000030  d902              BLS      |L7.56|
;;;713          count = n;
000032  4635              MOV      r5,r6
000034  e000              B        |L7.56|
                  |L7.54|
;;;714        }
;;;715      } else {
;;;716        count = 0U;
000036  2500              MOVS     r5,#0
                  |L7.56|
;;;717      }
;;;718    
;;;719      *response++ = status;
000038  f804ab01          STRB     r10,[r4],#1
;;;720      *response++ = (uint8_t)(count >> 0);
00003c  f8045b01          STRB     r5,[r4],#1
;;;721      *response++ = (uint8_t)(count >> 8);
000040  0a28              LSRS     r0,r5,#8
000042  f8040b01          STRB     r0,[r4],#1
;;;722    
;;;723      if (TraceTransport == 1U) {
000046  4810              LDR      r0,|L7.136|
000048  7800              LDRB     r0,[r0,#0]  ; TraceTransport
00004a  2801              CMP      r0,#1
00004c  d116              BNE      |L7.124|
;;;724        index = TraceIndexO;
00004e  480f              LDR      r0,|L7.140|
000050  f8d09000          LDR      r9,[r0,#0]  ; TraceIndexO
;;;725        for (i = index, n = count; n; n--) {
000054  464f              MOV      r7,r9
000056  462e              MOV      r6,r5
000058  e008              B        |L7.108|
                  |L7.90|
;;;726          i &= SWO_BUFFER_SIZE - 1U;
00005a  f3c7070b          UBFX     r7,r7,#0,#12
;;;727          *response++ = TraceBuf[i++];
00005e  4638              MOV      r0,r7
000060  1c7f              ADDS     r7,r7,#1
000062  490b              LDR      r1,|L7.144|
000064  5c08              LDRB     r0,[r1,r0]
000066  f8040b01          STRB     r0,[r4],#1
00006a  1e76              SUBS     r6,r6,#1              ;725
                  |L7.108|
00006c  2e00              CMP      r6,#0                 ;725
00006e  d1f4              BNE      |L7.90|
;;;728        }
;;;729        TraceIndexO = index + count;
000070  eb090005          ADD      r0,r9,r5
000074  4905              LDR      r1,|L7.140|
000076  6008              STR      r0,[r1,#0]  ; TraceIndexO
;;;730        ResumeTrace();
000078  f7fffffe          BL       ResumeTrace
                  |L7.124|
;;;731      }
;;;732    
;;;733      return ((2U << 16) | (3U + count));
00007c  1ce8              ADDS     r0,r5,#3
00007e  f4403000          ORR      r0,r0,#0x20000
;;;734    }
000082  e8bd87f0          POP      {r4-r10,pc}
;;;735    
                          ENDP

000086  0000              DCW      0x0000
                  |L7.136|
                          DCD      TraceTransport
                  |L7.140|
                          DCD      TraceIndexO
                  |L7.144|
                          DCD      TraceBuf

                          AREA ||i.SWO_ExtendedStatus||, CODE, READONLY, ALIGN=1

                  SWO_ExtendedStatus PROC
;;;640    //             number of bytes in request (upper 16 bits)
;;;641    uint32_t SWO_ExtendedStatus (const uint8_t *request, uint8_t *response) {
000000  e92d47f0          PUSH     {r4-r10,lr}
000004  4680              MOV      r8,r0
000006  460c              MOV      r4,r1
;;;642      uint8_t  cmd;
;;;643      uint8_t  status;
;;;644      uint32_t count;
;;;645    #if (TIMESTAMP_CLOCK != 0U) 
;;;646      uint32_t index;
;;;647      uint32_t tick;
;;;648    #endif
;;;649      uint32_t num;
;;;650    
;;;651      num = 0U;
000008  2700              MOVS     r7,#0
;;;652      cmd = *request;
00000a  f8989000          LDRB     r9,[r8,#0]
;;;653    
;;;654      if (cmd & 0x01U) {
00000e  f0090001          AND      r0,r9,#1
000012  b128              CBZ      r0,|L8.32|
;;;655        status = GetTraceStatus();
000014  f7fffffe          BL       GetTraceStatus
000018  4606              MOV      r6,r0
;;;656        *response++ = status;
00001a  f8046b01          STRB     r6,[r4],#1
;;;657        num += 1U;
00001e  1c7f              ADDS     r7,r7,#1
                  |L8.32|
;;;658      }
;;;659    
;;;660      if (cmd & 0x02U) {
000020  f0090002          AND      r0,r9,#2
000024  b170              CBZ      r0,|L8.68|
;;;661        count = GetTraceCount();
000026  f7fffffe          BL       GetTraceCount
00002a  4605              MOV      r5,r0
;;;662        *response++ = (uint8_t)(count >>  0);
00002c  f8045b01          STRB     r5,[r4],#1
;;;663        *response++ = (uint8_t)(count >>  8);
000030  0a28              LSRS     r0,r5,#8
000032  f8040b01          STRB     r0,[r4],#1
;;;664        *response++ = (uint8_t)(count >> 16);
000036  0c28              LSRS     r0,r5,#16
000038  f8040b01          STRB     r0,[r4],#1
;;;665        *response++ = (uint8_t)(count >> 24);
00003c  0e28              LSRS     r0,r5,#24
00003e  f8040b01          STRB     r0,[r4],#1
;;;666        num += 4U;
000042  1d3f              ADDS     r7,r7,#4
                  |L8.68|
;;;667      }
;;;668    
;;;669    #if (TIMESTAMP_CLOCK != 0U) 
;;;670      if (cmd & 0x04U) {
;;;671        do {
;;;672          TraceUpdate = 0U;
;;;673          index = TraceTimestamp.index;
;;;674          tick  = TraceTimestamp.tick;
;;;675        } while (TraceUpdate != 0U);
;;;676        *response++ = (uint8_t)(index >>  0);
;;;677        *response++ = (uint8_t)(index >>  8);
;;;678        *response++ = (uint8_t)(index >> 16);
;;;679        *response++ = (uint8_t)(index >> 24);
;;;680        *response++ = (uint8_t)(tick  >>  0);
;;;681        *response++ = (uint8_t)(tick  >>  8);
;;;682        *response++ = (uint8_t)(tick  >> 16);
;;;683        *response++ = (uint8_t)(tick  >> 24);
;;;684        num += 4U;
;;;685      }
;;;686    #endif
;;;687    
;;;688      return ((1U << 16) | num);
000044  f4473080          ORR      r0,r7,#0x10000
;;;689    }
000048  e8bd87f0          POP      {r4-r10,pc}
;;;690    
                          ENDP


                          AREA ||i.SWO_Mode||, CODE, READONLY, ALIGN=2

                  SWO_Mode PROC
;;;464    //             number of bytes in request (upper 16 bits)
;;;465    uint32_t SWO_Mode (const uint8_t *request, uint8_t *response) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4606              MOV      r6,r0
000006  460d              MOV      r5,r1
;;;466      uint8_t  mode;
;;;467      uint32_t result;
;;;468    
;;;469      mode = *request;
000008  7837              LDRB     r7,[r6,#0]
;;;470    
;;;471      switch (TraceMode) {
00000a  4815              LDR      r0,|L9.96|
00000c  7800              LDRB     r0,[r0,#0]  ; TraceMode
00000e  2801              CMP      r0,#1
000010  d103              BNE      |L9.26|
;;;472    #if (SWO_UART != 0)
;;;473        case DAP_SWO_UART:
;;;474          UART_SWO_Mode(0U);
000012  2000              MOVS     r0,#0
000014  f7fffffe          BL       UART_SWO_Mode
;;;475          break;
000018  e000              B        |L9.28|
                  |L9.26|
;;;476    #endif
;;;477    #if (SWO_MANCHESTER != 0)
;;;478        case DAP_SWO_MANCHESTER:
;;;479          Manchester_SWO_Mode(0U);
;;;480          break;
;;;481    #endif
;;;482        default:
;;;483          break;
00001a  bf00              NOP      
                  |L9.28|
00001c  bf00              NOP                            ;475
;;;484      }
;;;485    
;;;486      switch (mode) {
00001e  b117              CBZ      r7,|L9.38|
000020  2f01              CMP      r7,#1
000022  d107              BNE      |L9.52|
000024  e001              B        |L9.42|
                  |L9.38|
;;;487        case DAP_SWO_OFF:
;;;488          result = 1U;
000026  2401              MOVS     r4,#1
;;;489          break;
000028  e006              B        |L9.56|
                  |L9.42|
;;;490    #if (SWO_UART != 0)
;;;491        case DAP_SWO_UART:
;;;492          result = UART_SWO_Mode(1U);
00002a  2001              MOVS     r0,#1
00002c  f7fffffe          BL       UART_SWO_Mode
000030  4604              MOV      r4,r0
;;;493          break;
000032  e001              B        |L9.56|
                  |L9.52|
;;;494    #endif
;;;495    #if (SWO_MANCHESTER != 0)
;;;496        case DAP_SWO_MANCHESTER:
;;;497          result = Manchester_SWO_Mode(1U);
;;;498          break;
;;;499    #endif
;;;500        default:
;;;501          result = 0U;
000034  2400              MOVS     r4,#0
;;;502          break;
000036  bf00              NOP      
                  |L9.56|
000038  bf00              NOP                            ;489
;;;503      }
;;;504      if (result != 0U) {
00003a  b114              CBZ      r4,|L9.66|
;;;505        TraceMode = mode;
00003c  4808              LDR      r0,|L9.96|
00003e  7007              STRB     r7,[r0,#0]
000040  e002              B        |L9.72|
                  |L9.66|
;;;506      } else {
;;;507        TraceMode = DAP_SWO_OFF;
000042  2000              MOVS     r0,#0
000044  4906              LDR      r1,|L9.96|
000046  7008              STRB     r0,[r1,#0]
                  |L9.72|
;;;508      }
;;;509    
;;;510      TraceStatus = 0U;
000048  2000              MOVS     r0,#0
00004a  4906              LDR      r1,|L9.100|
00004c  7008              STRB     r0,[r1,#0]
;;;511    
;;;512      if (result != 0U) {
00004e  b10c              CBZ      r4,|L9.84|
;;;513        *response = DAP_OK;
000050  7028              STRB     r0,[r5,#0]
000052  e001              B        |L9.88|
                  |L9.84|
;;;514      } else {
;;;515        *response = DAP_ERROR;
000054  20ff              MOVS     r0,#0xff
000056  7028              STRB     r0,[r5,#0]
                  |L9.88|
;;;516      }
;;;517    
;;;518      return ((1U << 16) | 1U);
000058  f04f1001          MOV      r0,#0x10001
;;;519    }
00005c  e8bd81f0          POP      {r4-r8,pc}
;;;520    
                          ENDP

                  |L9.96|
                          DCD      TraceMode
                  |L9.100|
                          DCD      TraceStatus

                          AREA ||i.SWO_Status||, CODE, READONLY, ALIGN=1

                  SWO_Status PROC
;;;618    //   return:   number of bytes in response
;;;619    uint32_t SWO_Status (uint8_t *response) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;620      uint8_t  status;
;;;621      uint32_t count;
;;;622    
;;;623      status = GetTraceStatus();
000004  f7fffffe          BL       GetTraceStatus
000008  4606              MOV      r6,r0
;;;624      count  = GetTraceCount();
00000a  f7fffffe          BL       GetTraceCount
00000e  4605              MOV      r5,r0
;;;625    
;;;626      *response++ = status;
000010  f8046b01          STRB     r6,[r4],#1
;;;627      *response++ = (uint8_t)(count >>  0);
000014  f8045b01          STRB     r5,[r4],#1
;;;628      *response++ = (uint8_t)(count >>  8);
000018  0a28              LSRS     r0,r5,#8
00001a  f8040b01          STRB     r0,[r4],#1
;;;629      *response++ = (uint8_t)(count >> 16);
00001e  0c28              LSRS     r0,r5,#16
000020  f8040b01          STRB     r0,[r4],#1
;;;630      *response   = (uint8_t)(count >> 24);
000024  0e28              LSRS     r0,r5,#24
000026  7020              STRB     r0,[r4,#0]
;;;631    
;;;632      return (5U);
000028  2005              MOVS     r0,#5
;;;633    }
00002a  bd70              POP      {r4-r6,pc}
;;;634    
                          ENDP


                          AREA ||i.SWO_Transport||, CODE, READONLY, ALIGN=2

                  SWO_Transport PROC
;;;426    //             number of bytes in request (upper 16 bits)
;;;427    uint32_t SWO_Transport (const uint8_t *request, uint8_t *response) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  460a              MOV      r2,r1
;;;428      uint8_t  transport;
;;;429      uint32_t result;
;;;430    
;;;431      if ((TraceStatus & DAP_SWO_CAPTURE_ACTIVE) == 0U) {
000006  480e              LDR      r0,|L11.64|
000008  7800              LDRB     r0,[r0,#0]  ; TraceStatus
00000a  f0000001          AND      r0,r0,#1
00000e  b960              CBNZ     r0,|L11.42|
;;;432        transport = *request;
000010  7823              LDRB     r3,[r4,#0]
;;;433        switch (transport) {
000012  b113              CBZ      r3,|L11.26|
000014  2b01              CMP      r3,#1
000016  d105              BNE      |L11.36|
000018  e000              B        |L11.28|
                  |L11.26|
;;;434          case 0U:
;;;435          case 1U:
00001a  bf00              NOP      
                  |L11.28|
;;;436    #if (SWO_STREAM != 0)
;;;437          case 2U:
;;;438    #endif
;;;439            TraceTransport = transport;
00001c  4809              LDR      r0,|L11.68|
00001e  7003              STRB     r3,[r0,#0]
;;;440            result = 1U;
000020  2101              MOVS     r1,#1
;;;441            break;
000022  e001              B        |L11.40|
                  |L11.36|
;;;442          default:
;;;443            result = 0U;
000024  2100              MOVS     r1,#0
;;;444            break;
000026  bf00              NOP      
                  |L11.40|
000028  e000              B        |L11.44|
                  |L11.42|
;;;445        }
;;;446      } else {
;;;447        result = 0U;
00002a  2100              MOVS     r1,#0
                  |L11.44|
;;;448      }
;;;449    
;;;450      if (result != 0U) {
00002c  b111              CBZ      r1,|L11.52|
;;;451        *response = DAP_OK;
00002e  2000              MOVS     r0,#0
000030  7010              STRB     r0,[r2,#0]
000032  e001              B        |L11.56|
                  |L11.52|
;;;452      } else {
;;;453        *response = DAP_ERROR;
000034  20ff              MOVS     r0,#0xff
000036  7010              STRB     r0,[r2,#0]
                  |L11.56|
;;;454      }
;;;455    
;;;456      return ((1U << 16) | 1U);
000038  f04f1001          MOV      r0,#0x10001
;;;457    }
00003c  bd10              POP      {r4,pc}
;;;458    
                          ENDP

00003e  0000              DCW      0x0000
                  |L11.64|
                          DCD      TraceStatus
                  |L11.68|
                          DCD      TraceTransport

                          AREA ||i.SetTraceError||, CODE, READONLY, ALIGN=2

                  SetTraceError PROC
;;;416    //   flag:  error flag(s) to set
;;;417    static void SetTraceError (uint8_t flag) {
000000  4904              LDR      r1,|L12.20|
;;;418      TraceError[TraceError_n] |= flag;
000002  4a05              LDR      r2,|L12.24|
000004  7812              LDRB     r2,[r2,#0]  ; TraceError_n
000006  5c89              LDRB     r1,[r1,r2]
000008  4301              ORRS     r1,r1,r0
00000a  4a02              LDR      r2,|L12.20|
00000c  4b02              LDR      r3,|L12.24|
00000e  781b              LDRB     r3,[r3,#0]  ; TraceError_n
000010  54d1              STRB     r1,[r2,r3]
;;;419    }
000012  4770              BX       lr
;;;420    
                          ENDP

                  |L12.20|
                          DCD      TraceError
                  |L12.24|
                          DCD      TraceError_n

                          AREA ||i.UART_SWO_Baudrate||, CODE, READONLY, ALIGN=2

                  UART_SWO_Baudrate PROC
;;;182    //   return:   actual baudrate or 0 when not configured
;;;183    __WEAK uint32_t UART_SWO_Baudrate (uint32_t baudrate) {
000000  b5f8              PUSH     {r3-r7,lr}
000002  4604              MOV      r4,r0
;;;184      int32_t  status;
;;;185      uint32_t index;
;;;186      uint32_t num;
;;;187    
;;;188      if (baudrate > SWO_UART_MAX_BAUDRATE) {
000004  4828              LDR      r0,|L13.168|
000006  4284              CMP      r4,r0
000008  d900              BLS      |L13.12|
;;;189        baudrate = SWO_UART_MAX_BAUDRATE;
00000a  4604              MOV      r4,r0
                  |L13.12|
;;;190      }
;;;191    
;;;192      if (TraceStatus & DAP_SWO_CAPTURE_ACTIVE) {
00000c  4827              LDR      r0,|L13.172|
00000e  7800              LDRB     r0,[r0,#0]  ; TraceStatus
000010  f0000001          AND      r0,r0,#1
000014  b1c0              CBZ      r0,|L13.72|
;;;193        pUSART->Control(ARM_USART_CONTROL_RX, 0U);
000016  4826              LDR      r0,|L13.176|
000018  2100              MOVS     r1,#0
00001a  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART1
00001c  2016              MOVS     r0,#0x16
00001e  4790              BLX      r2
;;;194        if (pUSART->GetStatus().rx_busy) {
000020  4923              LDR      r1,|L13.176|
000022  6ac8              LDR      r0,[r1,#0x2c]  ; Driver_USART1
000024  4780              BLX      r0
000026  9000              STR      r0,[sp,#0]
000028  f3c00040          UBFX     r0,r0,#1,#1
00002c  b160              CBZ      r0,|L13.72|
;;;195          TraceIndexI += pUSART->GetRxCount();
00002e  4920              LDR      r1,|L13.176|
000030  6a48              LDR      r0,[r1,#0x24]  ; Driver_USART1
000032  4780              BLX      r0
000034  491f              LDR      r1,|L13.180|
000036  6809              LDR      r1,[r1,#0]  ; TraceIndexI
000038  4408              ADD      r0,r0,r1
00003a  491e              LDR      r1,|L13.180|
00003c  6008              STR      r0,[r1,#0]  ; TraceIndexI
;;;196          pUSART->Control(ARM_USART_ABORT_RECEIVE, 0U);
00003e  481c              LDR      r0,|L13.176|
000040  2100              MOVS     r1,#0
000042  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART1
000044  2019              MOVS     r0,#0x19
000046  4790              BLX      r2
                  |L13.72|
;;;197        }
;;;198      }
;;;199    
;;;200      status = pUSART->Control(ARM_USART_MODE_ASYNCHRONOUS |
000048  4819              LDR      r0,|L13.176|
00004a  4621              MOV      r1,r4
00004c  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART1
00004e  2001              MOVS     r0,#1
000050  4790              BLX      r2
000052  4605              MOV      r5,r0
;;;201                               ARM_USART_DATA_BITS_8       |
;;;202                               ARM_USART_PARITY_NONE       |
;;;203                               ARM_USART_STOP_BITS_1,
;;;204                               baudrate);
;;;205    
;;;206      if (status == ARM_DRIVER_OK) {
000054  b91d              CBNZ     r5,|L13.94|
;;;207        USART_Ready = 1U;
000056  2001              MOVS     r0,#1
000058  4917              LDR      r1,|L13.184|
00005a  7008              STRB     r0,[r1,#0]
00005c  e003              B        |L13.102|
                  |L13.94|
;;;208      } else {
;;;209        USART_Ready = 0U;
00005e  2000              MOVS     r0,#0
000060  4915              LDR      r1,|L13.184|
000062  7008              STRB     r0,[r1,#0]
                  |L13.100|
;;;210        return (0U);
;;;211      }
;;;212    
;;;213      if (TraceStatus & DAP_SWO_CAPTURE_ACTIVE) {
;;;214        if ((TraceStatus & DAP_SWO_CAPTURE_PAUSED) == 0U) {
;;;215          index = TraceIndexI & (SWO_BUFFER_SIZE - 1U);
;;;216          num = TRACE_BLOCK_SIZE - (index & (TRACE_BLOCK_SIZE - 1U));
;;;217          TraceBlockSize = num;
;;;218          pUSART->Receive(&TraceBuf[index], num);
;;;219        }
;;;220        pUSART->Control(ARM_USART_CONTROL_RX, 1U);
;;;221      }
;;;222    
;;;223      return (baudrate);
;;;224    }
000064  bdf8              POP      {r3-r7,pc}
                  |L13.102|
000066  4811              LDR      r0,|L13.172|
000068  7800              LDRB     r0,[r0,#0]            ;213  ; TraceStatus
00006a  f0000001          AND      r0,r0,#1              ;213
00006e  b1c8              CBZ      r0,|L13.164|
000070  480e              LDR      r0,|L13.172|
000072  7800              LDRB     r0,[r0,#0]            ;214  ; TraceStatus
000074  f0000002          AND      r0,r0,#2              ;214
000078  b978              CBNZ     r0,|L13.154|
00007a  480e              LDR      r0,|L13.180|
00007c  6800              LDR      r0,[r0,#0]            ;215  ; TraceIndexI
00007e  f3c0060b          UBFX     r6,r0,#0,#12          ;215
000082  f006003f          AND      r0,r6,#0x3f           ;216
000086  f1c00740          RSB      r7,r0,#0x40           ;216
00008a  480c              LDR      r0,|L13.188|
00008c  6007              STR      r7,[r0,#0]            ;217  ; TraceBlockSize
00008e  490c              LDR      r1,|L13.192|
000090  1988              ADDS     r0,r1,r6              ;218
000092  4907              LDR      r1,|L13.176|
000094  698a              LDR      r2,[r1,#0x18]         ;218  ; Driver_USART1
000096  4639              MOV      r1,r7                 ;218
000098  4790              BLX      r2                    ;218
                  |L13.154|
00009a  4805              LDR      r0,|L13.176|
00009c  2101              MOVS     r1,#1                 ;220
00009e  6a82              LDR      r2,[r0,#0x28]         ;220  ; Driver_USART1
0000a0  2016              MOVS     r0,#0x16              ;220
0000a2  4790              BLX      r2                    ;220
                  |L13.164|
0000a4  4620              MOV      r0,r4                 ;223
0000a6  e7dd              B        |L13.100|
;;;225    
                          ENDP

                  |L13.168|
                          DCD      0x000f4240
                  |L13.172|
                          DCD      TraceStatus
                  |L13.176|
                          DCD      Driver_USART1
                  |L13.180|
                          DCD      TraceIndexI
                  |L13.184|
                          DCD      USART_Ready
                  |L13.188|
                          DCD      TraceBlockSize
                  |L13.192|
                          DCD      TraceBuf

                          AREA ||i.UART_SWO_Capture||, CODE, READONLY, ALIGN=2

                  UART_SWO_Capture PROC
;;;257    //   num: number of bytes to capture
;;;258    __WEAK void UART_SWO_Capture (uint8_t *buf, uint32_t num) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;259      TraceBlockSize = num;
000006  4804              LDR      r0,|L14.24|
000008  6004              STR      r4,[r0,#0]  ; TraceBlockSize
;;;260      pUSART->Receive(buf, num);
00000a  4804              LDR      r0,|L14.28|
00000c  4621              MOV      r1,r4
00000e  6982              LDR      r2,[r0,#0x18]  ; Driver_USART1
000010  4628              MOV      r0,r5
000012  4790              BLX      r2
;;;261    }
000014  bd70              POP      {r4-r6,pc}
;;;262    
                          ENDP

000016  0000              DCW      0x0000
                  |L14.24|
                          DCD      TraceBlockSize
                  |L14.28|
                          DCD      Driver_USART1

                          AREA ||i.UART_SWO_Control||, CODE, READONLY, ALIGN=2

                  UART_SWO_Control PROC
;;;228    //   return: 1 - Success, 0 - Error
;;;229    __WEAK uint32_t UART_SWO_Control (uint32_t active) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
;;;230      int32_t status;
;;;231    
;;;232      if (active) {
000004  b1cd              CBZ      r5,|L15.58|
;;;233        if (!USART_Ready) { 
000006  481a              LDR      r0,|L15.112|
000008  7800              LDRB     r0,[r0,#0]  ; USART_Ready
00000a  b908              CBNZ     r0,|L15.16|
;;;234          return (0U);
00000c  2000              MOVS     r0,#0
                  |L15.14|
;;;235        }
;;;236        TraceBlockSize = 1U;
;;;237        status = pUSART->Receive(&TraceBuf[0], 1U);
;;;238        if (status != ARM_DRIVER_OK) {
;;;239          return (0U);
;;;240        }
;;;241        status = pUSART->Control(ARM_USART_CONTROL_RX, 1U);
;;;242        if (status != ARM_DRIVER_OK) {
;;;243          return (0U);
;;;244        }
;;;245      } else {
;;;246        pUSART->Control(ARM_USART_CONTROL_RX, 0U);
;;;247        if (pUSART->GetStatus().rx_busy) {
;;;248          TraceIndexI += pUSART->GetRxCount();
;;;249          pUSART->Control(ARM_USART_ABORT_RECEIVE, 0U);
;;;250        }
;;;251      }
;;;252      return (1U);
;;;253    }
00000e  bd38              POP      {r3-r5,pc}
                  |L15.16|
000010  2001              MOVS     r0,#1                 ;236
000012  4918              LDR      r1,|L15.116|
000014  6008              STR      r0,[r1,#0]            ;236  ; TraceBlockSize
000016  4818              LDR      r0,|L15.120|
000018  2101              MOVS     r1,#1                 ;237
00001a  6982              LDR      r2,[r0,#0x18]         ;237  ; Driver_USART1
00001c  4817              LDR      r0,|L15.124|
00001e  4790              BLX      r2                    ;237
000020  4604              MOV      r4,r0                 ;237
000022  b10c              CBZ      r4,|L15.40|
000024  2000              MOVS     r0,#0                 ;239
000026  e7f2              B        |L15.14|
                  |L15.40|
000028  4813              LDR      r0,|L15.120|
00002a  2101              MOVS     r1,#1                 ;241
00002c  6a82              LDR      r2,[r0,#0x28]         ;241  ; Driver_USART1
00002e  2016              MOVS     r0,#0x16              ;241
000030  4790              BLX      r2                    ;241
000032  4604              MOV      r4,r0                 ;241
000034  b1d4              CBZ      r4,|L15.108|
000036  2000              MOVS     r0,#0                 ;243
000038  e7e9              B        |L15.14|
                  |L15.58|
00003a  480f              LDR      r0,|L15.120|
00003c  2100              MOVS     r1,#0                 ;246
00003e  6a82              LDR      r2,[r0,#0x28]         ;246  ; Driver_USART1
000040  2016              MOVS     r0,#0x16              ;246
000042  4790              BLX      r2                    ;246
000044  490c              LDR      r1,|L15.120|
000046  6ac8              LDR      r0,[r1,#0x2c]         ;247  ; Driver_USART1
000048  4780              BLX      r0                    ;247
00004a  9000              STR      r0,[sp,#0]            ;247
00004c  f3c00040          UBFX     r0,r0,#1,#1           ;247
000050  b160              CBZ      r0,|L15.108|
000052  4909              LDR      r1,|L15.120|
000054  6a48              LDR      r0,[r1,#0x24]         ;248  ; Driver_USART1
000056  4780              BLX      r0                    ;248
000058  4909              LDR      r1,|L15.128|
00005a  6809              LDR      r1,[r1,#0]            ;248  ; TraceIndexI
00005c  4408              ADD      r0,r0,r1              ;248
00005e  4908              LDR      r1,|L15.128|
000060  6008              STR      r0,[r1,#0]            ;248  ; TraceIndexI
000062  4805              LDR      r0,|L15.120|
000064  2100              MOVS     r1,#0                 ;249
000066  6a82              LDR      r2,[r0,#0x28]         ;249  ; Driver_USART1
000068  2019              MOVS     r0,#0x19              ;249
00006a  4790              BLX      r2                    ;249
                  |L15.108|
00006c  2001              MOVS     r0,#1                 ;252
00006e  e7ce              B        |L15.14|
;;;254    
                          ENDP

                  |L15.112|
                          DCD      USART_Ready
                  |L15.116|
                          DCD      TraceBlockSize
                  |L15.120|
                          DCD      Driver_USART1
                  |L15.124|
                          DCD      TraceBuf
                  |L15.128|
                          DCD      TraceIndexI

                          AREA ||i.UART_SWO_GetCount||, CODE, READONLY, ALIGN=2

                  UART_SWO_GetCount PROC
;;;264    //   return: number of pending trace data bytes
;;;265    __WEAK uint32_t UART_SWO_GetCount (void) {
000000  b538              PUSH     {r3-r5,lr}
;;;266      uint32_t count;
;;;267    
;;;268      if (pUSART->GetStatus().rx_busy) {
000002  4907              LDR      r1,|L16.32|
000004  6ac8              LDR      r0,[r1,#0x2c]  ; Driver_USART1
000006  4780              BLX      r0
000008  9000              STR      r0,[sp,#0]
00000a  f3c00040          UBFX     r0,r0,#1,#1
00000e  b120              CBZ      r0,|L16.26|
;;;269        count = pUSART->GetRxCount();
000010  4903              LDR      r1,|L16.32|
000012  6a48              LDR      r0,[r1,#0x24]  ; Driver_USART1
000014  4780              BLX      r0
000016  4604              MOV      r4,r0
000018  e000              B        |L16.28|
                  |L16.26|
;;;270      } else {
;;;271        count = 0U;
00001a  2400              MOVS     r4,#0
                  |L16.28|
;;;272      }
;;;273      return (count);
00001c  4620              MOV      r0,r4
;;;274    }
00001e  bd38              POP      {r3-r5,pc}
;;;275    
                          ENDP

                  |L16.32|
                          DCD      Driver_USART1

                          AREA ||i.UART_SWO_Mode||, CODE, READONLY, ALIGN=2

                  UART_SWO_Mode PROC
;;;155    //   return: 1 - Success, 0 - Error
;;;156    __WEAK uint32_t UART_SWO_Mode (uint32_t enable) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;157      int32_t status;
;;;158    
;;;159      USART_Ready = 0U;
000004  2000              MOVS     r0,#0
000006  4914              LDR      r1,|L17.88|
000008  7008              STRB     r0,[r1,#0]
;;;160    
;;;161      if (enable != 0U) {
00000a  b195              CBZ      r5,|L17.50|
;;;162        status = pUSART->Initialize(USART_Callback);
00000c  4813              LDR      r0,|L17.92|
00000e  6881              LDR      r1,[r0,#8]  ; Driver_USART1
000010  4813              LDR      r0,|L17.96|
000012  4788              BLX      r1
000014  4604              MOV      r4,r0
;;;163        if (status != ARM_DRIVER_OK) {
000016  b10c              CBZ      r4,|L17.28|
;;;164          return (0U);
000018  2000              MOVS     r0,#0
                  |L17.26|
;;;165        }
;;;166        status = pUSART->PowerControl(ARM_POWER_FULL);
;;;167        if (status != ARM_DRIVER_OK) {
;;;168          pUSART->Uninitialize();
;;;169          return (0U);
;;;170        }
;;;171      } else {
;;;172        pUSART->Control(ARM_USART_CONTROL_RX, 0U);
;;;173        pUSART->Control(ARM_USART_ABORT_RECEIVE, 0U);
;;;174        pUSART->PowerControl(ARM_POWER_OFF);
;;;175        pUSART->Uninitialize();
;;;176      }
;;;177      return (1U);
;;;178    }
00001a  bd70              POP      {r4-r6,pc}
                  |L17.28|
00001c  480f              LDR      r0,|L17.92|
00001e  6901              LDR      r1,[r0,#0x10]         ;166  ; Driver_USART1
000020  2002              MOVS     r0,#2                 ;166
000022  4788              BLX      r1                    ;166
000024  4604              MOV      r4,r0                 ;166
000026  b1ac              CBZ      r4,|L17.84|
000028  490c              LDR      r1,|L17.92|
00002a  68c8              LDR      r0,[r1,#0xc]          ;168  ; Driver_USART1
00002c  4780              BLX      r0                    ;168
00002e  2000              MOVS     r0,#0                 ;169
000030  e7f3              B        |L17.26|
                  |L17.50|
000032  480a              LDR      r0,|L17.92|
000034  2100              MOVS     r1,#0                 ;172
000036  6a82              LDR      r2,[r0,#0x28]         ;172  ; Driver_USART1
000038  2016              MOVS     r0,#0x16              ;172
00003a  4790              BLX      r2                    ;172
00003c  4807              LDR      r0,|L17.92|
00003e  2100              MOVS     r1,#0                 ;173
000040  6a82              LDR      r2,[r0,#0x28]         ;173  ; Driver_USART1
000042  2019              MOVS     r0,#0x19              ;173
000044  4790              BLX      r2                    ;173
000046  4805              LDR      r0,|L17.92|
000048  6901              LDR      r1,[r0,#0x10]         ;174  ; Driver_USART1
00004a  2000              MOVS     r0,#0                 ;174
00004c  4788              BLX      r1                    ;174
00004e  4903              LDR      r1,|L17.92|
000050  68c8              LDR      r0,[r1,#0xc]          ;175  ; Driver_USART1
000052  4780              BLX      r0                    ;175
                  |L17.84|
000054  2001              MOVS     r0,#1                 ;177
000056  e7e0              B        |L17.26|
;;;179    
                          ENDP

                  |L17.88|
                          DCD      USART_Ready
                  |L17.92|
                          DCD      Driver_USART1
                  |L17.96|
                          DCD      USART_Callback

                          AREA ||i.USART_Callback||, CODE, READONLY, ALIGN=2

                  USART_Callback PROC
;;;107    //   event: event mask
;;;108    static void USART_Callback (uint32_t event) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4605              MOV      r5,r0
;;;109      uint32_t index_i;
;;;110      uint32_t index_o;
;;;111      uint32_t count;
;;;112      uint32_t num;
;;;113    
;;;114      if (event &  ARM_USART_EVENT_RECEIVE_COMPLETE) {
000006  f0050002          AND      r0,r5,#2
00000a  b318              CBZ      r0,|L18.84|
;;;115    #if (TIMESTAMP_CLOCK != 0U) 
;;;116        TraceTimestamp.tick = TIMESTAMP_GET();
;;;117    #endif
;;;118        index_o  = TraceIndexO;
00000c  4818              LDR      r0,|L18.112|
00000e  6807              LDR      r7,[r0,#0]  ; TraceIndexO
;;;119        index_i  = TraceIndexI;
000010  4818              LDR      r0,|L18.116|
000012  6804              LDR      r4,[r0,#0]  ; TraceIndexI
;;;120        index_i += TraceBlockSize;
000014  4818              LDR      r0,|L18.120|
000016  6800              LDR      r0,[r0,#0]  ; TraceBlockSize
000018  4404              ADD      r4,r4,r0
;;;121        TraceIndexI = index_i;
00001a  4816              LDR      r0,|L18.116|
00001c  6004              STR      r4,[r0,#0]  ; TraceIndexI
;;;122    #if (TIMESTAMP_CLOCK != 0U) 
;;;123        TraceTimestamp.index = index_i;
;;;124    #endif
;;;125        num   = TRACE_BLOCK_SIZE - (index_i & (TRACE_BLOCK_SIZE - 1U));
00001e  f004003f          AND      r0,r4,#0x3f
000022  f1c00640          RSB      r6,r0,#0x40
;;;126        count = index_i - index_o;
000026  eba40807          SUB      r8,r4,r7
;;;127        if (count <= (SWO_BUFFER_SIZE - num)) {
00002a  f5c65080          RSB      r0,r6,#0x1000
00002e  4540              CMP      r0,r8
000030  d30a              BCC      |L18.72|
;;;128          index_i &= SWO_BUFFER_SIZE - 1U;
000032  f3c4040b          UBFX     r4,r4,#0,#12
;;;129          TraceBlockSize = num;
000036  4810              LDR      r0,|L18.120|
000038  6006              STR      r6,[r0,#0]  ; TraceBlockSize
;;;130          pUSART->Receive(&TraceBuf[index_i], num);
00003a  4910              LDR      r1,|L18.124|
00003c  1908              ADDS     r0,r1,r4
00003e  4910              LDR      r1,|L18.128|
000040  698a              LDR      r2,[r1,#0x18]  ; Driver_USART1
000042  4631              MOV      r1,r6
000044  4790              BLX      r2
000046  e002              B        |L18.78|
                  |L18.72|
;;;131        } else {
;;;132          TraceStatus = DAP_SWO_CAPTURE_ACTIVE | DAP_SWO_CAPTURE_PAUSED;
000048  2003              MOVS     r0,#3
00004a  490e              LDR      r1,|L18.132|
00004c  7008              STRB     r0,[r1,#0]
                  |L18.78|
;;;133        }
;;;134        TraceUpdate = 1U;
00004e  2001              MOVS     r0,#1
000050  490d              LDR      r1,|L18.136|
000052  7008              STRB     r0,[r1,#0]
                  |L18.84|
;;;135    #if (SWO_STREAM != 0)
;;;136        if (TraceTransport == 2U) {
;;;137          if (count >= (USB_BLOCK_SIZE - (index_o & (USB_BLOCK_SIZE - 1U)))) {
;;;138            osThreadFlagsSet(SWO_ThreadId, 1U);
;;;139          }
;;;140        }
;;;141    #endif
;;;142      }
;;;143      if (event &  ARM_USART_EVENT_RX_OVERFLOW) {
000054  f0050020          AND      r0,r5,#0x20
000058  b110              CBZ      r0,|L18.96|
;;;144        SetTraceError(DAP_SWO_BUFFER_OVERRUN);
00005a  2080              MOVS     r0,#0x80
00005c  f7fffffe          BL       SetTraceError
                  |L18.96|
;;;145      }
;;;146      if (event & (ARM_USART_EVENT_RX_BREAK         |
000060  f4057060          AND      r0,r5,#0x380
000064  b110              CBZ      r0,|L18.108|
;;;147                   ARM_USART_EVENT_RX_FRAMING_ERROR |
;;;148                   ARM_USART_EVENT_RX_PARITY_ERROR)) {
;;;149        SetTraceError(DAP_SWO_STREAM_ERROR);
000066  2040              MOVS     r0,#0x40
000068  f7fffffe          BL       SetTraceError
                  |L18.108|
;;;150      }
;;;151    }
00006c  e8bd81f0          POP      {r4-r8,pc}
;;;152    
                          ENDP

                  |L18.112|
                          DCD      TraceIndexO
                  |L18.116|
                          DCD      TraceIndexI
                  |L18.120|
                          DCD      TraceBlockSize
                  |L18.124|
                          DCD      TraceBuf
                  |L18.128|
                          DCD      Driver_USART1
                  |L18.132|
                          DCD      TraceStatus
                  |L18.136|
                          DCD      TraceUpdate

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  TraceBuf
                          %        4096

                          AREA ||.data||, DATA, ALIGN=2

                  USART_Ready
000000  00                DCB      0x00
                  TraceTransport
000001  00                DCB      0x00
                  TraceMode
000002  00                DCB      0x00
                  TraceStatus
000003  00                DCB      0x00
                  TraceError
000004  0000              DCB      0x00,0x00
                  TraceError_n
000006  0000              DCB      0x00,0x00
                  TraceIndexI
                          DCD      0x00000000
                  TraceIndexO
                          DCD      0x00000000
                  TraceUpdate
000010  00000000          DCB      0x00,0x00,0x00,0x00
                  TraceBlockSize
                          DCD      0x00000000

;*** Start embedded assembler ***

#line 1 "CMSIS-DAP\\SWO.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___5_SWO_c_fc2b2971____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___5_SWO_c_fc2b2971____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___5_SWO_c_fc2b2971____REVSH|
#line 507
|__asm___5_SWO_c_fc2b2971____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___5_SWO_c_fc2b2971____RRX|
#line 694
|__asm___5_SWO_c_fc2b2971____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
