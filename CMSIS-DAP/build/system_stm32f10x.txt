; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\system_stm32f10x.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\system_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\system_stm32f10x.crf User\system_stm32f10x.c]
                          THUMB

                          AREA ||i.SetSysClock||, CODE, READONLY, ALIGN=1

                  SetSysClock PROC
;;;392      */
;;;393    static void SetSysClock(void)
000000  b510              PUSH     {r4,lr}
;;;394    {
;;;395    #ifdef SYSCLK_FREQ_HSE
;;;396    	SetSysClockToHSE();
;;;397    #elif defined SYSCLK_FREQ_24MHz
;;;398    	SetSysClockTo24();
;;;399    #elif defined SYSCLK_FREQ_36MHz
;;;400    	SetSysClockTo36();
;;;401    #elif defined SYSCLK_FREQ_48MHz
;;;402    	SetSysClockTo48();
;;;403    #elif defined SYSCLK_FREQ_56MHz
;;;404    	SetSysClockTo56();  
;;;405    #elif defined SYSCLK_FREQ_72MHz
;;;406    	SetSysClockTo72();
000002  f7fffffe          BL       SetSysClockTo72
;;;407    #endif
;;;408     
;;;409     /* If none of the define above is enabled, the HSI is used as System clock
;;;410        source (default after reset) */ 
;;;411    }
000006  bd10              POP      {r4,pc}
;;;412    
                          ENDP


                          AREA ||i.SetSysClockTo72||, CODE, READONLY, ALIGN=2

                  SetSysClockTo72 PROC
;;;960      */
;;;961    static void SetSysClockTo72(void)
000000  b508              PUSH     {r3,lr}
;;;962    {
;;;963    	__IO uint32_t StartUpCounter = 0;
000002  2000              MOVS     r0,#0
000004  9000              STR      r0,[sp,#0]
;;;964    
;;;965    	// SYSCLK, HCLK, PCLK2 and PCLK1 configuration
;;;966    	// Enable HSE
;;;967    	RCC->CR |= RCC_CR_HSEON;
000006  4837              LDR      r0,|L2.228|
000008  6800              LDR      r0,[r0,#0]
00000a  f4403080          ORR      r0,r0,#0x10000
00000e  4935              LDR      r1,|L2.228|
000010  6008              STR      r0,[r1,#0]
;;;968    
;;;969    	// Wait till HSE is ready and if Time out is reached exit
;;;970    	while (((RCC->CR & RCC_CR_HSERDY) == RESET) && (StartUpCounter != HSE_STARTUP_TIMEOUT))
000012  bf00              NOP      
                  |L2.20|
000014  4833              LDR      r0,|L2.228|
000016  6800              LDR      r0,[r0,#0]
000018  f4003000          AND      r0,r0,#0x20000
00001c  b918              CBNZ     r0,|L2.38|
00001e  9800              LDR      r0,[sp,#0]
000020  f5b06fa0          CMP      r0,#0x500
000024  d1f6              BNE      |L2.20|
                  |L2.38|
;;;971    	{ }
;;;972    
;;;973    	if ((RCC->CR & RCC_CR_HSERDY) == RESET)
000026  482f              LDR      r0,|L2.228|
000028  6800              LDR      r0,[r0,#0]
00002a  f4003000          AND      r0,r0,#0x20000
00002e  b940              CBNZ     r0,|L2.66|
;;;974    	{	// HSE not start, disable it
;;;975    		RCC->CR &= ~RCC_CR_HSEON;
000030  482c              LDR      r0,|L2.228|
000032  6800              LDR      r0,[r0,#0]
000034  f4203080          BIC      r0,r0,#0x10000
000038  492a              LDR      r1,|L2.228|
00003a  6008              STR      r0,[r1,#0]
;;;976    		StartUpCounter = 1;
00003c  2001              MOVS     r0,#1
00003e  9000              STR      r0,[sp,#0]
000040  e001              B        |L2.70|
                  |L2.66|
;;;977    	}
;;;978    	else
;;;979    		StartUpCounter = 0;
000042  2000              MOVS     r0,#0
000044  9000              STR      r0,[sp,#0]
                  |L2.70|
;;;980    
;;;981    	/* Enable Prefetch Buffer */
;;;982    	FLASH->ACR |= FLASH_ACR_PRFTBE;
000046  4828              LDR      r0,|L2.232|
000048  6800              LDR      r0,[r0,#0]
00004a  f0400010          ORR      r0,r0,#0x10
00004e  4926              LDR      r1,|L2.232|
000050  6008              STR      r0,[r1,#0]
;;;983    
;;;984    	/* Flash 2 wait state */
;;;985    	FLASH->ACR &= ~((uint32_t)FLASH_ACR_LATENCY);
000052  4608              MOV      r0,r1
000054  6800              LDR      r0,[r0,#0]
000056  f0200003          BIC      r0,r0,#3
00005a  6008              STR      r0,[r1,#0]
;;;986    	FLASH->ACR |=  (uint32_t)FLASH_ACR_LATENCY_2;    
00005c  4608              MOV      r0,r1
00005e  6800              LDR      r0,[r0,#0]
000060  f0400002          ORR      r0,r0,#2
000064  6008              STR      r0,[r1,#0]
;;;987    
;;;988    	/* HCLK = SYSCLK */
;;;989    	RCC->CFGR |= RCC_CFGR_HPRE_DIV1;
000066  481f              LDR      r0,|L2.228|
000068  6840              LDR      r0,[r0,#4]
00006a  491e              LDR      r1,|L2.228|
00006c  6048              STR      r0,[r1,#4]
;;;990    
;;;991    	/* PCLK2 = HCLK */
;;;992    	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1;
00006e  4608              MOV      r0,r1
000070  6840              LDR      r0,[r0,#4]
000072  6048              STR      r0,[r1,#4]
;;;993    
;;;994    	/* PCLK1 = HCLK */
;;;995    	RCC->CFGR |= RCC_CFGR_PPRE1_DIV2;
000074  4608              MOV      r0,r1
000076  6840              LDR      r0,[r0,#4]
000078  f4406080          ORR      r0,r0,#0x400
00007c  6048              STR      r0,[r1,#4]
;;;996    
;;;997    	#ifdef STM32F10X_CL
;;;998    		/* Configure PLLs ------------------------------------------------------*/
;;;999    		/* PLL2 configuration: PLL2CLK = (HSE / 5) * 8 = 40 MHz */
;;;1000   		/* PREDIV1 configuration: PREDIV1CLK = PLL2 / 5 = 8 MHz */
;;;1001   
;;;1002   		RCC->CFGR2 &= (uint32_t)~(RCC_CFGR2_PREDIV2 | RCC_CFGR2_PLL2MUL |
;;;1003   		RCC_CFGR2_PREDIV1 | RCC_CFGR2_PREDIV1SRC);
;;;1004   		RCC->CFGR2 |= (uint32_t)(RCC_CFGR2_PREDIV2_DIV5 | RCC_CFGR2_PLL2MUL8 |
;;;1005   		RCC_CFGR2_PREDIV1SRC_PLL2 | RCC_CFGR2_PREDIV1_DIV5);
;;;1006   
;;;1007   		/* Enable PLL2 */
;;;1008   		RCC->CR |= RCC_CR_PLL2ON;
;;;1009   		/* Wait till PLL2 is ready */
;;;1010   		while((RCC->CR & RCC_CR_PLL2RDY) == 0)
;;;1011   		{ }
;;;1012   
;;;1013   		/* PLL configuration: PLLCLK = PREDIV1 * 9 = 72 MHz */ 
;;;1014   		RCC->CFGR &= (uint32_t)~(RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLSRC | RCC_CFGR_PLLMULL);
;;;1015   		RCC->CFGR |= (uint32_t)(RCC_CFGR_PLLXTPRE_PREDIV1 | RCC_CFGR_PLLSRC_PREDIV1 | RCC_CFGR_PLLMULL9);
;;;1016   	#else    
;;;1017   		/*  PLL configuration: PLLCLK = HSE * 9 = 72 MHz */
;;;1018   		RCC->CFGR &= ~(RCC_CFGR_PLLSRC | RCC_CFGR_PLLXTPRE | RCC_CFGR_PLLMULL);
00007e  4608              MOV      r0,r1
000080  6840              LDR      r0,[r0,#4]
000082  f420107c          BIC      r0,r0,#0x3f0000
000086  6048              STR      r0,[r1,#4]
;;;1019   		if (StartUpCounter)
000088  9800              LDR      r0,[sp,#0]
00008a  b128              CBZ      r0,|L2.152|
;;;1020   		{
;;;1021   			RCC->CFGR |= (RCC_CFGR_PLLMULL12 | RCC_CFGR_USBPRE);
00008c  4608              MOV      r0,r1
00008e  6840              LDR      r0,[r0,#4]
000090  f44000d0          ORR      r0,r0,#0x680000
000094  6048              STR      r0,[r1,#4]
000096  e005              B        |L2.164|
                  |L2.152|
;;;1022   		}
;;;1023   		else
;;;1024   		{
;;;1025   			RCC->CFGR |= (RCC_CFGR_PLLSRC_HSE | RCC_CFGR_PLLMULL9);
000098  4812              LDR      r0,|L2.228|
00009a  6840              LDR      r0,[r0,#4]
00009c  f44010e8          ORR      r0,r0,#0x1d0000
0000a0  4910              LDR      r1,|L2.228|
0000a2  6048              STR      r0,[r1,#4]
                  |L2.164|
;;;1026   		}
;;;1027   	#endif /* STM32F10X_CL */
;;;1028   
;;;1029   	/* Enable PLL */
;;;1030   	RCC->CR |= RCC_CR_PLLON;
0000a4  480f              LDR      r0,|L2.228|
0000a6  6800              LDR      r0,[r0,#0]
0000a8  f0407080          ORR      r0,r0,#0x1000000
0000ac  490d              LDR      r1,|L2.228|
0000ae  6008              STR      r0,[r1,#0]
;;;1031   
;;;1032   	/* Wait till PLL is ready */
;;;1033   	while((RCC->CR & RCC_CR_PLLRDY) == 0)
0000b0  bf00              NOP      
                  |L2.178|
0000b2  480c              LDR      r0,|L2.228|
0000b4  6800              LDR      r0,[r0,#0]
0000b6  f0007000          AND      r0,r0,#0x2000000
0000ba  2800              CMP      r0,#0
0000bc  d0f9              BEQ      |L2.178|
;;;1034   	{ }
;;;1035   
;;;1036   	/* Select PLL as system clock source */
;;;1037   	RCC->CFGR &= ~RCC_CFGR_SW;
0000be  4809              LDR      r0,|L2.228|
0000c0  6840              LDR      r0,[r0,#4]
0000c2  f0200003          BIC      r0,r0,#3
0000c6  4907              LDR      r1,|L2.228|
0000c8  6048              STR      r0,[r1,#4]
;;;1038   	RCC->CFGR |=  RCC_CFGR_SW_PLL;
0000ca  4608              MOV      r0,r1
0000cc  6840              LDR      r0,[r0,#4]
0000ce  f0400002          ORR      r0,r0,#2
0000d2  6048              STR      r0,[r1,#4]
;;;1039   
;;;1040   	/* Wait till PLL is used as system clock source */
;;;1041   	while ((RCC->CFGR & (uint32_t)RCC_CFGR_SWS) != (uint32_t)0x08)
0000d4  bf00              NOP      
                  |L2.214|
0000d6  4803              LDR      r0,|L2.228|
0000d8  6840              LDR      r0,[r0,#4]
0000da  f000000c          AND      r0,r0,#0xc
0000de  2808              CMP      r0,#8
0000e0  d1f9              BNE      |L2.214|
;;;1042   	{ }
;;;1043   }
0000e2  bd08              POP      {r3,pc}
;;;1044   #endif
                          ENDP

                  |L2.228|
                          DCD      0x40021000
                  |L2.232|
                          DCD      0x40022000

                          AREA ||i.SystemCoreClockUpdate||, CODE, READONLY, ALIGN=2

                  SystemCoreClockUpdate PROC
;;;279      */
;;;280    void SystemCoreClockUpdate (void)
000000  b510              PUSH     {r4,lr}
;;;281    {
;;;282    	uint32_t tmp = 0, pllmull = 0, pllsource = 0;
000002  2100              MOVS     r1,#0
000004  2000              MOVS     r0,#0
000006  2200              MOVS     r2,#0
;;;283    
;;;284    #ifdef  STM32F10X_CL
;;;285    	uint32_t prediv1source = 0, prediv1factor = 0, prediv2factor = 0, pll2mull = 0;
;;;286    #endif /* STM32F10X_CL */
;;;287    
;;;288    #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;289    	uint32_t prediv1factor = 0;
;;;290    #endif /* STM32F10X_LD_VL or STM32F10X_MD_VL or STM32F10X_HD_VL */
;;;291        
;;;292    	/* Get SYSCLK source -------------------------------------------------------*/
;;;293    	tmp = RCC->CFGR & RCC_CFGR_SWS;
000008  4b21              LDR      r3,|L3.144|
00000a  685b              LDR      r3,[r3,#4]
00000c  f003010c          AND      r1,r3,#0xc
;;;294      
;;;295    	switch (tmp)
000010  b121              CBZ      r1,|L3.28|
000012  2904              CMP      r1,#4
000014  d006              BEQ      |L3.36|
000016  2908              CMP      r1,#8
000018  d128              BNE      |L3.108|
00001a  e007              B        |L3.44|
                  |L3.28|
;;;296    	{
;;;297    	case 0x00:  /* HSI used as system clock */
;;;298    		SystemCoreClock = HSI_VALUE;
00001c  4b1d              LDR      r3,|L3.148|
00001e  4c1e              LDR      r4,|L3.152|
000020  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;299    		break;
000022  e027              B        |L3.116|
                  |L3.36|
;;;300    	case 0x04:  /* HSE used as system clock */
;;;301    		SystemCoreClock = HSE_VALUE;
000024  4b1b              LDR      r3,|L3.148|
000026  4c1c              LDR      r4,|L3.152|
000028  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;302    		break;
00002a  e023              B        |L3.116|
                  |L3.44|
;;;303    	case 0x08:  /* PLL used as system clock */
;;;304    
;;;305    		/* Get PLL clock source and multiplication factor ----------------------*/
;;;306    		pllmull = RCC->CFGR & RCC_CFGR_PLLMULL;
00002c  4b18              LDR      r3,|L3.144|
00002e  685b              LDR      r3,[r3,#4]
000030  f4031070          AND      r0,r3,#0x3c0000
;;;307    		pllsource = RCC->CFGR & RCC_CFGR_PLLSRC;
000034  4b16              LDR      r3,|L3.144|
000036  685b              LDR      r3,[r3,#4]
000038  f4033280          AND      r2,r3,#0x10000
;;;308          
;;;309    #ifndef STM32F10X_CL      
;;;310    		pllmull = ( pllmull >> 18) + 2;
00003c  2302              MOVS     r3,#2
00003e  eb034090          ADD      r0,r3,r0,LSR #18
;;;311          
;;;312    		if (pllsource == 0x00)
000042  b922              CBNZ     r2,|L3.78|
;;;313    		{
;;;314    			/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;315    			SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
000044  4b15              LDR      r3,|L3.156|
000046  4343              MULS     r3,r0,r3
000048  4c13              LDR      r4,|L3.152|
00004a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
00004c  e00d              B        |L3.106|
                  |L3.78|
;;;316    		}
;;;317    		else
;;;318    		{
;;;319     #if defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;320    			prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;321    			/* HSE oscillator clock selected as PREDIV1 clock entry */
;;;322    			SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull; 
;;;323     #else
;;;324    			/* HSE selected as PLL clock entry */
;;;325    			if ((RCC->CFGR & RCC_CFGR_PLLXTPRE) != (uint32_t)RESET)
00004e  4b10              LDR      r3,|L3.144|
000050  685b              LDR      r3,[r3,#4]
000052  f4033300          AND      r3,r3,#0x20000
000056  b123              CBZ      r3,|L3.98|
;;;326    			{	/* HSE oscillator clock divided by 2 */
;;;327    				SystemCoreClock = (HSE_VALUE >> 1) * pllmull;
000058  4b10              LDR      r3,|L3.156|
00005a  4343              MULS     r3,r0,r3
00005c  4c0e              LDR      r4,|L3.152|
00005e  6023              STR      r3,[r4,#0]  ; SystemCoreClock
000060  e003              B        |L3.106|
                  |L3.98|
;;;328    			}
;;;329    			else
;;;330    			{
;;;331    				SystemCoreClock = HSE_VALUE * pllmull;
000062  4b0c              LDR      r3,|L3.148|
000064  4343              MULS     r3,r0,r3
000066  4c0c              LDR      r4,|L3.152|
000068  6023              STR      r3,[r4,#0]  ; SystemCoreClock
                  |L3.106|
;;;332    			}
;;;333     #endif
;;;334    		}
;;;335    #else
;;;336    		pllmull = pllmull >> 18;
;;;337    
;;;338    		if (pllmull != 0x0D)
;;;339    		{
;;;340    			pllmull += 2;
;;;341    		}
;;;342    		else
;;;343    		{	/* PLL multiplication factor = PLL input clock * 6.5 */
;;;344    			pllmull = 13 / 2; 
;;;345    		}
;;;346    
;;;347    		if (pllsource == 0x00)
;;;348    		{
;;;349    			/* HSI oscillator clock divided by 2 selected as PLL clock entry */
;;;350    			SystemCoreClock = (HSI_VALUE >> 1) * pllmull;
;;;351    		}
;;;352    		else
;;;353    		{	/* PREDIV1 selected as PLL clock entry */
;;;354    
;;;355    			/* Get PREDIV1 clock source and division factor */
;;;356    			prediv1source = RCC->CFGR2 & RCC_CFGR2_PREDIV1SRC;
;;;357    			prediv1factor = (RCC->CFGR2 & RCC_CFGR2_PREDIV1) + 1;
;;;358            
;;;359    			if (prediv1source == 0)
;;;360    			{ 
;;;361    				/* HSE oscillator clock selected as PREDIV1 clock entry */
;;;362    				SystemCoreClock = (HSE_VALUE / prediv1factor) * pllmull;          
;;;363    			}
;;;364    			else
;;;365    			{	/* PLL2 clock selected as PREDIV1 clock entry */
;;;366    
;;;367    				/* Get PREDIV2 division factor and PLL2 multiplication factor */
;;;368    				prediv2factor = ((RCC->CFGR2 & RCC_CFGR2_PREDIV2) >> 4) + 1;
;;;369    				pll2mull = ((RCC->CFGR2 & RCC_CFGR2_PLL2MUL) >> 8 ) + 2; 
;;;370    				SystemCoreClock = (((HSE_VALUE / prediv2factor) * pll2mull) / prediv1factor) * pllmull;                         
;;;371    			}
;;;372    		}
;;;373    #endif /* STM32F10X_CL */ 
;;;374    		break;
00006a  e003              B        |L3.116|
                  |L3.108|
;;;375    
;;;376    	default:
;;;377    		SystemCoreClock = HSI_VALUE;
00006c  4b09              LDR      r3,|L3.148|
00006e  4c0a              LDR      r4,|L3.152|
000070  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;378    		break;
000072  bf00              NOP      
                  |L3.116|
000074  bf00              NOP                            ;299
;;;379    	}
;;;380    
;;;381    	/* Compute HCLK clock frequency ----------------*/
;;;382    	/* Get HCLK prescaler */
;;;383    	tmp = AHBPrescTable[((RCC->CFGR & RCC_CFGR_HPRE) >> 4)];
000076  4b06              LDR      r3,|L3.144|
000078  685b              LDR      r3,[r3,#4]
00007a  f3c31303          UBFX     r3,r3,#4,#4
00007e  4c08              LDR      r4,|L3.160|
000080  5ce1              LDRB     r1,[r4,r3]
;;;384    	/* HCLK clock frequency */
;;;385    	SystemCoreClock >>= tmp;  
000082  4b05              LDR      r3,|L3.152|
000084  681b              LDR      r3,[r3,#0]  ; SystemCoreClock
000086  40cb              LSRS     r3,r3,r1
000088  4c03              LDR      r4,|L3.152|
00008a  6023              STR      r3,[r4,#0]  ; SystemCoreClock
;;;386    }
00008c  bd10              POP      {r4,pc}
;;;387    
                          ENDP

00008e  0000              DCW      0x0000
                  |L3.144|
                          DCD      0x40021000
                  |L3.148|
                          DCD      0x007a1200
                  |L3.152|
                          DCD      SystemCoreClock
                  |L3.156|
                          DCD      0x003d0900
                  |L3.160|
                          DCD      AHBPrescTable

                          AREA ||i.SystemInit||, CODE, READONLY, ALIGN=2

                  SystemInit PROC
;;;185      */
;;;186    void SystemInit (void)
000000  b510              PUSH     {r4,lr}
;;;187    {
;;;188    	/* Reset the RCC clock configuration to the default reset state(for debug purpose) */
;;;189    	/* Set HSION bit */
;;;190    	RCC->CR |= (uint32_t)0x00000001;
000002  4813              LDR      r0,|L4.80|
000004  6800              LDR      r0,[r0,#0]
000006  f0400001          ORR      r0,r0,#1
00000a  4911              LDR      r1,|L4.80|
00000c  6008              STR      r0,[r1,#0]
;;;191    
;;;192    	/* Reset SW, HPRE, PPRE1, PPRE2, ADCPRE and MCO bits */
;;;193    #ifndef STM32F10X_CL
;;;194    	RCC->CFGR &= (uint32_t)0xF8FF0000;
00000e  4608              MOV      r0,r1
000010  6840              LDR      r0,[r0,#4]
000012  4910              LDR      r1,|L4.84|
000014  4008              ANDS     r0,r0,r1
000016  490e              LDR      r1,|L4.80|
000018  6048              STR      r0,[r1,#4]
;;;195    #else
;;;196    	RCC->CFGR &= (uint32_t)0xF0FF0000;
;;;197    #endif /* STM32F10X_CL */   
;;;198    
;;;199    	/* Reset HSEON, CSSON and PLLON bits */
;;;200    	RCC->CR &= (uint32_t)0xFEF6FFFF;
00001a  4608              MOV      r0,r1
00001c  6800              LDR      r0,[r0,#0]
00001e  490e              LDR      r1,|L4.88|
000020  4008              ANDS     r0,r0,r1
000022  490b              LDR      r1,|L4.80|
000024  6008              STR      r0,[r1,#0]
;;;201    
;;;202    	/* Reset HSEBYP bit */
;;;203    	RCC->CR &= (uint32_t)0xFFFBFFFF;
000026  4608              MOV      r0,r1
000028  6800              LDR      r0,[r0,#0]
00002a  f4202080          BIC      r0,r0,#0x40000
00002e  6008              STR      r0,[r1,#0]
;;;204    
;;;205    	/* Reset PLLSRC, PLLXTPRE, PLLMUL and USBPRE/OTGFSPRE bits */
;;;206    	RCC->CFGR &= (uint32_t)0xFF80FFFF;
000030  4608              MOV      r0,r1
000032  6840              LDR      r0,[r0,#4]
000034  f42000fe          BIC      r0,r0,#0x7f0000
000038  6048              STR      r0,[r1,#4]
;;;207    
;;;208    #ifdef STM32F10X_CL
;;;209    	/* Reset PLL2ON and PLL3ON bits */
;;;210    	RCC->CR &= (uint32_t)0xEBFFFFFF;
;;;211    
;;;212    	/* Disable all interrupts and clear pending bits  */
;;;213    	RCC->CIR = 0x00FF0000;
;;;214    
;;;215    	/* Reset CFGR2 register */
;;;216    	RCC->CFGR2 = 0x00000000;
;;;217    #elif defined (STM32F10X_LD_VL) || defined (STM32F10X_MD_VL) || (defined STM32F10X_HD_VL)
;;;218    	/* Disable all interrupts and clear pending bits  */
;;;219    	RCC->CIR = 0x009F0000;
;;;220    
;;;221    	/* Reset CFGR2 register */
;;;222    	RCC->CFGR2 = 0x00000000;      
;;;223    #else
;;;224    	/* Disable all interrupts and clear pending bits  */
;;;225    	RCC->CIR = 0x009F0000;
00003a  f44f001f          MOV      r0,#0x9f0000
00003e  6088              STR      r0,[r1,#8]
;;;226    #endif /* STM32F10X_CL */
;;;227    
;;;228    #if defined (STM32F10X_HD) || (defined STM32F10X_XL) || (defined STM32F10X_HD_VL)
;;;229    	#ifdef DATA_IN_ExtSRAM
;;;230    	SystemInit_ExtMemCtl(); 
;;;231    	#endif /* DATA_IN_ExtSRAM */
;;;232    #endif 
;;;233    
;;;234    	/* Configure the System clock frequency, HCLK, PCLK2 and PCLK1 prescalers */
;;;235    	/* Configure the Flash Latency cycles and enable prefetch buffer */
;;;236    	SetSysClock();
000040  f7fffffe          BL       SetSysClock
;;;237    
;;;238    #ifdef VECT_TAB_SRAM
;;;239    	SCB->VTOR = SRAM_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal SRAM. */
;;;240    #else
;;;241    	SCB->VTOR = FLASH_BASE | VECT_TAB_OFFSET; /* Vector Table Relocation in Internal FLASH. */
000044  f04f6000          MOV      r0,#0x8000000
000048  4904              LDR      r1,|L4.92|
00004a  6008              STR      r0,[r1,#0]
;;;242    #endif 
;;;243    }
00004c  bd10              POP      {r4,pc}
;;;244    
                          ENDP

00004e  0000              DCW      0x0000
                  |L4.80|
                          DCD      0x40021000
                  |L4.84|
                          DCD      0xf8ff0000
                  |L4.88|
                          DCD      0xfef6ffff
                  |L4.92|
                          DCD      0xe000ed08

                          AREA ||.data||, DATA, ALIGN=2

                  SystemCoreClock
                          DCD      0x044aa200
                  AHBPrescTable
000004  00000000          DCB      0x00,0x00,0x00,0x00
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  01020304          DCB      0x01,0x02,0x03,0x04
000010  06070809          DCB      0x06,0x07,0x08,0x09

;*** Start embedded assembler ***

#line 1 "User\\system_stm32f10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___18_system_stm32f10x_c_5d646a67____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____REVSH|
#line 507
|__asm___18_system_stm32f10x_c_5d646a67____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___18_system_stm32f10x_c_5d646a67____RRX|
#line 694
|__asm___18_system_stm32f10x_c_5d646a67____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
