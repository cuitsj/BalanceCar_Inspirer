; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\usart_stm32f10x.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\usart_stm32f10x.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\usart_stm32f10x.crf Driver\STM32F10x_ARM_Driver\USART_STM32F10x.c]
                          THUMB

                          AREA ||i.DMA1_Channel4_Event||, CODE, READONLY, ALIGN=2

                  DMA1_Channel4_Event PROC
;;;2150   #ifdef MX_USART1_TX_DMA_Instance
;;;2151          void                    USART1_TX_DMA_Handler  (uint32_t events)                                     {        USART_TX_DMA_Complete(&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4801              LDR      r0,|L1.12|
000006  f7fffffe          BL       USART_TX_DMA_Complete
00000a  bd10              POP      {r4,pc}
;;;2152   #endif
                          ENDP

                  |L1.12|
                          DCD      USART1_Resources

                          AREA ||i.DMA1_Channel5_Event||, CODE, READONLY, ALIGN=2

                  DMA1_Channel5_Event PROC
;;;2153   #ifdef MX_USART1_RX_DMA_Instance
;;;2154          void                    USART1_RX_DMA_Handler  (uint32_t events)                                     {        USART_RX_DMA_Complete(&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4801              LDR      r0,|L2.12|
000006  f7fffffe          BL       USART_RX_DMA_Complete
00000a  bd10              POP      {r4,pc}
;;;2155   #endif
                          ENDP

                  |L2.12|
                          DCD      USART1_Resources

                          AREA ||i.DMA1_Channel6_Event||, CODE, READONLY, ALIGN=2

                  DMA1_Channel6_Event PROC
;;;2196   #ifdef MX_USART2_RX_DMA_Instance
;;;2197          void                    USART2_RX_DMA_Handler  (uint32_t events)                                     {        USART_RX_DMA_Complete(&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4801              LDR      r0,|L3.12|
000006  f7fffffe          BL       USART_RX_DMA_Complete
00000a  bd10              POP      {r4,pc}
;;;2198   #endif
                          ENDP

                  |L3.12|
                          DCD      USART2_Resources

                          AREA ||i.DMA1_Channel7_Event||, CODE, READONLY, ALIGN=2

                  DMA1_Channel7_Event PROC
;;;2193   #ifdef MX_USART2_TX_DMA_Instance
;;;2194          void                    USART2_TX_DMA_Handler  (uint32_t events)                                     {        USART_TX_DMA_Complete(&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4801              LDR      r0,|L4.12|
000006  f7fffffe          BL       USART_TX_DMA_Complete
00000a  bd10              POP      {r4,pc}
;;;2195   #endif
                          ENDP

                  |L4.12|
                          DCD      USART2_Resources

                          AREA ||i.USART1_Control||, CODE, READONLY, ALIGN=2

                  USART1_Control PROC
;;;2143   static uint32_t                USART1_GetRxCount      (void)                                                { return USART_GetRxCount (&USART1_Resources); }
;;;2144   static int32_t                 USART1_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L5.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Control
000010  bd70              POP      {r4-r6,pc}
;;;2145   static ARM_USART_STATUS        USART1_GetStatus       (void)                                                { return USART_GetStatus (&USART1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L5.20|
                          DCD      USART1_Resources

                          AREA ||i.USART1_GetCapabilities||, CODE, READONLY, ALIGN=2

                  USART1_GetCapabilities PROC
;;;2134   // USART1 Driver Wrapper functions
;;;2135   static ARM_USART_CAPABILITIES  USART1_GetCapabilities (void)                                                { return USART_GetCapabilities (&USART1_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L6.12|
000004  f7fffffe          BL       USART_GetCapabilities
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2136   static int32_t                 USART1_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART1_Resources); }
                          ENDP

                  |L6.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_GetModemStatus||, CODE, READONLY, ALIGN=2

                  USART1_GetModemStatus PROC
;;;2146   static int32_t                 USART1_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART1_Resources); }
;;;2147   static ARM_USART_MODEM_STATUS  USART1_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART1_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L7.12|
000004  f7fffffe          BL       USART_GetModemStatus
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2148          void                    USART1_IRQHandler      (void)                                                {        USART_IRQHandler (&USART1_Resources); }
                          ENDP

                  |L7.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_GetRxCount||, CODE, READONLY, ALIGN=2

                  USART1_GetRxCount PROC
;;;2142   static uint32_t                USART1_GetTxCount      (void)                                                { return USART_GetTxCount (&USART1_Resources); }
;;;2143   static uint32_t                USART1_GetRxCount      (void)                                                { return USART_GetRxCount (&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L8.12|
000004  f7fffffe          BL       USART_GetRxCount
000008  bd10              POP      {r4,pc}
;;;2144   static int32_t                 USART1_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART1_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L8.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_GetStatus||, CODE, READONLY, ALIGN=2

                  USART1_GetStatus PROC
;;;2144   static int32_t                 USART1_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART1_Resources); }
;;;2145   static ARM_USART_STATUS        USART1_GetStatus       (void)                                                { return USART_GetStatus (&USART1_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L9.12|
000004  f7fffffe          BL       USART_GetStatus
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2146   static int32_t                 USART1_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART1_Resources); }
                          ENDP

                  |L9.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_GetTxCount||, CODE, READONLY, ALIGN=2

                  USART1_GetTxCount PROC
;;;2141   static int32_t                 USART1_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART1_Resources); }
;;;2142   static uint32_t                USART1_GetTxCount      (void)                                                { return USART_GetTxCount (&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L10.12|
000004  f7fffffe          BL       USART_GetTxCount
000008  bd10              POP      {r4,pc}
;;;2143   static uint32_t                USART1_GetRxCount      (void)                                                { return USART_GetRxCount (&USART1_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L10.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART1_IRQHandler PROC
;;;2147   static ARM_USART_MODEM_STATUS  USART1_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART1_Resources); }
;;;2148          void                    USART1_IRQHandler      (void)                                                {        USART_IRQHandler (&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L11.12|
000004  f7fffffe          BL       USART_IRQHandler
000008  bd10              POP      {r4,pc}
;;;2149   
                          ENDP

00000a  0000              DCW      0x0000
                  |L11.12|
                          DCD      USART1_Resources

                          AREA ||i.USART1_Initialize||, CODE, READONLY, ALIGN=2

                  USART1_Initialize PROC
;;;2135   static ARM_USART_CAPABILITIES  USART1_GetCapabilities (void)                                                { return USART_GetCapabilities (&USART1_Resources); }
;;;2136   static int32_t                 USART1_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L12.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_Initialize
00000c  bd10              POP      {r4,pc}
;;;2137   static int32_t                 USART1_Uninitialize    (void)                                                { return USART_Uninitialize (&USART1_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L12.16|
                          DCD      USART1_Resources

                          AREA ||i.USART1_PowerControl||, CODE, READONLY, ALIGN=2

                  USART1_PowerControl PROC
;;;2137   static int32_t                 USART1_Uninitialize    (void)                                                { return USART_Uninitialize (&USART1_Resources); }
;;;2138   static int32_t                 USART1_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L13.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_PowerControl
00000c  bd10              POP      {r4,pc}
;;;2139   static int32_t                 USART1_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART1_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L13.16|
                          DCD      USART1_Resources

                          AREA ||i.USART1_Receive||, CODE, READONLY, ALIGN=2

                  USART1_Receive PROC
;;;2139   static int32_t                 USART1_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART1_Resources); }
;;;2140   static int32_t                 USART1_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L14.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Receive
000010  bd70              POP      {r4-r6,pc}
;;;2141   static int32_t                 USART1_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L14.20|
                          DCD      USART1_Resources

                          AREA ||i.USART1_Send||, CODE, READONLY, ALIGN=2

                  USART1_Send PROC
;;;2138   static int32_t                 USART1_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART1_Resources); }
;;;2139   static int32_t                 USART1_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L15.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Send
000010  bd70              POP      {r4-r6,pc}
;;;2140   static int32_t                 USART1_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART1_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L15.20|
                          DCD      USART1_Resources

                          AREA ||i.USART1_SetModemControl||, CODE, READONLY, ALIGN=2

                  USART1_SetModemControl PROC
;;;2145   static ARM_USART_STATUS        USART1_GetStatus       (void)                                                { return USART_GetStatus (&USART1_Resources); }
;;;2146   static int32_t                 USART1_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L16.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_SetModemControl
00000c  bd10              POP      {r4,pc}
;;;2147   static ARM_USART_MODEM_STATUS  USART1_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART1_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L16.16|
                          DCD      USART1_Resources

                          AREA ||i.USART1_Transfer||, CODE, READONLY, ALIGN=2

                  USART1_Transfer PROC
;;;2140   static int32_t                 USART1_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART1_Resources); }
;;;2141   static int32_t                 USART1_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART1_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  4b03              LDR      r3,|L17.24|
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_Transfer
000014  bd70              POP      {r4-r6,pc}
;;;2142   static uint32_t                USART1_GetTxCount      (void)                                                { return USART_GetTxCount (&USART1_Resources); }
                          ENDP

000016  0000              DCW      0x0000
                  |L17.24|
                          DCD      USART1_Resources

                          AREA ||i.USART1_Uninitialize||, CODE, READONLY, ALIGN=2

                  USART1_Uninitialize PROC
;;;2136   static int32_t                 USART1_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART1_Resources); }
;;;2137   static int32_t                 USART1_Uninitialize    (void)                                                { return USART_Uninitialize (&USART1_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L18.12|
000004  f7fffffe          BL       USART_Uninitialize
000008  bd10              POP      {r4,pc}
;;;2138   static int32_t                 USART1_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART1_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L18.12|
                          DCD      USART1_Resources

                          AREA ||i.USART2_Control||, CODE, READONLY, ALIGN=2

                  USART2_Control PROC
;;;2186   static uint32_t                USART2_GetRxCount      (void)                                                { return USART_GetRxCount (&USART2_Resources); }
;;;2187   static int32_t                 USART2_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART2_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L19.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Control
000010  bd70              POP      {r4-r6,pc}
;;;2188   static ARM_USART_STATUS        USART2_GetStatus       (void)                                                { return USART_GetStatus (&USART2_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L19.20|
                          DCD      USART2_Resources

                          AREA ||i.USART2_GetCapabilities||, CODE, READONLY, ALIGN=2

                  USART2_GetCapabilities PROC
;;;2177   // USART2 Driver Wrapper functions
;;;2178   static ARM_USART_CAPABILITIES  USART2_GetCapabilities (void)                                                { return USART_GetCapabilities (&USART2_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L20.12|
000004  f7fffffe          BL       USART_GetCapabilities
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2179   static int32_t                 USART2_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART2_Resources); }
                          ENDP

                  |L20.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_GetModemStatus||, CODE, READONLY, ALIGN=2

                  USART2_GetModemStatus PROC
;;;2189   static int32_t                 USART2_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART2_Resources); }
;;;2190   static ARM_USART_MODEM_STATUS  USART2_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART2_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L21.12|
000004  f7fffffe          BL       USART_GetModemStatus
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2191          void                    USART2_IRQHandler      (void)                                                {        USART_IRQHandler (&USART2_Resources); }
                          ENDP

                  |L21.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_GetRxCount||, CODE, READONLY, ALIGN=2

                  USART2_GetRxCount PROC
;;;2185   static uint32_t                USART2_GetTxCount      (void)                                                { return USART_GetTxCount (&USART2_Resources); }
;;;2186   static uint32_t                USART2_GetRxCount      (void)                                                { return USART_GetRxCount (&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L22.12|
000004  f7fffffe          BL       USART_GetRxCount
000008  bd10              POP      {r4,pc}
;;;2187   static int32_t                 USART2_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART2_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L22.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_GetStatus||, CODE, READONLY, ALIGN=2

                  USART2_GetStatus PROC
;;;2187   static int32_t                 USART2_Control         (uint32_t control, uint32_t arg)                      { return USART_Control (control, arg, &USART2_Resources); }
;;;2188   static ARM_USART_STATUS        USART2_GetStatus       (void)                                                { return USART_GetStatus (&USART2_Resources); }
000000  b508              PUSH     {r3,lr}
000002  4802              LDR      r0,|L23.12|
000004  f7fffffe          BL       USART_GetStatus
000008  9000              STR      r0,[sp,#0]
00000a  bd08              POP      {r3,pc}
;;;2189   static int32_t                 USART2_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART2_Resources); }
                          ENDP

                  |L23.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_GetTxCount||, CODE, READONLY, ALIGN=2

                  USART2_GetTxCount PROC
;;;2184   static int32_t                 USART2_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART2_Resources); }
;;;2185   static uint32_t                USART2_GetTxCount      (void)                                                { return USART_GetTxCount (&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L24.12|
000004  f7fffffe          BL       USART_GetTxCount
000008  bd10              POP      {r4,pc}
;;;2186   static uint32_t                USART2_GetRxCount      (void)                                                { return USART_GetRxCount (&USART2_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L24.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_IRQHandler||, CODE, READONLY, ALIGN=2

                  USART2_IRQHandler PROC
;;;2190   static ARM_USART_MODEM_STATUS  USART2_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART2_Resources); }
;;;2191          void                    USART2_IRQHandler      (void)                                                {        USART_IRQHandler (&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L25.12|
000004  f7fffffe          BL       USART_IRQHandler
000008  bd10              POP      {r4,pc}
;;;2192   
                          ENDP

00000a  0000              DCW      0x0000
                  |L25.12|
                          DCD      USART2_Resources

                          AREA ||i.USART2_Initialize||, CODE, READONLY, ALIGN=2

                  USART2_Initialize PROC
;;;2178   static ARM_USART_CAPABILITIES  USART2_GetCapabilities (void)                                                { return USART_GetCapabilities (&USART2_Resources); }
;;;2179   static int32_t                 USART2_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L26.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_Initialize
00000c  bd10              POP      {r4,pc}
;;;2180   static int32_t                 USART2_Uninitialize    (void)                                                { return USART_Uninitialize (&USART2_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L26.16|
                          DCD      USART2_Resources

                          AREA ||i.USART2_PowerControl||, CODE, READONLY, ALIGN=2

                  USART2_PowerControl PROC
;;;2180   static int32_t                 USART2_Uninitialize    (void)                                                { return USART_Uninitialize (&USART2_Resources); }
;;;2181   static int32_t                 USART2_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L27.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_PowerControl
00000c  bd10              POP      {r4,pc}
;;;2182   static int32_t                 USART2_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART2_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L27.16|
                          DCD      USART2_Resources

                          AREA ||i.USART2_Receive||, CODE, READONLY, ALIGN=2

                  USART2_Receive PROC
;;;2182   static int32_t                 USART2_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART2_Resources); }
;;;2183   static int32_t                 USART2_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART2_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L28.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Receive
000010  bd70              POP      {r4-r6,pc}
;;;2184   static int32_t                 USART2_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART2_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L28.20|
                          DCD      USART2_Resources

                          AREA ||i.USART2_Send||, CODE, READONLY, ALIGN=2

                  USART2_Send PROC
;;;2181   static int32_t                 USART2_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART2_Resources); }
;;;2182   static int32_t                 USART2_Send            (const void *data, uint32_t num)                      { return USART_Send (data, num, &USART2_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4a03              LDR      r2,|L29.20|
000008  4629              MOV      r1,r5
00000a  4620              MOV      r0,r4
00000c  f7fffffe          BL       USART_Send
000010  bd70              POP      {r4-r6,pc}
;;;2183   static int32_t                 USART2_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART2_Resources); }
                          ENDP

000012  0000              DCW      0x0000
                  |L29.20|
                          DCD      USART2_Resources

                          AREA ||i.USART2_SetModemControl||, CODE, READONLY, ALIGN=2

                  USART2_SetModemControl PROC
;;;2188   static ARM_USART_STATUS        USART2_GetStatus       (void)                                                { return USART_GetStatus (&USART2_Resources); }
;;;2189   static int32_t                 USART2_SetModemControl (ARM_USART_MODEM_CONTROL control)                     { return USART_SetModemControl (control, &USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
000004  4902              LDR      r1,|L30.16|
000006  4620              MOV      r0,r4
000008  f7fffffe          BL       USART_SetModemControl
00000c  bd10              POP      {r4,pc}
;;;2190   static ARM_USART_MODEM_STATUS  USART2_GetModemStatus  (void)                                                { return USART_GetModemStatus (&USART2_Resources); }
                          ENDP

00000e  0000              DCW      0x0000
                  |L30.16|
                          DCD      USART2_Resources

                          AREA ||i.USART2_Transfer||, CODE, READONLY, ALIGN=2

                  USART2_Transfer PROC
;;;2183   static int32_t                 USART2_Receive         (void *data, uint32_t num)                            { return USART_Receive (data, num, &USART2_Resources); }
;;;2184   static int32_t                 USART2_Transfer        (const void *data_out, void *data_in, uint32_t num)   { return USART_Transfer (data_out, data_in, num, &USART2_Resources); }
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
000004  460d              MOV      r5,r1
000006  4616              MOV      r6,r2
000008  4b03              LDR      r3,|L31.24|
00000a  4632              MOV      r2,r6
00000c  4629              MOV      r1,r5
00000e  4620              MOV      r0,r4
000010  f7fffffe          BL       USART_Transfer
000014  bd70              POP      {r4-r6,pc}
;;;2185   static uint32_t                USART2_GetTxCount      (void)                                                { return USART_GetTxCount (&USART2_Resources); }
                          ENDP

000016  0000              DCW      0x0000
                  |L31.24|
                          DCD      USART2_Resources

                          AREA ||i.USART2_Uninitialize||, CODE, READONLY, ALIGN=2

                  USART2_Uninitialize PROC
;;;2179   static int32_t                 USART2_Initialize      (ARM_USART_SignalEvent_t cb_event)                    { return USART_Initialize (cb_event, &USART2_Resources); }
;;;2180   static int32_t                 USART2_Uninitialize    (void)                                                { return USART_Uninitialize (&USART2_Resources); }
000000  b510              PUSH     {r4,lr}
000002  4802              LDR      r0,|L32.12|
000004  f7fffffe          BL       USART_Uninitialize
000008  bd10              POP      {r4,pc}
;;;2181   static int32_t                 USART2_PowerControl    (ARM_POWER_STATE state)                               { return USART_PowerControl (state, &USART2_Resources); }
                          ENDP

00000a  0000              DCW      0x0000
                  |L32.12|
                          DCD      USART2_Resources

                          AREA ||i.USART_Control||, CODE, READONLY, ALIGN=2

                  USART_Control PROC
;;;1258   */
;;;1259   static int32_t USART_Control (      uint32_t          control,
000000  e92d4ffe          PUSH     {r1-r11,lr}
;;;1260                                       uint32_t          arg,
;;;1261                                 const USART_RESOURCES  *usart) {
000004  4607              MOV      r7,r0
000006  460d              MOV      r5,r1
000008  4614              MOV      r4,r2
;;;1262     uint32_t val, mode, flow_control, br, i;
;;;1263     uint32_t cr1, cr2, cr3;
;;;1264   
;;;1265     if ((usart->info->flags & USART_FLAG_POWERED) == 0U) {
00000a  6b20              LDR      r0,[r4,#0x30]
00000c  7ac0              LDRB     r0,[r0,#0xb]
00000e  f0000002          AND      r0,r0,#2
000012  b918              CBNZ     r0,|L33.28|
;;;1266       // USART not powered
;;;1267       return ARM_DRIVER_ERROR;
000014  f04f30ff          MOV      r0,#0xffffffff
                  |L33.24|
;;;1268     }
;;;1269   
;;;1270     cr1  = 0U;
;;;1271     cr2  = 0U;
;;;1272     cr3  = 0U;
;;;1273   
;;;1274     switch (control & ARM_USART_CONTROL_Msk) {
;;;1275        // Control break
;;;1276       case ARM_USART_CONTROL_BREAK:
;;;1277         if (arg) {
;;;1278           if (usart->xfer->send_active != 0U) { return ARM_DRIVER_ERROR_BUSY; }
;;;1279   
;;;1280           // Set Send active and Break flag
;;;1281           usart->xfer->send_active = 1U;
;;;1282           usart->xfer->break_flag  = 1U;
;;;1283   
;;;1284           // Enable TX interrupt and send break
;;;1285           usart->reg->CR1 |=  USART_CR1_TXEIE | USART_CR1_SBK;
;;;1286         } else {
;;;1287             if (usart->xfer->break_flag) {
;;;1288               // Disable TX interrupt
;;;1289               usart->reg->CR1 &= ~USART_CR1_TXEIE;
;;;1290   
;;;1291               // Clear break and Send Active flag
;;;1292               usart->xfer->break_flag  = 0U;
;;;1293               usart->xfer->send_active = 0U;
;;;1294             }
;;;1295         }
;;;1296         return ARM_DRIVER_OK;
;;;1297   
;;;1298       // Abort Send
;;;1299       case ARM_USART_ABORT_SEND:
;;;1300         // Disable TX and TC interrupt
;;;1301         usart->reg->CR1 &= ~(USART_CR1_TXEIE | USART_CR1_TCIE);
;;;1302   
;;;1303         // If DMA mode - disable DMA channel
;;;1304         if ((usart->dma_tx != NULL) && (usart->xfer->send_active != 0)) {
;;;1305           // DMA disable transmitter
;;;1306           usart->reg->CR3 &= ~USART_CR3_DMAT;
;;;1307   
;;;1308           // Abort TX DMA transfer
;;;1309           DMA_ChannelDisable (usart->dma_tx->instance);
;;;1310         }
;;;1311   
;;;1312         // Clear break flag
;;;1313         usart->xfer->break_flag = 0U;
;;;1314   
;;;1315         // Clear Send active flag
;;;1316         usart->xfer->send_active = 0U;
;;;1317         return ARM_DRIVER_OK;
;;;1318   
;;;1319       // Abort receive
;;;1320       case ARM_USART_ABORT_RECEIVE:
;;;1321         // Disable RX interrupt
;;;1322         usart->reg->CR1 &= ~USART_CR1_RXNEIE;
;;;1323   
;;;1324         // If DMA mode - disable DMA channel
;;;1325         if ((usart->dma_rx != NULL) && (usart->info->status.rx_busy != 0)) {
;;;1326           // DMA disable Receiver
;;;1327           usart->reg->CR3 &= ~USART_CR3_DMAR;
;;;1328   
;;;1329           // Abort RX DMA transfer
;;;1330           DMA_ChannelDisable (usart->dma_rx->instance);
;;;1331         }
;;;1332   
;;;1333         // Clear RX busy status
;;;1334         usart->info->status.rx_busy = 0U;
;;;1335   
;;;1336         return ARM_DRIVER_OK;
;;;1337   
;;;1338       // Abort transfer
;;;1339       case ARM_USART_ABORT_TRANSFER:
;;;1340         // Disable TX, TC and RX interrupt
;;;1341         usart->reg->CR1 &= ~(USART_CR1_TXEIE | USART_CR1_TCIE | USART_CR1_RXNEIE);
;;;1342   
;;;1343         // If DMA mode - disable DMA channel
;;;1344         if ((usart->dma_tx != NULL) && (usart->xfer->send_active != 0U)) {
;;;1345           // DMA disable transmitter
;;;1346           usart->reg->CR3 &= ~USART_CR3_DMAT;
;;;1347   
;;;1348           // Abort TX DMA transfer
;;;1349           DMA_ChannelDisable (usart->dma_tx->instance);
;;;1350         }
;;;1351   
;;;1352         // If DMA mode - disable DMA channel
;;;1353         if ((usart->dma_rx != NULL) && (usart->info->status.rx_busy != 0U)) {
;;;1354           // DMA disable Receiver
;;;1355           usart->reg->CR3 &= ~USART_CR3_DMAR;
;;;1356   
;;;1357           // Abort RX DMA transfer
;;;1358           DMA_ChannelDisable (usart->dma_rx->instance);
;;;1359         }
;;;1360   
;;;1361         // Clear busy statuses
;;;1362         usart->info->status.rx_busy = 0U;
;;;1363         usart->xfer->send_active    = 0U;
;;;1364         return ARM_DRIVER_OK;
;;;1365   
;;;1366       // Control TX
;;;1367       case ARM_USART_CONTROL_TX:
;;;1368         // Check if TX pin available
;;;1369         if (usart->io.tx == NULL) { return ARM_DRIVER_ERROR; }
;;;1370         if (arg) {
;;;1371           if (usart->info->mode != ARM_USART_MODE_SMART_CARD) {
;;;1372             // USART TX pin function selected
;;;1373             GPIO_PinConfigure(usart->io.tx->port, usart->io.tx->pin, GPIO_AF_PUSHPULL, GPIO_MODE_OUT50MHZ);
;;;1374           }
;;;1375           usart->info->flags |= USART_FLAG_TX_ENABLED;
;;;1376   
;;;1377           // Transmitter enable
;;;1378           usart->reg->CR1 |= USART_CR1_TE;
;;;1379         } else {
;;;1380           // Transmitter disable
;;;1381           usart->reg->CR1 &= ~USART_CR1_TE;
;;;1382   
;;;1383           usart->info->flags &= ~USART_FLAG_TX_ENABLED;
;;;1384   
;;;1385           if (usart->info->mode != ARM_USART_MODE_SMART_CARD) {
;;;1386             // GPIO pin function selected
;;;1387             if (usart->io.tx) {
;;;1388               GPIO_PinConfigure(usart->io.tx->port, usart->io.tx->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1389             }
;;;1390           }
;;;1391         }
;;;1392         return ARM_DRIVER_OK;
;;;1393   
;;;1394       // Control RX
;;;1395       case ARM_USART_CONTROL_RX:
;;;1396         // Check if RX line available
;;;1397         if (usart->io.rx == NULL) { return ARM_DRIVER_ERROR; }
;;;1398         if (arg) {
;;;1399           if ((usart->info->mode != ARM_USART_MODE_SMART_CARD)   &&
;;;1400               (usart->info->mode != ARM_USART_MODE_SINGLE_WIRE )) {
;;;1401             // USART RX pin function selected
;;;1402             GPIO_PinConfigure(usart->io.rx->port, usart->io.rx->pin, GPIO_IN_FLOATING, GPIO_MODE_INPUT);
;;;1403           }
;;;1404           usart->info->flags |= USART_FLAG_RX_ENABLED;
;;;1405   
;;;1406           // Enable Error interrupt,
;;;1407           usart->reg->CR3 |= USART_CR3_EIE;
;;;1408   
;;;1409           // Break detection interrupt enable
;;;1410           usart->reg->CR2 |= USART_CR2_LBDIE;
;;;1411   
;;;1412           // Enable Idle line interrupt
;;;1413           usart->reg->CR1 |= USART_CR1_IDLEIE;
;;;1414   
;;;1415           if (((usart->info->status.rx_busy != 0U) && (usart->dma_rx != NULL)) == false) {
;;;1416             usart->reg->CR1 |= USART_CR1_RXNEIE;
;;;1417           }
;;;1418   
;;;1419           // Receiver enable
;;;1420           usart->reg->CR1 |= USART_CR1_RE;
;;;1421   
;;;1422         } else {
;;;1423           // Receiver disable
;;;1424           usart->reg->CR1 &= ~USART_CR1_RE;
;;;1425   
;;;1426           usart->info->flags &= ~USART_FLAG_RX_ENABLED;
;;;1427   
;;;1428           if ((usart->info->mode != ARM_USART_MODE_SMART_CARD)   &&
;;;1429               (usart->info->mode != ARM_USART_MODE_SINGLE_WIRE )) {
;;;1430             // GPIO pin function selected
;;;1431             if (usart->io.rx) {
;;;1432               GPIO_PinConfigure(usart->io.rx->port, usart->io.rx->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1433             }
;;;1434           }
;;;1435         }
;;;1436         return ARM_DRIVER_OK;
;;;1437       default: break;
;;;1438     }
;;;1439   
;;;1440     // Check if busy
;;;1441     if ((usart->info->status.rx_busy != 0U) || (usart->xfer->send_active != 0U)) {
;;;1442       return ARM_DRIVER_ERROR_BUSY;
;;;1443     }
;;;1444   
;;;1445     if (((usart->reg->CR1 & USART_CR1_TE) != 0U) && ((usart->reg->SR & USART_SR_TC) == 0U)) {
;;;1446       return ARM_DRIVER_ERROR_BUSY;
;;;1447     }
;;;1448   
;;;1449     switch (control & ARM_USART_CONTROL_Msk) {
;;;1450       case ARM_USART_MODE_ASYNCHRONOUS:
;;;1451         mode = ARM_USART_MODE_ASYNCHRONOUS;
;;;1452         break;
;;;1453       case ARM_USART_MODE_SYNCHRONOUS_MASTER:
;;;1454         if (usart->capabilities.synchronous_master) {
;;;1455           // Enable Clock pin
;;;1456           cr2 |= USART_CR2_CLKEN;
;;;1457   
;;;1458           // Enable last bit clock pulse
;;;1459           cr2 |= USART_CR2_LBCL;
;;;1460         } else { return ARM_USART_ERROR_MODE; }
;;;1461         mode = ARM_USART_MODE_SYNCHRONOUS_MASTER;
;;;1462         break;
;;;1463       case ARM_USART_MODE_SYNCHRONOUS_SLAVE:
;;;1464         return ARM_USART_ERROR_MODE;
;;;1465       case ARM_USART_MODE_SINGLE_WIRE:
;;;1466         // Enable Half duplex
;;;1467         cr3 |= USART_CR3_HDSEL;
;;;1468         mode = ARM_USART_MODE_SINGLE_WIRE;
;;;1469         break;
;;;1470       case ARM_USART_MODE_IRDA:
;;;1471         // Enable IrDA mode
;;;1472         cr3 |= USART_CR3_IREN;
;;;1473         mode = ARM_USART_MODE_IRDA;
;;;1474         break;
;;;1475       case ARM_USART_MODE_SMART_CARD:
;;;1476         if (usart->capabilities.smart_card) {
;;;1477           // Enable Smart card mode
;;;1478           cr3 |= USART_CR3_SCEN;
;;;1479         } else { return ARM_USART_ERROR_MODE; }
;;;1480         mode = ARM_USART_MODE_SMART_CARD;
;;;1481         break;
;;;1482   
;;;1483       // Default TX value
;;;1484       case ARM_USART_SET_DEFAULT_TX_VALUE:
;;;1485         usart->xfer->def_val = (uint16_t)arg;
;;;1486         return ARM_DRIVER_OK;
;;;1487   
;;;1488       // IrDA pulse
;;;1489       case ARM_USART_SET_IRDA_PULSE:
;;;1490         if (usart->info->mode != ARM_USART_MODE_IRDA) {
;;;1491           if (arg != 0U) {
;;;1492             // IrDa low-power
;;;1493             usart->reg->CR3 |= USART_CR3_IRLP;
;;;1494   
;;;1495             // Get clock
;;;1496             val = usart->pclk;
;;;1497   
;;;1498             // Calculate period in ns
;;;1499             val = 1000000000U / val;
;;;1500             for (i = 1U; i < 256U; i++) {
;;;1501               if ((val * i) > arg) { break; }
;;;1502             }
;;;1503             if (i == 256U) { return ARM_DRIVER_ERROR; }
;;;1504             usart->reg->GTPR = (usart->reg->GTPR & ~USART_GTPR_PSC) | i;
;;;1505           }
;;;1506         } else { return ARM_DRIVER_ERROR; }
;;;1507         return ARM_DRIVER_OK;
;;;1508   
;;;1509       // SmartCard guard time
;;;1510       case ARM_USART_SET_SMART_CARD_GUARD_TIME:
;;;1511         if (usart->info->mode == ARM_USART_MODE_SMART_CARD) {
;;;1512           if (arg > 255U) return ARM_DRIVER_ERROR;
;;;1513   
;;;1514           usart->reg->GTPR = (usart->reg->GTPR & ~USART_GTPR_GT) | arg;
;;;1515         } else { return ARM_DRIVER_ERROR; }
;;;1516         return ARM_DRIVER_OK;
;;;1517   
;;;1518       // SmartCard clock
;;;1519       case ARM_USART_SET_SMART_CARD_CLOCK:
;;;1520         if (usart->info->mode == ARM_USART_MODE_SMART_CARD) {
;;;1521           // Get clock
;;;1522           val = usart->pclk;
;;;1523   
;;;1524           // Calculate period in ns
;;;1525           val = 1000000000U / val;
;;;1526           for (i = 1U; i <64U; i++) {
;;;1527             // if in +-2% tolerance
;;;1528             if (((val * i * 2U * 100U) < (arg * 102U)) &&
;;;1529                 ((val * i * 2U * 100U) > (arg * 98U))    ) {
;;;1530               break;
;;;1531             }
;;;1532           }
;;;1533           if (i == 64U) { return ARM_DRIVER_ERROR; }
;;;1534   
;;;1535           usart->reg->GTPR = (usart->reg->GTPR & ~USART_GTPR_PSC) | i;
;;;1536         } else { return ARM_DRIVER_ERROR; }
;;;1537         return ARM_DRIVER_OK;
;;;1538   
;;;1539       // SmartCard NACK
;;;1540       case ARM_USART_CONTROL_SMART_CARD_NACK:
;;;1541         if (usart->info->mode == ARM_USART_MODE_SMART_CARD) {
;;;1542           // SmartCard NACK Enable
;;;1543           if (arg != 0U) { usart->reg->CR3 |= USART_CR3_NACK; }
;;;1544         } else { return ARM_DRIVER_ERROR; }
;;;1545         return ARM_DRIVER_OK;
;;;1546   
;;;1547       // Unsupported command
;;;1548       default: { return ARM_DRIVER_ERROR_UNSUPPORTED; }
;;;1549     }
;;;1550   
;;;1551     // USART Data bits
;;;1552     switch (control & ARM_USART_DATA_BITS_Msk) {
;;;1553       case ARM_USART_DATA_BITS_7:
;;;1554         if ((control & ARM_USART_PARITY_Msk) == ARM_USART_PARITY_NONE) {
;;;1555           return ARM_USART_ERROR_DATA_BITS;
;;;1556         }
;;;1557   
;;;1558         // 7 data bits, 8. data bit is parity bit
;;;1559         break;
;;;1560       case ARM_USART_DATA_BITS_8:
;;;1561         if ((control & ARM_USART_PARITY_Msk) == ARM_USART_PARITY_NONE) {
;;;1562           // 8-data bits, no parity
;;;1563         } else {
;;;1564           // 11-bit break detection
;;;1565           cr2 |= USART_CR2_LBDL;
;;;1566   
;;;1567           // 8-data bits, 9. bit is parity bit
;;;1568           cr1 |= USART_CR1_M;
;;;1569         }
;;;1570         break;
;;;1571       case ARM_USART_DATA_BITS_9:
;;;1572         if ((control & ARM_USART_PARITY_Msk) != ARM_USART_PARITY_NONE) {
;;;1573           return ARM_USART_ERROR_DATA_BITS;
;;;1574         }
;;;1575   
;;;1576         // 11-bit break detection
;;;1577         cr2 |= USART_CR2_LBDL;
;;;1578   
;;;1579         // 9-data bits, no parity
;;;1580         cr1 |= USART_CR1_M;
;;;1581         break;
;;;1582       default: return ARM_USART_ERROR_DATA_BITS;
;;;1583     }
;;;1584   
;;;1585     // USART Parity
;;;1586     switch (control & ARM_USART_PARITY_Msk) {
;;;1587       case ARM_USART_PARITY_NONE:                              break;
;;;1588       case ARM_USART_PARITY_EVEN:   cr1 |=  USART_CR1_PCE;     break;
;;;1589       case ARM_USART_PARITY_ODD:    cr1 |= (USART_CR1_PCE | 
;;;1590                                             USART_CR1_PS);     break;
;;;1591       default: return ARM_USART_ERROR_PARITY;
;;;1592     }
;;;1593   
;;;1594     // USART Stop bits
;;;1595     switch (control & ARM_USART_STOP_BITS_Msk) {
;;;1596       case ARM_USART_STOP_BITS_1:                              break;
;;;1597       case ARM_USART_STOP_BITS_2:   cr2 |= USART_CR2_STOP_1;   break;
;;;1598       case ARM_USART_STOP_BITS_1_5: cr2 |= USART_CR2_STOP_0 |
;;;1599                                            USART_CR2_STOP_1;   break;
;;;1600       case ARM_USART_STOP_BITS_0_5: cr2 |= USART_CR2_STOP_0;   break;
;;;1601       default: return ARM_USART_ERROR_STOP_BITS;
;;;1602     }
;;;1603   
;;;1604     // USART Flow control
;;;1605     switch (control & ARM_USART_FLOW_CONTROL_Msk) {
;;;1606       case ARM_USART_FLOW_CONTROL_NONE:
;;;1607         flow_control = ARM_USART_FLOW_CONTROL_NONE;
;;;1608         break;
;;;1609       case ARM_USART_FLOW_CONTROL_RTS:
;;;1610         if (usart->capabilities.flow_control_rts) {
;;;1611           flow_control = ARM_USART_FLOW_CONTROL_RTS;
;;;1612           // RTS Enable
;;;1613           cr3 |= USART_CR3_RTSE;
;;;1614         }
;;;1615         else  { return ARM_USART_ERROR_FLOW_CONTROL; }
;;;1616         break;
;;;1617       case ARM_USART_FLOW_CONTROL_CTS:
;;;1618         if (usart->capabilities.flow_control_cts) {
;;;1619           flow_control = ARM_USART_FLOW_CONTROL_CTS;
;;;1620           // CTS Enable, CTS interrupt enable
;;;1621           cr3 |= USART_CR3_CTSE | USART_CR3_CTSIE;
;;;1622         }
;;;1623         else { return ARM_USART_ERROR_FLOW_CONTROL; }
;;;1624         break;
;;;1625       case ARM_USART_FLOW_CONTROL_RTS_CTS:
;;;1626         if ((usart->capabilities.flow_control_rts != 0U) &&
;;;1627             (usart->capabilities.flow_control_cts != 0U)) {
;;;1628           flow_control = ARM_USART_FLOW_CONTROL_RTS_CTS;
;;;1629           // RTS and CTS Enable, CTS interrupt enable
;;;1630           cr3 |= (USART_CR3_RTSE | USART_CR3_CTSE | USART_CR3_CTSIE);
;;;1631         } else { return ARM_USART_ERROR_FLOW_CONTROL; }
;;;1632         break;
;;;1633       default: return ARM_USART_ERROR_FLOW_CONTROL;
;;;1634     }
;;;1635   
;;;1636     // Clock setting for synchronous mode
;;;1637     if (mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;1638   
;;;1639       // Polarity
;;;1640       switch (control & ARM_USART_CPOL_Msk) {
;;;1641         case ARM_USART_CPOL0:
;;;1642           break;
;;;1643         case ARM_USART_CPOL1:
;;;1644           cr2 |= USART_CR2_CPOL;
;;;1645           break;
;;;1646         default: return ARM_USART_ERROR_CPOL;
;;;1647       }
;;;1648   
;;;1649       // Phase
;;;1650       switch (control & ARM_USART_CPHA_Msk) {
;;;1651         case ARM_USART_CPHA0:
;;;1652           break;
;;;1653         case ARM_USART_CPHA1:
;;;1654           cr2 |= USART_CR2_CPHA;
;;;1655           break;
;;;1656         default: return ARM_USART_ERROR_CPHA;
;;;1657       }
;;;1658     }
;;;1659   
;;;1660     // USART Baudrate
;;;1661     val = (uint32_t) (USART_BAUDRATE_DIVIDER(usart->pclk, arg));
;;;1662     br = ((usart->pclk << 4U) / (val & 0xFFFFU)) >> 4U;
;;;1663     // If inside +/- 2% tolerance, baud rate configured correctly
;;;1664     if (!(((br * 100U) < (arg * 102U)) && ((br * 100U) > (arg * 98U)))) {
;;;1665       return ARM_USART_ERROR_BAUDRATE;
;;;1666     }
;;;1667   
;;;1668     // USART Disable
;;;1669     usart->reg->CR1 &= ~USART_CR1_UE;
;;;1670   
;;;1671     // Configure Baud rate register
;;;1672     usart->reg->BRR = val;
;;;1673   
;;;1674     // Configuration is OK - Mode is valid
;;;1675     usart->info->mode = mode;
;;;1676   
;;;1677     // Save flow control mode
;;;1678     usart->info->flow_control = flow_control;
;;;1679   
;;;1680     // Configure TX pin regarding mode and transmitter state
;;;1681     switch (usart->info->mode) {
;;;1682       case ARM_USART_MODE_SMART_CARD:
;;;1683         // USART TX pin function selected
;;;1684         if (usart->io.tx) {
;;;1685           GPIO_PinConfigure(usart->io.tx->port, usart->io.tx->pin, GPIO_AF_PUSHPULL, GPIO_MODE_OUT50MHZ);
;;;1686         }
;;;1687         break;
;;;1688       default:
;;;1689         // Synchronous master/slave, asynchronous, single-wire and IrDA mode
;;;1690         if (usart->info->flags & USART_FLAG_TX_ENABLED) {
;;;1691           // USART TX pin function selected
;;;1692           if (usart->io.tx) {
;;;1693             GPIO_PinConfigure(usart->io.tx->port, usart->io.tx->pin, GPIO_AF_PUSHPULL, GPIO_MODE_OUT50MHZ);
;;;1694           }
;;;1695         } else {
;;;1696           // GPIO pin function selected
;;;1697           if (usart->io.tx) {
;;;1698             GPIO_PinConfigure(usart->io.tx->port, usart->io.tx->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1699           }
;;;1700         }
;;;1701     }
;;;1702   
;;;1703     // Configure RX pin regarding mode and receiver state
;;;1704     switch (usart->info->mode) {
;;;1705       case ARM_USART_MODE_SINGLE_WIRE:
;;;1706       case ARM_USART_MODE_SMART_CARD:
;;;1707         // GPIO pin function selected
;;;1708         if (usart->io.rx) {
;;;1709           GPIO_PinConfigure(usart->io.rx->port, usart->io.rx->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1710         }
;;;1711         break;
;;;1712       default:
;;;1713         // Synchronous master/slave, asynchronous and  IrDA mode
;;;1714         if (usart->info->flags & USART_FLAG_RX_ENABLED) {
;;;1715           // USART RX pin function selected
;;;1716           if (usart->io.rx) {
;;;1717             GPIO_PinConfigure(usart->io.rx->port, usart->io.rx->pin, GPIO_IN_FLOATING, GPIO_MODE_INPUT);
;;;1718           }
;;;1719         } else {
;;;1720          // GPIO pin function selected
;;;1721           if (usart->io.rx) {
;;;1722             GPIO_PinConfigure(usart->io.rx->port, usart->io.rx->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1723           }
;;;1724         }
;;;1725         break;
;;;1726     }
;;;1727   
;;;1728     // Configure CLK pin regarding mode
;;;1729     if (usart->io.ck) {
;;;1730       switch (usart->info->mode) {
;;;1731         case ARM_USART_MODE_SMART_CARD:
;;;1732         case ARM_USART_MODE_SYNCHRONOUS_MASTER:
;;;1733           // USART CK pin function selected
;;;1734           GPIO_PinConfigure(usart->io.ck->port, usart->io.ck->pin, GPIO_AF_PUSHPULL, GPIO_MODE_OUT50MHZ);
;;;1735           break;
;;;1736         default:
;;;1737           // Asynchronous, Single-wire and IrDA mode
;;;1738           // GPIO pin function selected
;;;1739           GPIO_PinConfigure(usart->io.ck->port, usart->io.ck->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
;;;1740       }
;;;1741     }
;;;1742   
;;;1743     // Configure RTS pin regarding Flow control configuration
;;;1744     if (usart->io.rts) {
;;;1745       if ((flow_control == ARM_USART_FLOW_CONTROL_RTS) ||
;;;1746           (flow_control == ARM_USART_FLOW_CONTROL_RTS_CTS)) {
;;;1747         // USART RTS Alternate function
;;;1748         GPIO_PinConfigure(usart->io.rts->port, usart->io.rts->pin, GPIO_AF_PUSHPULL, GPIO_MODE_OUT50MHZ);
;;;1749       } else {
;;;1750         // GPIO output
;;;1751         GPIO_PinConfigure(usart->io.rts->port, usart->io.rts->pin, GPIO_OUT_PUSH_PULL, GPIO_MODE_INPUT);
;;;1752       }
;;;1753     }
;;;1754   
;;;1755     // Configure CTS pin regarding Flow control configuration
;;;1756     if (usart->io.cts) {
;;;1757       if ((flow_control == ARM_USART_FLOW_CONTROL_CTS) ||
;;;1758           (flow_control == ARM_USART_FLOW_CONTROL_RTS_CTS)) {
;;;1759         // USART CTS Alternate function
;;;1760         GPIO_PinConfigure(usart->io.cts->port, usart->io.cts->pin, GPIO_IN_FLOATING, GPIO_MODE_INPUT);
;;;1761       } else {
;;;1762         // GPIO input
;;;1763         GPIO_PinConfigure(usart->io.cts->port, usart->io.cts->pin, GPIO_IN_FLOATING, GPIO_MODE_INPUT);
;;;1764       }
;;;1765     }
;;;1766   
;;;1767     // Configure USART control registers
;;;1768     usart->reg->CR1 = cr1;
;;;1769     usart->reg->CR2 = cr2;
;;;1770     usart->reg->CR3 = cr3;
;;;1771   
;;;1772     // USART Enable
;;;1773     usart->reg->CR1 |= USART_CR1_UE;
;;;1774   
;;;1775     // Set configured flag
;;;1776     usart->info->flags |= USART_FLAG_CONFIGURED;
;;;1777   
;;;1778     return ARM_DRIVER_OK;
;;;1779   }
000018  e8bd8ffe          POP      {r1-r11,pc}
                  |L33.28|
00001c  2000              MOVS     r0,#0                 ;1270
00001e  9000              STR      r0,[sp,#0]            ;1270
000020  4680              MOV      r8,r0                 ;1271
000022  4683              MOV      r11,r0                ;1272
000024  b2f8              UXTB     r0,r7                 ;1274
000026  3815              SUBS     r0,r0,#0x15           ;1274
000028  2806              CMP      r0,#6                 ;1274
00002a  d27c              BCS      |L33.294|
00002c  e8dff000          TBB      [pc,r0]               ;1274
000030  a3dc032c          DCB      0xa3,0xdc,0x03,0x2c
000034  4e6c              DCB      0x4e,0x6c
000036  b1a5              CBZ      r5,|L33.98|
000038  6b60              LDR      r0,[r4,#0x34]         ;1278
00003a  f8900021          LDRB     r0,[r0,#0x21]         ;1278
00003e  b110              CBZ      r0,|L33.70|
000040  f06f0001          MVN      r0,#1                 ;1278
                  |L33.68|
000044  e7e8              B        |L33.24|
                  |L33.70|
000046  2001              MOVS     r0,#1                 ;1281
000048  6b61              LDR      r1,[r4,#0x34]         ;1281
00004a  f8810021          STRB     r0,[r1,#0x21]         ;1281
00004e  6b61              LDR      r1,[r4,#0x34]         ;1282
000050  f8810020          STRB     r0,[r1,#0x20]         ;1282
000054  6860              LDR      r0,[r4,#4]            ;1285
000056  8980              LDRH     r0,[r0,#0xc]          ;1285
000058  f0400081          ORR      r0,r0,#0x81           ;1285
00005c  6861              LDR      r1,[r4,#4]            ;1285
00005e  8188              STRH     r0,[r1,#0xc]          ;1285
000060  e010              B        |L33.132|
                  |L33.98|
000062  6b60              LDR      r0,[r4,#0x34]         ;1287
000064  f8900020          LDRB     r0,[r0,#0x20]         ;1287
000068  b160              CBZ      r0,|L33.132|
00006a  6860              LDR      r0,[r4,#4]            ;1289
00006c  8980              LDRH     r0,[r0,#0xc]          ;1289
00006e  f0200080          BIC      r0,r0,#0x80           ;1289
000072  6861              LDR      r1,[r4,#4]            ;1289
000074  8188              STRH     r0,[r1,#0xc]          ;1289
000076  2000              MOVS     r0,#0                 ;1292
000078  6b61              LDR      r1,[r4,#0x34]         ;1292
00007a  f8810020          STRB     r0,[r1,#0x20]         ;1292
00007e  6b61              LDR      r1,[r4,#0x34]         ;1293
000080  f8810021          STRB     r0,[r1,#0x21]         ;1293
                  |L33.132|
000084  2000              MOVS     r0,#0                 ;1296
000086  e7c7              B        |L33.24|
000088  6860              LDR      r0,[r4,#4]            ;1301
00008a  8980              LDRH     r0,[r0,#0xc]          ;1301
00008c  f02000c0          BIC      r0,r0,#0xc0           ;1301
000090  6861              LDR      r1,[r4,#4]            ;1301
000092  8188              STRH     r0,[r1,#0xc]          ;1301
000094  6aa0              LDR      r0,[r4,#0x28]         ;1304
000096  b188              CBZ      r0,|L33.188|
000098  6b60              LDR      r0,[r4,#0x34]         ;1304
00009a  f8900021          LDRB     r0,[r0,#0x21]         ;1304
00009e  b168              CBZ      r0,|L33.188|
0000a0  6860              LDR      r0,[r4,#4]            ;1306
0000a2  8a80              LDRH     r0,[r0,#0x14]         ;1306
0000a4  f0200080          BIC      r0,r0,#0x80           ;1306
0000a8  6861              LDR      r1,[r4,#4]            ;1306
0000aa  8288              STRH     r0,[r1,#0x14]         ;1306
0000ac  6aa1              LDR      r1,[r4,#0x28]         ;1309
0000ae  6808              LDR      r0,[r1,#0]            ;1309
0000b0  6801              LDR      r1,[r0,#0]            ;1309
0000b2  f0210101          BIC      r1,r1,#1              ;1309
0000b6  6001              STR      r1,[r0,#0]            ;1309
0000b8  bf00              NOP                            ;1309
0000ba  bf00              NOP                            ;1309
                  |L33.188|
0000bc  2000              MOVS     r0,#0                 ;1313
0000be  6b61              LDR      r1,[r4,#0x34]         ;1313
0000c0  f8810020          STRB     r0,[r1,#0x20]         ;1313
0000c4  6b61              LDR      r1,[r4,#0x34]         ;1316
0000c6  f8810021          STRB     r0,[r1,#0x21]         ;1316
0000ca  e7a5              B        |L33.24|
0000cc  6860              LDR      r0,[r4,#4]            ;1322
0000ce  8980              LDRH     r0,[r0,#0xc]          ;1322
0000d0  f0200020          BIC      r0,r0,#0x20           ;1322
0000d4  6861              LDR      r1,[r4,#4]            ;1322
0000d6  8188              STRH     r0,[r1,#0xc]          ;1322
0000d8  6ae0              LDR      r0,[r4,#0x2c]         ;1325
0000da  b180              CBZ      r0,|L33.254|
0000dc  6b20              LDR      r0,[r4,#0x30]         ;1325
0000de  7940              LDRB     r0,[r0,#5]            ;1325
0000e0  b168              CBZ      r0,|L33.254|
0000e2  6860              LDR      r0,[r4,#4]            ;1327
0000e4  8a80              LDRH     r0,[r0,#0x14]         ;1327
0000e6  f0200040          BIC      r0,r0,#0x40           ;1327
0000ea  6861              LDR      r1,[r4,#4]            ;1327
0000ec  8288              STRH     r0,[r1,#0x14]         ;1327
0000ee  6ae1              LDR      r1,[r4,#0x2c]         ;1330
0000f0  6808              LDR      r0,[r1,#0]            ;1330
0000f2  6801              LDR      r1,[r0,#0]            ;1330
0000f4  f0210101          BIC      r1,r1,#1              ;1330
0000f8  6001              STR      r1,[r0,#0]            ;1330
0000fa  bf00              NOP                            ;1330
0000fc  bf00              NOP                            ;1330
                  |L33.254|
0000fe  2100              MOVS     r1,#0                 ;1334
000100  6b20              LDR      r0,[r4,#0x30]         ;1334
000102  7141              STRB     r1,[r0,#5]            ;1334
000104  2000              MOVS     r0,#0                 ;1336
000106  e787              B        |L33.24|
000108  6860              LDR      r0,[r4,#4]            ;1341
00010a  8980              LDRH     r0,[r0,#0xc]          ;1341
00010c  f02000e0          BIC      r0,r0,#0xe0           ;1341
000110  6861              LDR      r1,[r4,#4]            ;1341
000112  8188              STRH     r0,[r1,#0xc]          ;1341
000114  6aa0              LDR      r0,[r4,#0x28]         ;1344
000116  b198              CBZ      r0,|L33.320|
000118  6b60              LDR      r0,[r4,#0x34]         ;1344
00011a  f8900021          LDRB     r0,[r0,#0x21]         ;1344
00011e  b178              CBZ      r0,|L33.320|
000120  6860              LDR      r0,[r4,#4]            ;1346
000122  8a80              LDRH     r0,[r0,#0x14]         ;1346
000124  e000              B        |L33.296|
                  |L33.294|
000126  e0c2              B        |L33.686|
                  |L33.296|
000128  f0200080          BIC      r0,r0,#0x80           ;1346
00012c  6861              LDR      r1,[r4,#4]            ;1346
00012e  8288              STRH     r0,[r1,#0x14]         ;1346
000130  6aa1              LDR      r1,[r4,#0x28]         ;1349
000132  6808              LDR      r0,[r1,#0]            ;1349
000134  6801              LDR      r1,[r0,#0]            ;1349
000136  f0210101          BIC      r1,r1,#1              ;1349
00013a  6001              STR      r1,[r0,#0]            ;1349
00013c  bf00              NOP                            ;1349
00013e  bf00              NOP                            ;1349
                  |L33.320|
000140  6ae0              LDR      r0,[r4,#0x2c]         ;1353
000142  b180              CBZ      r0,|L33.358|
000144  6b20              LDR      r0,[r4,#0x30]         ;1353
000146  7940              LDRB     r0,[r0,#5]            ;1353
000148  b168              CBZ      r0,|L33.358|
00014a  6860              LDR      r0,[r4,#4]            ;1355
00014c  8a80              LDRH     r0,[r0,#0x14]         ;1355
00014e  f0200040          BIC      r0,r0,#0x40           ;1355
000152  6861              LDR      r1,[r4,#4]            ;1355
000154  8288              STRH     r0,[r1,#0x14]         ;1355
000156  6ae1              LDR      r1,[r4,#0x2c]         ;1358
000158  6808              LDR      r0,[r1,#0]            ;1358
00015a  6801              LDR      r1,[r0,#0]            ;1358
00015c  f0210101          BIC      r1,r1,#1              ;1358
000160  6001              STR      r1,[r0,#0]            ;1358
000162  bf00              NOP                            ;1358
000164  bf00              NOP                            ;1358
                  |L33.358|
000166  2100              MOVS     r1,#0                 ;1362
000168  6b20              LDR      r0,[r4,#0x30]         ;1362
00016a  7141              STRB     r1,[r0,#5]            ;1362
00016c  2000              MOVS     r0,#0                 ;1363
00016e  6b61              LDR      r1,[r4,#0x34]         ;1363
000170  f8810021          STRB     r0,[r1,#0x21]         ;1363
000174  e750              B        |L33.24|
000176  68e0              LDR      r0,[r4,#0xc]          ;1369
000178  b910              CBNZ     r0,|L33.384|
00017a  f04f30ff          MOV      r0,#0xffffffff        ;1369
00017e  e74b              B        |L33.24|
                  |L33.384|
000180  b1bd              CBZ      r5,|L33.434|
000182  6b20              LDR      r0,[r4,#0x30]         ;1371
000184  68c0              LDR      r0,[r0,#0xc]          ;1371
000186  2806              CMP      r0,#6                 ;1371
000188  d006              BEQ      |L33.408|
00018a  68e2              LDR      r2,[r4,#0xc]          ;1373
00018c  8891              LDRH     r1,[r2,#4]            ;1373
00018e  2303              MOVS     r3,#3                 ;1373
000190  6810              LDR      r0,[r2,#0]            ;1373
000192  2202              MOVS     r2,#2                 ;1373
000194  f7fffffe          BL       GPIO_PinConfigure
                  |L33.408|
000198  6b20              LDR      r0,[r4,#0x30]         ;1375
00019a  7ac0              LDRB     r0,[r0,#0xb]          ;1375
00019c  f0400008          ORR      r0,r0,#8              ;1375
0001a0  6b21              LDR      r1,[r4,#0x30]         ;1375
0001a2  72c8              STRB     r0,[r1,#0xb]          ;1375
0001a4  6860              LDR      r0,[r4,#4]            ;1378
0001a6  8980              LDRH     r0,[r0,#0xc]          ;1378
0001a8  f0400008          ORR      r0,r0,#8              ;1378
0001ac  6861              LDR      r1,[r4,#4]            ;1378
0001ae  8188              STRH     r0,[r1,#0xc]          ;1378
0001b0  e018              B        |L33.484|
                  |L33.434|
0001b2  6860              LDR      r0,[r4,#4]            ;1381
0001b4  8980              LDRH     r0,[r0,#0xc]          ;1381
0001b6  f0200008          BIC      r0,r0,#8              ;1381
0001ba  6861              LDR      r1,[r4,#4]            ;1381
0001bc  8188              STRH     r0,[r1,#0xc]          ;1381
0001be  6b20              LDR      r0,[r4,#0x30]         ;1383
0001c0  7ac0              LDRB     r0,[r0,#0xb]          ;1383
0001c2  f0200008          BIC      r0,r0,#8              ;1383
0001c6  6b21              LDR      r1,[r4,#0x30]         ;1383
0001c8  72c8              STRB     r0,[r1,#0xb]          ;1383
0001ca  6b20              LDR      r0,[r4,#0x30]         ;1385
0001cc  68c0              LDR      r0,[r0,#0xc]          ;1385
0001ce  2806              CMP      r0,#6                 ;1385
0001d0  d008              BEQ      |L33.484|
0001d2  68e0              LDR      r0,[r4,#0xc]          ;1387
0001d4  b130              CBZ      r0,|L33.484|
0001d6  68e2              LDR      r2,[r4,#0xc]          ;1388
0001d8  8891              LDRH     r1,[r2,#4]            ;1388
0001da  2300              MOVS     r3,#0                 ;1388
0001dc  6810              LDR      r0,[r2,#0]            ;1388
0001de  461a              MOV      r2,r3                 ;1388
0001e0  f7fffffe          BL       GPIO_PinConfigure
                  |L33.484|
0001e4  2000              MOVS     r0,#0                 ;1392
0001e6  e717              B        |L33.24|
0001e8  6920              LDR      r0,[r4,#0x10]         ;1397
0001ea  b910              CBNZ     r0,|L33.498|
0001ec  f04f30ff          MOV      r0,#0xffffffff        ;1397
0001f0  e712              B        |L33.24|
                  |L33.498|
0001f2  b3e5              CBZ      r5,|L33.622|
0001f4  6b20              LDR      r0,[r4,#0x30]         ;1399
0001f6  68c0              LDR      r0,[r0,#0xc]          ;1399
0001f8  2806              CMP      r0,#6                 ;1399
0001fa  d00a              BEQ      |L33.530|
0001fc  6b20              LDR      r0,[r4,#0x30]         ;1400
0001fe  68c0              LDR      r0,[r0,#0xc]          ;1400
000200  2804              CMP      r0,#4                 ;1400
000202  d006              BEQ      |L33.530|
000204  6922              LDR      r2,[r4,#0x10]         ;1402
000206  8891              LDRH     r1,[r2,#4]            ;1402
000208  2300              MOVS     r3,#0                 ;1402
00020a  6810              LDR      r0,[r2,#0]            ;1402
00020c  2201              MOVS     r2,#1                 ;1402
00020e  f7fffffe          BL       GPIO_PinConfigure
                  |L33.530|
000212  6b20              LDR      r0,[r4,#0x30]         ;1404
000214  7ac0              LDRB     r0,[r0,#0xb]          ;1404
000216  f0400010          ORR      r0,r0,#0x10           ;1404
00021a  6b21              LDR      r1,[r4,#0x30]         ;1404
00021c  72c8              STRB     r0,[r1,#0xb]          ;1404
00021e  6860              LDR      r0,[r4,#4]            ;1407
000220  8a80              LDRH     r0,[r0,#0x14]         ;1407
000222  f0400001          ORR      r0,r0,#1              ;1407
000226  6861              LDR      r1,[r4,#4]            ;1407
000228  8288              STRH     r0,[r1,#0x14]         ;1407
00022a  6860              LDR      r0,[r4,#4]            ;1410
00022c  8a00              LDRH     r0,[r0,#0x10]         ;1410
00022e  f0400040          ORR      r0,r0,#0x40           ;1410
000232  6861              LDR      r1,[r4,#4]            ;1410
000234  8208              STRH     r0,[r1,#0x10]         ;1410
000236  6860              LDR      r0,[r4,#4]            ;1413
000238  8980              LDRH     r0,[r0,#0xc]          ;1413
00023a  f0400010          ORR      r0,r0,#0x10           ;1413
00023e  6861              LDR      r1,[r4,#4]            ;1413
000240  8188              STRH     r0,[r1,#0xc]          ;1413
000242  6b20              LDR      r0,[r4,#0x30]         ;1415
000244  7940              LDRB     r0,[r0,#5]            ;1415
000246  b118              CBZ      r0,|L33.592|
000248  6ae0              LDR      r0,[r4,#0x2c]         ;1415
00024a  b108              CBZ      r0,|L33.592|
00024c  2001              MOVS     r0,#1                 ;1415
00024e  e000              B        |L33.594|
                  |L33.592|
000250  2000              MOVS     r0,#0                 ;1415
                  |L33.594|
000252  b928              CBNZ     r0,|L33.608|
000254  6860              LDR      r0,[r4,#4]            ;1416
000256  8980              LDRH     r0,[r0,#0xc]          ;1416
000258  f0400020          ORR      r0,r0,#0x20           ;1416
00025c  6861              LDR      r1,[r4,#4]            ;1416
00025e  8188              STRH     r0,[r1,#0xc]          ;1416
                  |L33.608|
000260  6860              LDR      r0,[r4,#4]            ;1420
000262  8980              LDRH     r0,[r0,#0xc]          ;1420
000264  f0400004          ORR      r0,r0,#4              ;1420
000268  6861              LDR      r1,[r4,#4]            ;1420
00026a  8188              STRH     r0,[r1,#0xc]          ;1420
00026c  e01d              B        |L33.682|
                  |L33.622|
00026e  e7ff              B        |L33.624|
                  |L33.624|
000270  6860              LDR      r0,[r4,#4]            ;1424
000272  8980              LDRH     r0,[r0,#0xc]          ;1424
000274  f0200004          BIC      r0,r0,#4              ;1424
000278  6861              LDR      r1,[r4,#4]            ;1424
00027a  8188              STRH     r0,[r1,#0xc]          ;1424
00027c  6b20              LDR      r0,[r4,#0x30]         ;1426
00027e  7ac0              LDRB     r0,[r0,#0xb]          ;1426
000280  f0200010          BIC      r0,r0,#0x10           ;1426
000284  6b21              LDR      r1,[r4,#0x30]         ;1426
000286  72c8              STRB     r0,[r1,#0xb]          ;1426
000288  6b20              LDR      r0,[r4,#0x30]         ;1428
00028a  68c0              LDR      r0,[r0,#0xc]          ;1428
00028c  2806              CMP      r0,#6                 ;1428
00028e  d00c              BEQ      |L33.682|
000290  6b20              LDR      r0,[r4,#0x30]         ;1429
000292  68c0              LDR      r0,[r0,#0xc]          ;1429
000294  2804              CMP      r0,#4                 ;1429
000296  d008              BEQ      |L33.682|
000298  6920              LDR      r0,[r4,#0x10]         ;1431
00029a  b130              CBZ      r0,|L33.682|
00029c  6922              LDR      r2,[r4,#0x10]         ;1432
00029e  8891              LDRH     r1,[r2,#4]            ;1432
0002a0  2300              MOVS     r3,#0                 ;1432
0002a2  6810              LDR      r0,[r2,#0]            ;1432
0002a4  461a              MOV      r2,r3                 ;1432
0002a6  f7fffffe          BL       GPIO_PinConfigure
                  |L33.682|
0002aa  2000              MOVS     r0,#0                 ;1436
0002ac  e6b4              B        |L33.24|
                  |L33.686|
0002ae  bf00              NOP                            ;1437
0002b0  bf00              NOP                            ;1437
0002b2  6b20              LDR      r0,[r4,#0x30]         ;1441
0002b4  7940              LDRB     r0,[r0,#5]            ;1441
0002b6  b918              CBNZ     r0,|L33.704|
0002b8  6b60              LDR      r0,[r4,#0x34]         ;1441
0002ba  f8900021          LDRB     r0,[r0,#0x21]         ;1441
0002be  b110              CBZ      r0,|L33.710|
                  |L33.704|
0002c0  f06f0001          MVN      r0,#1                 ;1442
0002c4  e6a8              B        |L33.24|
                  |L33.710|
0002c6  6860              LDR      r0,[r4,#4]            ;1445
0002c8  8980              LDRH     r0,[r0,#0xc]          ;1445
0002ca  f0000008          AND      r0,r0,#8              ;1445
0002ce  b138              CBZ      r0,|L33.736|
0002d0  6860              LDR      r0,[r4,#4]            ;1445
0002d2  8800              LDRH     r0,[r0,#0]            ;1445
0002d4  f0000040          AND      r0,r0,#0x40           ;1445
0002d8  b910              CBNZ     r0,|L33.736|
0002da  f06f0001          MVN      r0,#1                 ;1446
0002de  e69b              B        |L33.24|
                  |L33.736|
0002e0  b2f8              UXTB     r0,r7                 ;1449
0002e2  2815              CMP      r0,#0x15              ;1449
0002e4  d272              BCS      |L33.972|
0002e6  e8dff000          TBB      [pc,r0]               ;1449
0002ea  c90b              DCB      0xc9,0x0b
0002ec  0e1d2025          DCB      0x0e,0x1d,0x20,0x25
0002f0  2ac9c9c9          DCB      0x2a,0xc9,0xc9,0xc9
0002f4  c9c9c9c9          DCB      0xc9,0xc9,0xc9,0xc9
0002f8  c9c9373b          DCB      0xc9,0xc9,0x37,0x3b
0002fc  697eb800          DCB      0x69,0x7e,0xb8,0x00
000300  2001              MOVS     r0,#1                 ;1451
000302  9002              STR      r0,[sp,#8]            ;1451
000304  e0bd              B        |L33.1154|
000306  7820              LDRB     r0,[r4,#0]            ;1454
000308  f3c00040          UBFX     r0,r0,#1,#1           ;1454
00030c  b120              CBZ      r0,|L33.792|
00030e  f4486800          ORR      r8,r8,#0x800          ;1456
000312  f4487880          ORR      r8,r8,#0x100          ;1459
000316  e002              B        |L33.798|
                  |L33.792|
000318  f06f0006          MVN      r0,#6                 ;1460
00031c  e67c              B        |L33.24|
                  |L33.798|
00031e  2002              MOVS     r0,#2                 ;1461
000320  9002              STR      r0,[sp,#8]            ;1461
000322  e0ae              B        |L33.1154|
000324  f06f0006          MVN      r0,#6                 ;1464
000328  e676              B        |L33.24|
00032a  f04b0b08          ORR      r11,r11,#8            ;1467
00032e  2004              MOVS     r0,#4                 ;1468
000330  9002              STR      r0,[sp,#8]            ;1468
000332  e0a6              B        |L33.1154|
000334  f04b0b02          ORR      r11,r11,#2            ;1472
000338  2005              MOVS     r0,#5                 ;1473
00033a  9002              STR      r0,[sp,#8]            ;1473
00033c  e0a1              B        |L33.1154|
00033e  7820              LDRB     r0,[r4,#0]            ;1476
000340  f3c01040          UBFX     r0,r0,#5,#1           ;1476
000344  b110              CBZ      r0,|L33.844|
000346  f04b0b20          ORR      r11,r11,#0x20         ;1478
00034a  e002              B        |L33.850|
                  |L33.844|
00034c  f06f0006          MVN      r0,#6                 ;1479
000350  e662              B        |L33.24|
                  |L33.850|
000352  2006              MOVS     r0,#6                 ;1480
000354  9002              STR      r0,[sp,#8]            ;1480
000356  e094              B        |L33.1154|
000358  6b61              LDR      r1,[r4,#0x34]         ;1485
00035a  834d              STRH     r5,[r1,#0x1a]         ;1485
00035c  2000              MOVS     r0,#0                 ;1486
00035e  e65b              B        |L33.24|
000360  6b20              LDR      r0,[r4,#0x30]         ;1490
000362  68c0              LDR      r0,[r0,#0xc]          ;1490
000364  2805              CMP      r0,#5                 ;1490
000366  d024              BEQ      |L33.946|
000368  b315              CBZ      r5,|L33.944|
00036a  6860              LDR      r0,[r4,#4]            ;1493
00036c  8a80              LDRH     r0,[r0,#0x14]         ;1493
00036e  f0400004          ORR      r0,r0,#4              ;1493
000372  6861              LDR      r1,[r4,#4]            ;1493
000374  8288              STRH     r0,[r1,#0x14]         ;1493
000376  f8d4a008          LDR      r10,[r4,#8]           ;1496
00037a  48fe              LDR      r0,|L33.1908|
00037c  fbb0fafa          UDIV     r10,r0,r10            ;1499
000380  2601              MOVS     r6,#1                 ;1500
000382  e005              B        |L33.912|
                  |L33.900|
000384  fb0af006          MUL      r0,r10,r6             ;1501
000388  42a8              CMP      r0,r5                 ;1501
00038a  d900              BLS      |L33.910|
00038c  e002              B        |L33.916|
                  |L33.910|
00038e  1c76              ADDS     r6,r6,#1              ;1500
                  |L33.912|
000390  2eff              CMP      r6,#0xff              ;1500
000392  d9f7              BLS      |L33.900|
                  |L33.916|
000394  bf00              NOP                            ;1501
000396  f5b67f80          CMP      r6,#0x100             ;1503
00039a  d102              BNE      |L33.930|
00039c  f04f30ff          MOV      r0,#0xffffffff        ;1503
0003a0  e63a              B        |L33.24|
                  |L33.930|
0003a2  6860              LDR      r0,[r4,#4]            ;1504
0003a4  8b00              LDRH     r0,[r0,#0x18]         ;1504
0003a6  f02000ff          BIC      r0,r0,#0xff           ;1504
0003aa  4330              ORRS     r0,r0,r6              ;1504
0003ac  6861              LDR      r1,[r4,#4]            ;1504
0003ae  8308              STRH     r0,[r1,#0x18]         ;1504
                  |L33.944|
0003b0  e002              B        |L33.952|
                  |L33.946|
0003b2  f04f30ff          MOV      r0,#0xffffffff        ;1506
0003b6  e62f              B        |L33.24|
                  |L33.952|
0003b8  2000              MOVS     r0,#0                 ;1507
0003ba  e62d              B        |L33.24|
0003bc  6b20              LDR      r0,[r4,#0x30]         ;1511
0003be  68c0              LDR      r0,[r0,#0xc]          ;1511
0003c0  2806              CMP      r0,#6                 ;1511
0003c2  d10b              BNE      |L33.988|
0003c4  2dff              CMP      r5,#0xff              ;1512
0003c6  d902              BLS      |L33.974|
0003c8  1fc0              SUBS     r0,r0,#7              ;1512
0003ca  e625              B        |L33.24|
                  |L33.972|
0003cc  e056              B        |L33.1148|
                  |L33.974|
0003ce  6860              LDR      r0,[r4,#4]            ;1514
0003d0  8b00              LDRH     r0,[r0,#0x18]         ;1514
0003d2  b2c0              UXTB     r0,r0                 ;1514
0003d4  4328              ORRS     r0,r0,r5              ;1514
0003d6  6861              LDR      r1,[r4,#4]            ;1514
0003d8  8308              STRH     r0,[r1,#0x18]         ;1514
0003da  e002              B        |L33.994|
                  |L33.988|
0003dc  f04f30ff          MOV      r0,#0xffffffff        ;1515
0003e0  e61a              B        |L33.24|
                  |L33.994|
0003e2  2000              MOVS     r0,#0                 ;1516
0003e4  e618              B        |L33.24|
0003e6  6b20              LDR      r0,[r4,#0x30]         ;1520
0003e8  68c0              LDR      r0,[r0,#0xc]          ;1520
0003ea  2806              CMP      r0,#6                 ;1520
0003ec  d130              BNE      |L33.1104|
0003ee  f8d4a008          LDR      r10,[r4,#8]           ;1522
0003f2  48e0              LDR      r0,|L33.1908|
0003f4  fbb0fafa          UDIV     r10,r0,r10            ;1525
0003f8  2601              MOVS     r6,#1                 ;1526
0003fa  e019              B        |L33.1072|
                  |L33.1020|
0003fc  fb0af006          MUL      r0,r10,r6             ;1528
000400  0040              LSLS     r0,r0,#1              ;1528
000402  2164              MOVS     r1,#0x64              ;1528
000404  4348              MULS     r0,r1,r0              ;1528
000406  eb051105          ADD      r1,r5,r5,LSL #4       ;1528
00040a  eb010141          ADD      r1,r1,r1,LSL #1       ;1528
00040e  ebb00f41          CMP      r0,r1,LSL #1          ;1528
000412  d20c              BCS      |L33.1070|
000414  fb0af006          MUL      r0,r10,r6             ;1529
000418  0040              LSLS     r0,r0,#1              ;1529
00041a  2164              MOVS     r1,#0x64              ;1529
00041c  4348              MULS     r0,r1,r0              ;1529
00041e  eb051105          ADD      r1,r5,r5,LSL #4       ;1529
000422  eb011145          ADD      r1,r1,r5,LSL #5       ;1529
000426  ebb00f41          CMP      r0,r1,LSL #1          ;1529
00042a  d900              BLS      |L33.1070|
00042c  e002              B        |L33.1076|
                  |L33.1070|
00042e  1c76              ADDS     r6,r6,#1              ;1526
                  |L33.1072|
000430  2e40              CMP      r6,#0x40              ;1526
000432  d3e3              BCC      |L33.1020|
                  |L33.1076|
000434  bf00              NOP                            ;1530
000436  2e40              CMP      r6,#0x40              ;1533
000438  d102              BNE      |L33.1088|
00043a  f04f30ff          MOV      r0,#0xffffffff        ;1533
00043e  e5eb              B        |L33.24|
                  |L33.1088|
000440  6860              LDR      r0,[r4,#4]            ;1535
000442  8b00              LDRH     r0,[r0,#0x18]         ;1535
000444  f02000ff          BIC      r0,r0,#0xff           ;1535
000448  4330              ORRS     r0,r0,r6              ;1535
00044a  6861              LDR      r1,[r4,#4]            ;1535
00044c  8308              STRH     r0,[r1,#0x18]         ;1535
00044e  e002              B        |L33.1110|
                  |L33.1104|
000450  f04f30ff          MOV      r0,#0xffffffff        ;1536
000454  e5e0              B        |L33.24|
                  |L33.1110|
000456  2000              MOVS     r0,#0                 ;1537
000458  e5de              B        |L33.24|
00045a  6b20              LDR      r0,[r4,#0x30]         ;1541
00045c  68c0              LDR      r0,[r0,#0xc]          ;1541
00045e  2806              CMP      r0,#6                 ;1541
000460  d107              BNE      |L33.1138|
000462  b14d              CBZ      r5,|L33.1144|
000464  6860              LDR      r0,[r4,#4]            ;1543
000466  8a80              LDRH     r0,[r0,#0x14]         ;1543
000468  f0400010          ORR      r0,r0,#0x10           ;1543
00046c  6861              LDR      r1,[r4,#4]            ;1543
00046e  8288              STRH     r0,[r1,#0x14]         ;1543
000470  e002              B        |L33.1144|
                  |L33.1138|
000472  f04f30ff          MOV      r0,#0xffffffff        ;1544
000476  e5cf              B        |L33.24|
                  |L33.1144|
000478  2000              MOVS     r0,#0                 ;1545
00047a  e5cd              B        |L33.24|
                  |L33.1148|
00047c  f06f0003          MVN      r0,#3                 ;1548
000480  e5ca              B        |L33.24|
                  |L33.1154|
000482  bf00              NOP                            ;1452
000484  f40760e0          AND      r0,r7,#0x700          ;1552
000488  b160              CBZ      r0,|L33.1188|
00048a  f5b07f80          CMP      r0,#0x100             ;1552
00048e  d013              BEQ      |L33.1208|
000490  f5b06fe0          CMP      r0,#0x700             ;1552
000494  d11d              BNE      |L33.1234|
000496  f4075040          AND      r0,r7,#0x3000         ;1554
00049a  b910              CBNZ     r0,|L33.1186|
00049c  f06f0008          MVN      r0,#8                 ;1555
0004a0  e5ba              B        |L33.24|
                  |L33.1186|
0004a2  e019              B        |L33.1240|
                  |L33.1188|
0004a4  f4075040          AND      r0,r7,#0x3000         ;1561
0004a8  b128              CBZ      r0,|L33.1206|
0004aa  f0480820          ORR      r8,r8,#0x20           ;1565
0004ae  9800              LDR      r0,[sp,#0]            ;1568
0004b0  f4405080          ORR      r0,r0,#0x1000         ;1568
0004b4  9000              STR      r0,[sp,#0]            ;1568
                  |L33.1206|
0004b6  e00f              B        |L33.1240|
                  |L33.1208|
0004b8  f4075040          AND      r0,r7,#0x3000         ;1572
0004bc  b110              CBZ      r0,|L33.1220|
0004be  f06f0008          MVN      r0,#8                 ;1573
0004c2  e5a9              B        |L33.24|
                  |L33.1220|
0004c4  f0480820          ORR      r8,r8,#0x20           ;1577
0004c8  9800              LDR      r0,[sp,#0]            ;1580
0004ca  f4405080          ORR      r0,r0,#0x1000         ;1580
0004ce  9000              STR      r0,[sp,#0]            ;1580
0004d0  e002              B        |L33.1240|
                  |L33.1234|
0004d2  f06f0008          MVN      r0,#8                 ;1582
0004d6  e59f              B        |L33.24|
                  |L33.1240|
0004d8  bf00              NOP                            ;1559
0004da  f4075040          AND      r0,r7,#0x3000         ;1586
0004de  b130              CBZ      r0,|L33.1262|
0004e0  f5b05f80          CMP      r0,#0x1000            ;1586
0004e4  d004              BEQ      |L33.1264|
0004e6  f5b05f00          CMP      r0,#0x2000            ;1586
0004ea  d10b              BNE      |L33.1284|
0004ec  e005              B        |L33.1274|
                  |L33.1262|
0004ee  e00c              B        |L33.1290|
                  |L33.1264|
0004f0  9800              LDR      r0,[sp,#0]            ;1588
0004f2  f4406080          ORR      r0,r0,#0x400          ;1588
0004f6  9000              STR      r0,[sp,#0]            ;1588
0004f8  e007              B        |L33.1290|
                  |L33.1274|
0004fa  9800              LDR      r0,[sp,#0]            ;1589
0004fc  f44060c0          ORR      r0,r0,#0x600          ;1589
000500  9000              STR      r0,[sp,#0]            ;1589
000502  e002              B        |L33.1290|
                  |L33.1284|
000504  f06f0009          MVN      r0,#9                 ;1591
000508  e586              B        |L33.24|
                  |L33.1290|
00050a  bf00              NOP                            ;1587
00050c  f4074040          AND      r0,r7,#0xc000         ;1595
000510  b148              CBZ      r0,|L33.1318|
000512  f5b04f80          CMP      r0,#0x4000            ;1595
000516  d007              BEQ      |L33.1320|
000518  f5b04f00          CMP      r0,#0x8000            ;1595
00051c  d007              BEQ      |L33.1326|
00051e  f5b04f40          CMP      r0,#0xc000            ;1595
000522  d10a              BNE      |L33.1338|
000524  e006              B        |L33.1332|
                  |L33.1318|
000526  e00b              B        |L33.1344|
                  |L33.1320|
000528  f4485800          ORR      r8,r8,#0x2000         ;1597
00052c  e008              B        |L33.1344|
                  |L33.1326|
00052e  f4485840          ORR      r8,r8,#0x3000         ;1598
000532  e005              B        |L33.1344|
                  |L33.1332|
000534  f4485880          ORR      r8,r8,#0x1000         ;1600
000538  e002              B        |L33.1344|
                  |L33.1338|
00053a  f06f000a          MVN      r0,#0xa               ;1601
00053e  e56b              B        |L33.24|
                  |L33.1344|
000540  bf00              NOP                            ;1596
000542  f4073040          AND      r0,r7,#0x30000        ;1605
000546  b148              CBZ      r0,|L33.1372|
000548  f5b03f80          CMP      r0,#0x10000           ;1605
00054c  d009              BEQ      |L33.1378|
00054e  f5b03f00          CMP      r0,#0x20000           ;1605
000552  d013              BEQ      |L33.1404|
000554  f5b03f40          CMP      r0,#0x30000           ;1605
000558  d12e              BNE      |L33.1464|
00055a  e01c              B        |L33.1430|
                  |L33.1372|
00055c  f04f0900          MOV      r9,#0                 ;1607
000560  e02d              B        |L33.1470|
                  |L33.1378|
000562  7820              LDRB     r0,[r4,#0]            ;1610
000564  f3c010c0          UBFX     r0,r0,#7,#1           ;1610
000568  b120              CBZ      r0,|L33.1396|
00056a  f44f3980          MOV      r9,#0x10000           ;1611
00056e  f44b7b80          ORR      r11,r11,#0x100        ;1613
000572  e002              B        |L33.1402|
                  |L33.1396|
000574  f06f000b          MVN      r0,#0xb               ;1615
000578  e54e              B        |L33.24|
                  |L33.1402|
00057a  e020              B        |L33.1470|
                  |L33.1404|
00057c  8820              LDRH     r0,[r4,#0]            ;1618
00057e  f3c02000          UBFX     r0,r0,#8,#1           ;1618
000582  b120              CBZ      r0,|L33.1422|
000584  f44f3900          MOV      r9,#0x20000           ;1619
000588  f44b6bc0          ORR      r11,r11,#0x600        ;1621
00058c  e002              B        |L33.1428|
                  |L33.1422|
00058e  f06f000b          MVN      r0,#0xb               ;1623
000592  e541              B        |L33.24|
                  |L33.1428|
000594  e013              B        |L33.1470|
                  |L33.1430|
000596  7820              LDRB     r0,[r4,#0]            ;1626
000598  f3c010c0          UBFX     r0,r0,#7,#1           ;1626
00059c  b140              CBZ      r0,|L33.1456|
00059e  8820              LDRH     r0,[r4,#0]            ;1627
0005a0  f3c02000          UBFX     r0,r0,#8,#1           ;1627
0005a4  b120              CBZ      r0,|L33.1456|
0005a6  f44f3940          MOV      r9,#0x30000           ;1628
0005aa  f44b6be0          ORR      r11,r11,#0x700        ;1630
0005ae  e002              B        |L33.1462|
                  |L33.1456|
0005b0  f06f000b          MVN      r0,#0xb               ;1631
0005b4  e530              B        |L33.24|
                  |L33.1462|
0005b6  e002              B        |L33.1470|
                  |L33.1464|
0005b8  f06f000b          MVN      r0,#0xb               ;1633
0005bc  e52c              B        |L33.24|
                  |L33.1470|
0005be  bf00              NOP                            ;1608
0005c0  9802              LDR      r0,[sp,#8]            ;1637
0005c2  2802              CMP      r0,#2                 ;1637
0005c4  d11d              BNE      |L33.1538|
0005c6  f4072080          AND      r0,r7,#0x40000        ;1640
0005ca  b118              CBZ      r0,|L33.1492|
0005cc  f5b02f80          CMP      r0,#0x40000           ;1640
0005d0  d104              BNE      |L33.1500|
0005d2  e000              B        |L33.1494|
                  |L33.1492|
0005d4  e005              B        |L33.1506|
                  |L33.1494|
0005d6  f4486880          ORR      r8,r8,#0x400          ;1644
0005da  e002              B        |L33.1506|
                  |L33.1500|
0005dc  f06f000c          MVN      r0,#0xc               ;1646
0005e0  e51a              B        |L33.24|
                  |L33.1506|
0005e2  bf00              NOP                            ;1642
0005e4  f4072000          AND      r0,r7,#0x80000        ;1650
0005e8  b118              CBZ      r0,|L33.1522|
0005ea  f5b02f00          CMP      r0,#0x80000           ;1650
0005ee  d104              BNE      |L33.1530|
0005f0  e000              B        |L33.1524|
                  |L33.1522|
0005f2  e005              B        |L33.1536|
                  |L33.1524|
0005f4  f4487800          ORR      r8,r8,#0x200          ;1654
0005f8  e002              B        |L33.1536|
                  |L33.1530|
0005fa  f06f000d          MVN      r0,#0xd               ;1656
0005fe  e50b              B        |L33.24|
                  |L33.1536|
000600  bf00              NOP                            ;1652
                  |L33.1538|
000602  68a0              LDR      r0,[r4,#8]            ;1661
000604  eb0001c0          ADD      r1,r0,r0,LSL #3       ;1661
000608  eb011000          ADD      r0,r1,r0,LSL #4       ;1661
00060c  00a9              LSLS     r1,r5,#2              ;1661
00060e  fbb0f0f1          UDIV     r0,r0,r1              ;1661
000612  2164              MOVS     r1,#0x64              ;1661
000614  fbb0f1f1          UDIV     r1,r0,r1              ;1661
000618  68a0              LDR      r0,[r4,#8]            ;1661
00061a  eb0002c0          ADD      r2,r0,r0,LSL #3       ;1661
00061e  eb021000          ADD      r0,r2,r0,LSL #4       ;1661
000622  00aa              LSLS     r2,r5,#2              ;1661
000624  fbb0f0f2          UDIV     r0,r0,r2              ;1661
000628  68a2              LDR      r2,[r4,#8]            ;1661
00062a  eb0203c2          ADD      r3,r2,r2,LSL #3       ;1661
00062e  eb031202          ADD      r2,r3,r2,LSL #4       ;1661
000632  00ab              LSLS     r3,r5,#2              ;1661
000634  fbb2f2f3          UDIV     r2,r2,r3              ;1661
000638  2364              MOVS     r3,#0x64              ;1661
00063a  fbb2f2f3          UDIV     r2,r2,r3              ;1661
00063e  eb0203c2          ADD      r3,r2,r2,LSL #3       ;1661
000642  eb031202          ADD      r2,r3,r2,LSL #4       ;1661
000646  eba00082          SUB      r0,r0,r2,LSL #2       ;1661
00064a  2232              MOVS     r2,#0x32              ;1661
00064c  eb021000          ADD      r0,r2,r0,LSL #4       ;1661
000650  2264              MOVS     r2,#0x64              ;1661
000652  fbb0faf2          UDIV     r10,r0,r2             ;1661
000656  f3611a1f          BFI      r10,r1,#4,#28         ;1661
00065a  68a0              LDR      r0,[r4,#8]            ;1662
00065c  0100              LSLS     r0,r0,#4              ;1662
00065e  fa1ff18a          UXTH     r1,r10                ;1662
000662  fbb0f0f1          UDIV     r0,r0,r1              ;1662
000666  0900              LSRS     r0,r0,#4              ;1662
000668  9001              STR      r0,[sp,#4]            ;1662
00066a  2164              MOVS     r1,#0x64              ;1664
00066c  9801              LDR      r0,[sp,#4]            ;1664
00066e  4348              MULS     r0,r1,r0              ;1664
000670  eb051105          ADD      r1,r5,r5,LSL #4       ;1664
000674  eb010141          ADD      r1,r1,r1,LSL #1       ;1664
000678  ebb00f41          CMP      r0,r1,LSL #1          ;1664
00067c  d209              BCS      |L33.1682|
00067e  2164              MOVS     r1,#0x64              ;1664
000680  9801              LDR      r0,[sp,#4]            ;1664
000682  4348              MULS     r0,r1,r0              ;1664
000684  eb051105          ADD      r1,r5,r5,LSL #4       ;1664
000688  eb011145          ADD      r1,r1,r5,LSL #5       ;1664
00068c  ebb00f41          CMP      r0,r1,LSL #1          ;1664
000690  d802              BHI      |L33.1688|
                  |L33.1682|
000692  f06f0007          MVN      r0,#7                 ;1665
000696  e4bf              B        |L33.24|
                  |L33.1688|
000698  6860              LDR      r0,[r4,#4]            ;1669
00069a  8980              LDRH     r0,[r0,#0xc]          ;1669
00069c  f4205000          BIC      r0,r0,#0x2000         ;1669
0006a0  6861              LDR      r1,[r4,#4]            ;1669
0006a2  8188              STRH     r0,[r1,#0xc]          ;1669
0006a4  6861              LDR      r1,[r4,#4]            ;1672
0006a6  f8a1a008          STRH     r10,[r1,#8]           ;1672
0006aa  9802              LDR      r0,[sp,#8]            ;1675
0006ac  6b21              LDR      r1,[r4,#0x30]         ;1675
0006ae  60c8              STR      r0,[r1,#0xc]          ;1675
0006b0  6b20              LDR      r0,[r4,#0x30]         ;1678
0006b2  f8c09010          STR      r9,[r0,#0x10]         ;1678
0006b6  6b20              LDR      r0,[r4,#0x30]         ;1681
0006b8  68c0              LDR      r0,[r0,#0xc]          ;1681
0006ba  2806              CMP      r0,#6                 ;1681
0006bc  d109              BNE      |L33.1746|
0006be  68e0              LDR      r0,[r4,#0xc]          ;1684
0006c0  b130              CBZ      r0,|L33.1744|
0006c2  68e2              LDR      r2,[r4,#0xc]          ;1685
0006c4  8891              LDRH     r1,[r2,#4]            ;1685
0006c6  2303              MOVS     r3,#3                 ;1685
0006c8  6810              LDR      r0,[r2,#0]            ;1685
0006ca  2202              MOVS     r2,#2                 ;1685
0006cc  f7fffffe          BL       GPIO_PinConfigure
                  |L33.1744|
0006d0  e018              B        |L33.1796|
                  |L33.1746|
0006d2  6b20              LDR      r0,[r4,#0x30]         ;1690
0006d4  7ac0              LDRB     r0,[r0,#0xb]          ;1690
0006d6  f0000008          AND      r0,r0,#8              ;1690
0006da  b148              CBZ      r0,|L33.1776|
0006dc  68e0              LDR      r0,[r4,#0xc]          ;1692
0006de  b180              CBZ      r0,|L33.1794|
0006e0  68e2              LDR      r2,[r4,#0xc]          ;1693
0006e2  8891              LDRH     r1,[r2,#4]            ;1693
0006e4  2303              MOVS     r3,#3                 ;1693
0006e6  6810              LDR      r0,[r2,#0]            ;1693
0006e8  2202              MOVS     r2,#2                 ;1693
0006ea  f7fffffe          BL       GPIO_PinConfigure
0006ee  e008              B        |L33.1794|
                  |L33.1776|
0006f0  68e0              LDR      r0,[r4,#0xc]          ;1697
0006f2  b130              CBZ      r0,|L33.1794|
0006f4  68e2              LDR      r2,[r4,#0xc]          ;1698
0006f6  8891              LDRH     r1,[r2,#4]            ;1698
0006f8  2300              MOVS     r3,#0                 ;1698
0006fa  6810              LDR      r0,[r2,#0]            ;1698
0006fc  461a              MOV      r2,r3                 ;1698
0006fe  f7fffffe          BL       GPIO_PinConfigure
                  |L33.1794|
000702  bf00              NOP                            ;1681
                  |L33.1796|
000704  bf00              NOP                            ;1687
000706  6b20              LDR      r0,[r4,#0x30]         ;1704
000708  68c0              LDR      r0,[r0,#0xc]          ;1704
00070a  2804              CMP      r0,#4                 ;1704
00070c  d002              BEQ      |L33.1812|
00070e  2806              CMP      r0,#6                 ;1704
000710  d10b              BNE      |L33.1834|
000712  e000              B        |L33.1814|
                  |L33.1812|
000714  bf00              NOP                            ;1706
                  |L33.1814|
000716  6920              LDR      r0,[r4,#0x10]         ;1708
000718  b130              CBZ      r0,|L33.1832|
00071a  6922              LDR      r2,[r4,#0x10]         ;1709
00071c  8891              LDRH     r1,[r2,#4]            ;1709
00071e  2300              MOVS     r3,#0                 ;1709
000720  6810              LDR      r0,[r2,#0]            ;1709
000722  461a              MOV      r2,r3                 ;1709
000724  f7fffffe          BL       GPIO_PinConfigure
                  |L33.1832|
000728  e018              B        |L33.1884|
                  |L33.1834|
00072a  6b20              LDR      r0,[r4,#0x30]         ;1714
00072c  7ac0              LDRB     r0,[r0,#0xb]          ;1714
00072e  f0000010          AND      r0,r0,#0x10           ;1714
000732  b148              CBZ      r0,|L33.1864|
000734  6920              LDR      r0,[r4,#0x10]         ;1716
000736  b180              CBZ      r0,|L33.1882|
000738  6922              LDR      r2,[r4,#0x10]         ;1717
00073a  8891              LDRH     r1,[r2,#4]            ;1717
00073c  2300              MOVS     r3,#0                 ;1717
00073e  6810              LDR      r0,[r2,#0]            ;1717
000740  2201              MOVS     r2,#1                 ;1717
000742  f7fffffe          BL       GPIO_PinConfigure
000746  e008              B        |L33.1882|
                  |L33.1864|
000748  6920              LDR      r0,[r4,#0x10]         ;1721
00074a  b130              CBZ      r0,|L33.1882|
00074c  6922              LDR      r2,[r4,#0x10]         ;1722
00074e  8891              LDRH     r1,[r2,#4]            ;1722
000750  2300              MOVS     r3,#0                 ;1722
000752  6810              LDR      r0,[r2,#0]            ;1722
000754  461a              MOV      r2,r3                 ;1722
000756  f7fffffe          BL       GPIO_PinConfigure
                  |L33.1882|
00075a  bf00              NOP                            ;1725
                  |L33.1884|
00075c  bf00              NOP                            ;1711
00075e  6960              LDR      r0,[r4,#0x14]         ;1729
000760  b1d0              CBZ      r0,|L33.1944|
000762  6b20              LDR      r0,[r4,#0x30]         ;1730
000764  68c0              LDR      r0,[r0,#0xc]          ;1730
000766  2802              CMP      r0,#2                 ;1730
000768  d002              BEQ      |L33.1904|
00076a  2806              CMP      r0,#6                 ;1730
00076c  d10b              BNE      |L33.1926|
00076e  bf00              NOP                            ;1732
                  |L33.1904|
000770  6962              LDR      r2,[r4,#0x14]         ;1734
000772  e001              B        |L33.1912|
                  |L33.1908|
                          DCD      0x3b9aca00
                  |L33.1912|
000778  8891              LDRH     r1,[r2,#4]            ;1734
00077a  2303              MOVS     r3,#3                 ;1734
00077c  6810              LDR      r0,[r2,#0]            ;1734
00077e  2202              MOVS     r2,#2                 ;1734
000780  f7fffffe          BL       GPIO_PinConfigure
000784  e007              B        |L33.1942|
                  |L33.1926|
000786  6962              LDR      r2,[r4,#0x14]         ;1739
000788  8891              LDRH     r1,[r2,#4]            ;1739
00078a  2300              MOVS     r3,#0                 ;1739
00078c  6810              LDR      r0,[r2,#0]            ;1739
00078e  461a              MOV      r2,r3                 ;1739
000790  f7fffffe          BL       GPIO_PinConfigure
000794  bf00              NOP                            ;1730
                  |L33.1942|
000796  bf00              NOP                            ;1735
                  |L33.1944|
000798  69a0              LDR      r0,[r4,#0x18]         ;1744
00079a  b1a0              CBZ      r0,|L33.1990|
00079c  f5b93f80          CMP      r9,#0x10000           ;1745
0007a0  d002              BEQ      |L33.1960|
0007a2  f5b93f40          CMP      r9,#0x30000           ;1746
0007a6  d107              BNE      |L33.1976|
                  |L33.1960|
0007a8  69a2              LDR      r2,[r4,#0x18]         ;1748
0007aa  8891              LDRH     r1,[r2,#4]            ;1748
0007ac  2303              MOVS     r3,#3                 ;1748
0007ae  6810              LDR      r0,[r2,#0]            ;1748
0007b0  2202              MOVS     r2,#2                 ;1748
0007b2  f7fffffe          BL       GPIO_PinConfigure
0007b6  e006              B        |L33.1990|
                  |L33.1976|
0007b8  69a2              LDR      r2,[r4,#0x18]         ;1751
0007ba  8891              LDRH     r1,[r2,#4]            ;1751
0007bc  2300              MOVS     r3,#0                 ;1751
0007be  6810              LDR      r0,[r2,#0]            ;1751
0007c0  461a              MOV      r2,r3                 ;1751
0007c2  f7fffffe          BL       GPIO_PinConfigure
                  |L33.1990|
0007c6  69e0              LDR      r0,[r4,#0x1c]         ;1756
0007c8  b1a0              CBZ      r0,|L33.2036|
0007ca  f5b93f00          CMP      r9,#0x20000           ;1757
0007ce  d002              BEQ      |L33.2006|
0007d0  f5b93f40          CMP      r9,#0x30000           ;1758
0007d4  d107              BNE      |L33.2022|
                  |L33.2006|
0007d6  69e2              LDR      r2,[r4,#0x1c]         ;1760
0007d8  8891              LDRH     r1,[r2,#4]            ;1760
0007da  2300              MOVS     r3,#0                 ;1760
0007dc  6810              LDR      r0,[r2,#0]            ;1760
0007de  2201              MOVS     r2,#1                 ;1760
0007e0  f7fffffe          BL       GPIO_PinConfigure
0007e4  e006              B        |L33.2036|
                  |L33.2022|
0007e6  69e2              LDR      r2,[r4,#0x1c]         ;1763
0007e8  8891              LDRH     r1,[r2,#4]            ;1763
0007ea  2300              MOVS     r3,#0                 ;1763
0007ec  6810              LDR      r0,[r2,#0]            ;1763
0007ee  2201              MOVS     r2,#1                 ;1763
0007f0  f7fffffe          BL       GPIO_PinConfigure
                  |L33.2036|
0007f4  9800              LDR      r0,[sp,#0]            ;1768
0007f6  6861              LDR      r1,[r4,#4]            ;1768
0007f8  8188              STRH     r0,[r1,#0xc]          ;1768
0007fa  6861              LDR      r1,[r4,#4]            ;1769
0007fc  f8a18010          STRH     r8,[r1,#0x10]         ;1769
000800  6861              LDR      r1,[r4,#4]            ;1770
000802  f8a1b014          STRH     r11,[r1,#0x14]        ;1770
000806  6860              LDR      r0,[r4,#4]            ;1773
000808  8980              LDRH     r0,[r0,#0xc]          ;1773
00080a  f4405000          ORR      r0,r0,#0x2000         ;1773
00080e  6861              LDR      r1,[r4,#4]            ;1773
000810  8188              STRH     r0,[r1,#0xc]          ;1773
000812  6b20              LDR      r0,[r4,#0x30]         ;1776
000814  7ac0              LDRB     r0,[r0,#0xb]          ;1776
000816  f0400004          ORR      r0,r0,#4              ;1776
00081a  6b21              LDR      r1,[r4,#0x30]         ;1776
00081c  72c8              STRB     r0,[r1,#0xb]          ;1776
00081e  2000              MOVS     r0,#0                 ;1778
000820  e410              B        |L33.68|
;;;1780   
                          ENDP


                          AREA ||i.USART_GetCapabilities||, CODE, READONLY, ALIGN=1

                  USART_GetCapabilities PROC
;;;740    */
;;;741    static ARM_USART_CAPABILITIES USART_GetCapabilities (const USART_RESOURCES *usart) {
000000  4601              MOV      r1,r0
;;;742      return usart->capabilities;
000002  6808              LDR      r0,[r1,#0]
;;;743    }
000004  4770              BX       lr
;;;744    
                          ENDP


                          AREA ||i.USART_GetModemStatus||, CODE, READONLY, ALIGN=1

                  USART_GetModemStatus PROC
;;;1852   */
;;;1853   static ARM_USART_MODEM_STATUS USART_GetModemStatus (const USART_RESOURCES *usart) {
000000  b50c              PUSH     {r2,r3,lr}
000002  4601              MOV      r1,r0
;;;1854     ARM_USART_MODEM_STATUS modem_status;
;;;1855   
;;;1856     modem_status.cts = 0U;
000004  9801              LDR      r0,[sp,#4]
000006  f0200001          BIC      r0,r0,#1
00000a  9001              STR      r0,[sp,#4]
;;;1857     if ((usart->info->flow_control == ARM_USART_FLOW_CONTROL_NONE) ||
00000c  6b08              LDR      r0,[r1,#0x30]
00000e  6900              LDR      r0,[r0,#0x10]
000010  b120              CBZ      r0,|L35.28|
;;;1858         (usart->info->flow_control == ARM_USART_FLOW_CONTROL_RTS)) {
000012  6b08              LDR      r0,[r1,#0x30]
000014  6900              LDR      r0,[r0,#0x10]
000016  f5b03f80          CMP      r0,#0x10000
00001a  d10e              BNE      |L35.58|
                  |L35.28|
;;;1859       if (usart->io.cts) {
00001c  69c8              LDR      r0,[r1,#0x1c]
00001e  b160              CBZ      r0,|L35.58|
;;;1860         if (GPIO_PinRead (usart->io.cts->port, usart->io.cts->pin) == 0U) {
000020  69cb              LDR      r3,[r1,#0x1c]
000022  8898              LDRH     r0,[r3,#4]
000024  681a              LDR      r2,[r3,#0]
000026  6893              LDR      r3,[r2,#8]
000028  40c3              LSRS     r3,r3,r0
00002a  f0030301          AND      r3,r3,#1
00002e  b923              CBNZ     r3,|L35.58|
;;;1861           modem_status.cts = 1U;
000030  9801              LDR      r0,[sp,#4]
000032  f0200001          BIC      r0,r0,#1
000036  1c40              ADDS     r0,r0,#1
000038  9001              STR      r0,[sp,#4]
                  |L35.58|
;;;1862         }
;;;1863       }
;;;1864     }
;;;1865     modem_status.dsr = 0U;
00003a  9801              LDR      r0,[sp,#4]
00003c  f0200002          BIC      r0,r0,#2
000040  9001              STR      r0,[sp,#4]
;;;1866     modem_status.ri  = 0U;
000042  9801              LDR      r0,[sp,#4]
000044  f0200008          BIC      r0,r0,#8
000048  9001              STR      r0,[sp,#4]
;;;1867     modem_status.dcd = 0U;
00004a  9801              LDR      r0,[sp,#4]
00004c  f0200004          BIC      r0,r0,#4
000050  9001              STR      r0,[sp,#4]
;;;1868   
;;;1869     return modem_status;
000052  9801              LDR      r0,[sp,#4]
000054  9a00              LDR      r2,[sp,#0]
000056  f3600200          BFI      r2,r0,#0,#1
00005a  9200              STR      r2,[sp,#0]
00005c  9801              LDR      r0,[sp,#4]
00005e  0842              LSRS     r2,r0,#1
000060  9800              LDR      r0,[sp,#0]
000062  f3620041          BFI      r0,r2,#1,#1
000066  9000              STR      r0,[sp,#0]
000068  9801              LDR      r0,[sp,#4]
00006a  0882              LSRS     r2,r0,#2
00006c  9800              LDR      r0,[sp,#0]
00006e  f3620082          BFI      r0,r2,#2,#1
000072  9000              STR      r0,[sp,#0]
000074  9801              LDR      r0,[sp,#4]
000076  08c2              LSRS     r2,r0,#3
000078  9800              LDR      r0,[sp,#0]
00007a  f36200c3          BFI      r0,r2,#3,#1
00007e  9000              STR      r0,[sp,#0]
000080  9801              LDR      r0,[sp,#4]
000082  0902              LSRS     r2,r0,#4
000084  9800              LDR      r0,[sp,#0]
000086  f362101f          BFI      r0,r2,#4,#28
00008a  9000              STR      r0,[sp,#0]
00008c  9800              LDR      r0,[sp,#0]
;;;1870   }
00008e  bd0c              POP      {r2,r3,pc}
;;;1871   
                          ENDP


                          AREA ||i.USART_GetRxCount||, CODE, READONLY, ALIGN=1

                  USART_GetRxCount PROC
;;;1236   */
;;;1237   static uint32_t USART_GetRxCount (const USART_RESOURCES *usart) {
000000  4601              MOV      r1,r0
;;;1238   
;;;1239   #ifdef __USART_DMA_RX
;;;1240     if (usart->dma_rx) {
000002  6ac8              LDR      r0,[r1,#0x2c]
000004  b130              CBZ      r0,|L36.20|
;;;1241       return (usart->xfer->rx_num - DMA_ChannelTransferItemCount(usart->dma_rx->instance));
000006  6aca              LDR      r2,[r1,#0x2c]
000008  6810              LDR      r0,[r2,#0]
00000a  6842              LDR      r2,[r0,#4]
00000c  6b48              LDR      r0,[r1,#0x34]
00000e  6800              LDR      r0,[r0,#0]
000010  1a80              SUBS     r0,r0,r2
                  |L36.18|
;;;1242     } else
;;;1243   #endif
;;;1244     {
;;;1245       return usart->xfer->rx_cnt;
;;;1246     }
;;;1247   }
000012  4770              BX       lr
                  |L36.20|
000014  6b48              LDR      r0,[r1,#0x34]         ;1245
000016  6900              LDR      r0,[r0,#0x10]         ;1245
000018  e7fb              B        |L36.18|
;;;1248   
                          ENDP


                          AREA ||i.USART_GetStatus||, CODE, READONLY, ALIGN=1

                  USART_GetStatus PROC
;;;1786   */
;;;1787   static ARM_USART_STATUS USART_GetStatus (const USART_RESOURCES *usart) {
000000  b50c              PUSH     {r2,r3,lr}
000002  4601              MOV      r1,r0
;;;1788     ARM_USART_STATUS status;
;;;1789   
;;;1790     if (usart->xfer->send_active != 0U) {
000004  6b48              LDR      r0,[r1,#0x34]
000006  f8900021          LDRB     r0,[r0,#0x21]
00000a  b128              CBZ      r0,|L37.24|
;;;1791       status.tx_busy        = 1U;
00000c  9801              LDR      r0,[sp,#4]
00000e  f0200001          BIC      r0,r0,#1
000012  1c40              ADDS     r0,r0,#1
000014  9001              STR      r0,[sp,#4]
000016  e008              B        |L37.42|
                  |L37.24|
;;;1792     } else {
;;;1793       status.tx_busy        = ((usart->reg->SR & USART_SR_TC) ? (0U) : (1U));
000018  6848              LDR      r0,[r1,#4]
00001a  8800              LDRH     r0,[r0,#0]
00001c  2201              MOVS     r2,#1
00001e  ea221290          BIC      r2,r2,r0,LSR #6
000022  9801              LDR      r0,[sp,#4]
000024  f3620000          BFI      r0,r2,#0,#1
000028  9001              STR      r0,[sp,#4]
                  |L37.42|
;;;1794     }
;;;1795     status.rx_busy          = usart->info->status.rx_busy;
00002a  6b08              LDR      r0,[r1,#0x30]
00002c  7942              LDRB     r2,[r0,#5]
00002e  9801              LDR      r0,[sp,#4]
000030  f3620041          BFI      r0,r2,#1,#1
000034  9001              STR      r0,[sp,#4]
;;;1796     status.tx_underflow     = usart->info->status.tx_underflow;
000036  6b08              LDR      r0,[r1,#0x30]
000038  7982              LDRB     r2,[r0,#6]
00003a  9801              LDR      r0,[sp,#4]
00003c  f3620082          BFI      r0,r2,#2,#1
000040  9001              STR      r0,[sp,#4]
;;;1797     status.rx_overflow      = usart->info->status.rx_overflow;
000042  6b08              LDR      r0,[r1,#0x30]
000044  79c2              LDRB     r2,[r0,#7]
000046  9801              LDR      r0,[sp,#4]
000048  f36200c3          BFI      r0,r2,#3,#1
00004c  9001              STR      r0,[sp,#4]
;;;1798     status.rx_break         = usart->info->status.rx_break;
00004e  6b08              LDR      r0,[r1,#0x30]
000050  7a02              LDRB     r2,[r0,#8]
000052  9801              LDR      r0,[sp,#4]
000054  f3621004          BFI      r0,r2,#4,#1
000058  9001              STR      r0,[sp,#4]
;;;1799     status.rx_framing_error = usart->info->status.rx_framing_error;
00005a  6b08              LDR      r0,[r1,#0x30]
00005c  7a42              LDRB     r2,[r0,#9]
00005e  9801              LDR      r0,[sp,#4]
000060  f3621045          BFI      r0,r2,#5,#1
000064  9001              STR      r0,[sp,#4]
;;;1800     status.rx_parity_error  = usart->info->status.rx_parity_error;
000066  6b08              LDR      r0,[r1,#0x30]
000068  7a82              LDRB     r2,[r0,#0xa]
00006a  9801              LDR      r0,[sp,#4]
00006c  f3621086          BFI      r0,r2,#6,#1
000070  9001              STR      r0,[sp,#4]
;;;1801   
;;;1802     return status;
000072  9801              LDR      r0,[sp,#4]
000074  9a00              LDR      r2,[sp,#0]
000076  f3600200          BFI      r2,r0,#0,#1
00007a  9200              STR      r2,[sp,#0]
00007c  9801              LDR      r0,[sp,#4]
00007e  0842              LSRS     r2,r0,#1
000080  9800              LDR      r0,[sp,#0]
000082  f3620041          BFI      r0,r2,#1,#1
000086  9000              STR      r0,[sp,#0]
000088  9801              LDR      r0,[sp,#4]
00008a  0882              LSRS     r2,r0,#2
00008c  9800              LDR      r0,[sp,#0]
00008e  f3620082          BFI      r0,r2,#2,#1
000092  9000              STR      r0,[sp,#0]
000094  9801              LDR      r0,[sp,#4]
000096  08c2              LSRS     r2,r0,#3
000098  9800              LDR      r0,[sp,#0]
00009a  f36200c3          BFI      r0,r2,#3,#1
00009e  9000              STR      r0,[sp,#0]
0000a0  9801              LDR      r0,[sp,#4]
0000a2  0902              LSRS     r2,r0,#4
0000a4  9800              LDR      r0,[sp,#0]
0000a6  f3621004          BFI      r0,r2,#4,#1
0000aa  9000              STR      r0,[sp,#0]
0000ac  9801              LDR      r0,[sp,#4]
0000ae  0942              LSRS     r2,r0,#5
0000b0  9800              LDR      r0,[sp,#0]
0000b2  f3621045          BFI      r0,r2,#5,#1
0000b6  9000              STR      r0,[sp,#0]
0000b8  9801              LDR      r0,[sp,#4]
0000ba  0982              LSRS     r2,r0,#6
0000bc  9800              LDR      r0,[sp,#0]
0000be  f3621086          BFI      r0,r2,#6,#1
0000c2  9000              STR      r0,[sp,#0]
0000c4  9801              LDR      r0,[sp,#4]
0000c6  09c2              LSRS     r2,r0,#7
0000c8  9800              LDR      r0,[sp,#0]
0000ca  f36210df          BFI      r0,r2,#7,#25
0000ce  9000              STR      r0,[sp,#0]
0000d0  9800              LDR      r0,[sp,#0]
;;;1803   }
0000d2  bd0c              POP      {r2,r3,pc}
;;;1804   
                          ENDP


                          AREA ||i.USART_GetTxCount||, CODE, READONLY, ALIGN=1

                  USART_GetTxCount PROC
;;;1218   */
;;;1219   static uint32_t USART_GetTxCount (const USART_RESOURCES *usart) {
000000  4601              MOV      r1,r0
;;;1220   
;;;1221   #ifdef __USART_DMA_TX
;;;1222     if (usart->dma_tx) {
000002  6a88              LDR      r0,[r1,#0x28]
000004  b130              CBZ      r0,|L38.20|
;;;1223       return (usart->xfer->tx_num - DMA_ChannelTransferItemCount(usart->dma_tx->instance));
000006  6a8a              LDR      r2,[r1,#0x28]
000008  6810              LDR      r0,[r2,#0]
00000a  6842              LDR      r2,[r0,#4]
00000c  6b48              LDR      r0,[r1,#0x34]
00000e  6840              LDR      r0,[r0,#4]
000010  1a80              SUBS     r0,r0,r2
                  |L38.18|
;;;1224     } else
;;;1225   #endif
;;;1226     {
;;;1227       return usart->xfer->tx_cnt;
;;;1228     }
;;;1229   }
000012  4770              BX       lr
                  |L38.20|
000014  6b48              LDR      r0,[r1,#0x34]         ;1227
000016  6940              LDR      r0,[r0,#0x14]         ;1227
000018  e7fb              B        |L38.18|
;;;1230   
                          ENDP


                          AREA ||i.USART_IRQHandler||, CODE, READONLY, ALIGN=1

                  USART_IRQHandler PROC
;;;1877   */
;;;1878   void USART_IRQHandler (const USART_RESOURCES *usart) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;1879     uint32_t val, sr, event;
;;;1880     uint16_t data;
;;;1881   
;;;1882     // Read USART status register
;;;1883     sr = usart->reg->SR;
000006  6860              LDR      r0,[r4,#4]
000008  8806              LDRH     r6,[r0,#0]
;;;1884   
;;;1885     // Reset local variables
;;;1886     val   = 0U;
00000a  2700              MOVS     r7,#0
;;;1887     event = 0U;
00000c  2500              MOVS     r5,#0
;;;1888     data  = 0U;
00000e  46a8              MOV      r8,r5
;;;1889   
;;;1890     // Read Data register not empty
;;;1891     if (sr & USART_SR_RXNE & usart->reg->CR1) {
000010  f0060020          AND      r0,r6,#0x20
000014  6861              LDR      r1,[r4,#4]
000016  8989              LDRH     r1,[r1,#0xc]
000018  4008              ANDS     r0,r0,r1
00001a  2800              CMP      r0,#0
00001c  d060              BEQ      |L39.224|
;;;1892       // Check for RX overflow
;;;1893       if (usart->info->status.rx_busy == 0U) {
00001e  6b20              LDR      r0,[r4,#0x30]
000020  7940              LDRB     r0,[r0,#5]
000022  b938              CBNZ     r0,|L39.52|
;;;1894         // New receive has not been started
;;;1895         // Dump RX data
;;;1896         usart->reg->DR;
000024  6860              LDR      r0,[r4,#4]
000026  8880              LDRH     r0,[r0,#4]
;;;1897         usart->info->status.rx_overflow = 1;
000028  2101              MOVS     r1,#1
00002a  6b20              LDR      r0,[r4,#0x30]
00002c  71c1              STRB     r1,[r0,#7]
;;;1898         event |= ARM_USART_EVENT_RX_OVERFLOW;
00002e  f0450520          ORR      r5,r5,#0x20
000032  e055              B        |L39.224|
                  |L39.52|
;;;1899       } else {
;;;1900         if ((usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER)  &&
000034  6b20              LDR      r0,[r4,#0x30]
000036  68c0              LDR      r0,[r0,#0xc]
000038  2802              CMP      r0,#2
00003a  d106              BNE      |L39.74|
;;;1901             (usart->xfer->sync_mode == USART_SYNC_MODE_TX)) {
00003c  6b60              LDR      r0,[r4,#0x34]
00003e  69c0              LDR      r0,[r0,#0x1c]
000040  2801              CMP      r0,#1
000042  d102              BNE      |L39.74|
;;;1902           // Dummy read in synchronous transmit only mode
;;;1903           usart->reg->DR;
000044  6860              LDR      r0,[r4,#4]
000046  8880              LDRH     r0,[r0,#4]
000048  e002              B        |L39.80|
                  |L39.74|
;;;1904         } else {
;;;1905           // Read data from RX FIFO into receive buffer
;;;1906           data = (uint16_t)usart->reg->DR;
00004a  6860              LDR      r0,[r4,#4]
00004c  f8b08004          LDRH     r8,[r0,#4]
                  |L39.80|
;;;1907         }
;;;1908   
;;;1909         *(usart->xfer->rx_buf++) = (uint8_t)data;
000050  6b60              LDR      r0,[r4,#0x34]
000052  6882              LDR      r2,[r0,#8]
000054  1c50              ADDS     r0,r2,#1
000056  6b63              LDR      r3,[r4,#0x34]
000058  6098              STR      r0,[r3,#8]
00005a  f8828000          STRB     r8,[r2,#0]
;;;1910   
;;;1911         // If nine bit data, no parity
;;;1912         val = usart->reg->CR1;
00005e  6860              LDR      r0,[r4,#4]
000060  8987              LDRH     r7,[r0,#0xc]
;;;1913         if (((val & USART_CR1_PCE) == 0U) &&
000062  f4076080          AND      r0,r7,#0x400
000066  b950              CBNZ     r0,|L39.126|
;;;1914             ((val & USART_CR1_M)   != 0U)) {
000068  f4075080          AND      r0,r7,#0x1000
00006c  b138              CBZ      r0,|L39.126|
;;;1915           *(usart->xfer->rx_buf++) = (uint8_t)(data >> 8U);
00006e  ea4f2128          ASR      r1,r8,#8
000072  6b60              LDR      r0,[r4,#0x34]
000074  6882              LDR      r2,[r0,#8]
000076  1c50              ADDS     r0,r2,#1
000078  6b63              LDR      r3,[r4,#0x34]
00007a  6098              STR      r0,[r3,#8]
00007c  7011              STRB     r1,[r2,#0]
                  |L39.126|
;;;1916         }
;;;1917         usart->xfer->rx_cnt++;
00007e  6b60              LDR      r0,[r4,#0x34]
000080  6900              LDR      r0,[r0,#0x10]
000082  1c40              ADDS     r0,r0,#1
000084  6b61              LDR      r1,[r4,#0x34]
000086  6108              STR      r0,[r1,#0x10]
;;;1918   
;;;1919         // Check if requested amount of data is received
;;;1920         if (usart->xfer->rx_cnt == usart->xfer->rx_num) {
000088  6b60              LDR      r0,[r4,#0x34]
00008a  6900              LDR      r0,[r0,#0x10]
00008c  6b61              LDR      r1,[r4,#0x34]
00008e  6809              LDR      r1,[r1,#0]
000090  4288              CMP      r0,r1
000092  d125              BNE      |L39.224|
;;;1921   
;;;1922           // Disable IDLE interrupt
;;;1923           usart->reg->CR1 &= ~USART_CR1_IDLEIE;
000094  6860              LDR      r0,[r4,#4]
000096  8980              LDRH     r0,[r0,#0xc]
000098  f0200010          BIC      r0,r0,#0x10
00009c  6861              LDR      r1,[r4,#4]
00009e  8188              STRH     r0,[r1,#0xc]
;;;1924   
;;;1925           // Clear RX busy flag and set receive transfer complete event
;;;1926           usart->info->status.rx_busy = 0U;
0000a0  2100              MOVS     r1,#0
0000a2  6b20              LDR      r0,[r4,#0x30]
0000a4  7141              STRB     r1,[r0,#5]
;;;1927           if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
0000a6  6b20              LDR      r0,[r4,#0x30]
0000a8  68c0              LDR      r0,[r0,#0xc]
0000aa  2802              CMP      r0,#2
0000ac  d116              BNE      |L39.220|
;;;1928             val = usart->xfer->sync_mode;
0000ae  6b60              LDR      r0,[r4,#0x34]
0000b0  69c7              LDR      r7,[r0,#0x1c]
;;;1929             usart->xfer->sync_mode = 0U;
0000b2  2000              MOVS     r0,#0
0000b4  6b61              LDR      r1,[r4,#0x34]
0000b6  61c8              STR      r0,[r1,#0x1c]
;;;1930             switch (val) {
0000b8  2f01              CMP      r7,#1
0000ba  d004              BEQ      |L39.198|
0000bc  2f02              CMP      r7,#2
0000be  d005              BEQ      |L39.204|
0000c0  2f03              CMP      r7,#3
0000c2  d109              BNE      |L39.216|
0000c4  e005              B        |L39.210|
                  |L39.198|
;;;1931               case USART_SYNC_MODE_TX:
;;;1932                 event |= ARM_USART_EVENT_SEND_COMPLETE;
0000c6  f0450501          ORR      r5,r5,#1
;;;1933                 break;
0000ca  e006              B        |L39.218|
                  |L39.204|
;;;1934               case USART_SYNC_MODE_RX:
;;;1935                 event |= ARM_USART_EVENT_RECEIVE_COMPLETE;
0000cc  f0450502          ORR      r5,r5,#2
;;;1936                 break;
0000d0  e003              B        |L39.218|
                  |L39.210|
;;;1937               case USART_SYNC_MODE_TX_RX:
;;;1938                 event |= ARM_USART_EVENT_TRANSFER_COMPLETE;
0000d2  f0450504          ORR      r5,r5,#4
;;;1939                 break;
0000d6  e000              B        |L39.218|
                  |L39.216|
;;;1940               default: break;
0000d8  bf00              NOP      
                  |L39.218|
0000da  e001              B        |L39.224|
                  |L39.220|
;;;1941             }
;;;1942           } else {
;;;1943             event |= ARM_USART_EVENT_RECEIVE_COMPLETE;
0000dc  f0450502          ORR      r5,r5,#2
                  |L39.224|
;;;1944           }
;;;1945         }
;;;1946       }
;;;1947     }
;;;1948   
;;;1949     // IDLE line
;;;1950     if (sr & USART_SR_IDLE & usart->reg->CR1) {
0000e0  f0060010          AND      r0,r6,#0x10
0000e4  6861              LDR      r1,[r4,#4]
0000e6  8989              LDRH     r1,[r1,#0xc]
0000e8  4008              ANDS     r0,r0,r1
0000ea  b118              CBZ      r0,|L39.244|
;;;1951       // Dummy read to clear IDLE interrupt
;;;1952       usart->reg->DR;
0000ec  6860              LDR      r0,[r4,#4]
0000ee  8880              LDRH     r0,[r0,#4]
;;;1953       event |= ARM_USART_EVENT_RX_TIMEOUT;
0000f0  f0450540          ORR      r5,r5,#0x40
                  |L39.244|
;;;1954     }
;;;1955   
;;;1956     // Transmit data register empty
;;;1957     if (sr & USART_SR_TXE & usart->reg->CR1) {
0000f4  f0060080          AND      r0,r6,#0x80
0000f8  6861              LDR      r1,[r4,#4]
0000fa  8989              LDRH     r1,[r1,#0xc]
0000fc  4008              ANDS     r0,r0,r1
0000fe  2800              CMP      r0,#0
000100  d063              BEQ      |L39.458|
;;;1958   
;;;1959       // Break handling
;;;1960       if (usart->xfer->break_flag) {
000102  6b60              LDR      r0,[r4,#0x34]
000104  f8900020          LDRB     r0,[r0,#0x20]
000108  b130              CBZ      r0,|L39.280|
;;;1961         // Send break
;;;1962         usart->reg->CR1 |= USART_CR1_SBK;
00010a  6860              LDR      r0,[r4,#4]
00010c  8980              LDRH     r0,[r0,#0xc]
00010e  f0400001          ORR      r0,r0,#1
000112  6861              LDR      r1,[r4,#4]
000114  8188              STRH     r0,[r1,#0xc]
000116  e058              B        |L39.458|
                  |L39.280|
;;;1963       } else {
;;;1964         if(usart->xfer->tx_num != usart->xfer->tx_cnt) {
000118  6b60              LDR      r0,[r4,#0x34]
00011a  6840              LDR      r0,[r0,#4]
00011c  6b61              LDR      r1,[r4,#0x34]
00011e  6949              LDR      r1,[r1,#0x14]
000120  4288              CMP      r0,r1
000122  d022              BEQ      |L39.362|
;;;1965           if ((usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) &&
000124  6b20              LDR      r0,[r4,#0x30]
000126  68c0              LDR      r0,[r0,#0xc]
000128  2802              CMP      r0,#2
00012a  d107              BNE      |L39.316|
;;;1966                (usart->xfer->sync_mode == USART_SYNC_MODE_RX)) {
00012c  6b60              LDR      r0,[r4,#0x34]
00012e  69c0              LDR      r0,[r0,#0x1c]
000130  2802              CMP      r0,#2
000132  d103              BNE      |L39.316|
;;;1967             // Dummy write in synchronous receive only mode
;;;1968             data = usart->xfer->def_val;
000134  6b60              LDR      r0,[r4,#0x34]
000136  f8b0801a          LDRH     r8,[r0,#0x1a]
00013a  e016              B        |L39.362|
                  |L39.316|
;;;1969           } else {
;;;1970             // Write data to TX FIFO
;;;1971             data = *(usart->xfer->tx_buf++);
00013c  6b60              LDR      r0,[r4,#0x34]
00013e  68c1              LDR      r1,[r0,#0xc]
000140  1c48              ADDS     r0,r1,#1
000142  6b62              LDR      r2,[r4,#0x34]
000144  60d0              STR      r0,[r2,#0xc]
000146  f8918000          LDRB     r8,[r1,#0]
;;;1972   
;;;1973             // If nine bit data, no parity
;;;1974             val = usart->reg->CR1;
00014a  6860              LDR      r0,[r4,#4]
00014c  8987              LDRH     r7,[r0,#0xc]
;;;1975             if (((val & USART_CR1_PCE) == 0U) &&
00014e  f4076080          AND      r0,r7,#0x400
000152  b950              CBNZ     r0,|L39.362|
;;;1976                 ((val & USART_CR1_M)   != 0U)) {
000154  f4075080          AND      r0,r7,#0x1000
000158  b138              CBZ      r0,|L39.362|
;;;1977               data |= *(usart->xfer->tx_buf++) << 8U;
00015a  6b60              LDR      r0,[r4,#0x34]
00015c  68c1              LDR      r1,[r0,#0xc]
00015e  1c48              ADDS     r0,r1,#1
000160  6b62              LDR      r2,[r4,#0x34]
000162  60d0              STR      r0,[r2,#0xc]
000164  7808              LDRB     r0,[r1,#0]
000166  ea482800          ORR      r8,r8,r0,LSL #8
                  |L39.362|
;;;1978             }
;;;1979           }
;;;1980         }
;;;1981         usart->xfer->tx_cnt++;
00016a  6b60              LDR      r0,[r4,#0x34]
00016c  6940              LDR      r0,[r0,#0x14]
00016e  1c40              ADDS     r0,r0,#1
000170  6b61              LDR      r1,[r4,#0x34]
000172  6148              STR      r0,[r1,#0x14]
;;;1982   
;;;1983         // Write to data register
;;;1984         usart->reg->DR = data;
000174  6860              LDR      r0,[r4,#4]
000176  f8a08004          STRH     r8,[r0,#4]
;;;1985   
;;;1986         // Check if all data is transmitted
;;;1987         if (usart->xfer->tx_num == usart->xfer->tx_cnt) {
00017a  6b60              LDR      r0,[r4,#0x34]
00017c  6840              LDR      r0,[r0,#4]
00017e  6b61              LDR      r1,[r4,#0x34]
000180  6949              LDR      r1,[r1,#0x14]
000182  4288              CMP      r0,r1
000184  d121              BNE      |L39.458|
;;;1988           // Disable TXE interrupt
;;;1989           usart->reg->CR1 &= ~USART_CR1_TXEIE;
000186  6860              LDR      r0,[r4,#4]
000188  8980              LDRH     r0,[r0,#0xc]
00018a  f0200080          BIC      r0,r0,#0x80
00018e  6861              LDR      r1,[r4,#4]
000190  8188              STRH     r0,[r1,#0xc]
;;;1990   
;;;1991           // Enable TC interrupt
;;;1992           usart->reg->CR1 |= USART_CR1_TCIE;
000192  6860              LDR      r0,[r4,#4]
000194  8980              LDRH     r0,[r0,#0xc]
000196  f0400040          ORR      r0,r0,#0x40
00019a  6861              LDR      r1,[r4,#4]
00019c  8188              STRH     r0,[r1,#0xc]
;;;1993   
;;;1994           usart->xfer->send_active = 0U;
00019e  2000              MOVS     r0,#0
0001a0  6b61              LDR      r1,[r4,#0x34]
0001a2  f8810021          STRB     r0,[r1,#0x21]
;;;1995   
;;;1996           // Set send complete event
;;;1997           if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
0001a6  6b20              LDR      r0,[r4,#0x30]
0001a8  68c0              LDR      r0,[r0,#0xc]
0001aa  2802              CMP      r0,#2
0001ac  d10b              BNE      |L39.454|
;;;1998             if ((usart->xfer->sync_mode == USART_SYNC_MODE_TX)    &&
0001ae  6b60              LDR      r0,[r4,#0x34]
0001b0  69c0              LDR      r0,[r0,#0x1c]
0001b2  2801              CMP      r0,#1
0001b4  d109              BNE      |L39.458|
;;;1999                 ((usart->info->flags & USART_FLAG_RX_ENABLED) == 0U)) {
0001b6  6b20              LDR      r0,[r4,#0x30]
0001b8  7ac0              LDRB     r0,[r0,#0xb]
0001ba  f0000010          AND      r0,r0,#0x10
0001be  b920              CBNZ     r0,|L39.458|
;;;2000               event |= ARM_USART_EVENT_SEND_COMPLETE;
0001c0  f0450501          ORR      r5,r5,#1
0001c4  e001              B        |L39.458|
                  |L39.454|
;;;2001             }
;;;2002           } else {
;;;2003             event |= ARM_USART_EVENT_SEND_COMPLETE;
0001c6  f0450501          ORR      r5,r5,#1
                  |L39.458|
;;;2004           }
;;;2005         }
;;;2006       }
;;;2007     }
;;;2008   
;;;2009     // Transmission complete
;;;2010     if (sr & USART_SR_TC & usart->reg->CR1) {
0001ca  f0060040          AND      r0,r6,#0x40
0001ce  6861              LDR      r1,[r4,#4]
0001d0  8989              LDRH     r1,[r1,#0xc]
0001d2  4008              ANDS     r0,r0,r1
0001d4  b138              CBZ      r0,|L39.486|
;;;2011       // Disable transmission complete interrupt
;;;2012       usart->reg->CR1 &= ~USART_CR1_TCIE;
0001d6  6860              LDR      r0,[r4,#4]
0001d8  8980              LDRH     r0,[r0,#0xc]
0001da  f0200040          BIC      r0,r0,#0x40
0001de  6861              LDR      r1,[r4,#4]
0001e0  8188              STRH     r0,[r1,#0xc]
;;;2013       event |= ARM_USART_EVENT_TX_COMPLETE;
0001e2  f0450508          ORR      r5,r5,#8
                  |L39.486|
;;;2014     }
;;;2015   
;;;2016     // RX Overrun
;;;2017     if ((sr & USART_SR_ORE) != 0U) {
0001e6  f0060008          AND      r0,r6,#8
0001ea  b130              CBZ      r0,|L39.506|
;;;2018       // Shift register has been overwritten
;;;2019       // Dummy data read to clear the ORE flag
;;;2020       usart->reg->DR;
0001ec  6860              LDR      r0,[r4,#4]
0001ee  8880              LDRH     r0,[r0,#4]
;;;2021       usart->info->status.rx_overflow = 1U;
0001f0  2101              MOVS     r1,#1
0001f2  6b20              LDR      r0,[r4,#0x30]
0001f4  71c1              STRB     r1,[r0,#7]
;;;2022       event |= ARM_USART_EVENT_RX_OVERFLOW;
0001f6  f0450520          ORR      r5,r5,#0x20
                  |L39.506|
;;;2023     }
;;;2024   
;;;2025     // Framing error
;;;2026     if ((sr & USART_SR_FE) != 0U) {
0001fa  f0060002          AND      r0,r6,#2
0001fe  b130              CBZ      r0,|L39.526|
;;;2027       // Dummy data read to clear the FE flag
;;;2028       usart->reg->DR;
000200  6860              LDR      r0,[r4,#4]
000202  8880              LDRH     r0,[r0,#4]
;;;2029       usart->info->status.rx_framing_error = 1U;
000204  2101              MOVS     r1,#1
000206  6b20              LDR      r0,[r4,#0x30]
000208  7241              STRB     r1,[r0,#9]
;;;2030       event |= ARM_USART_EVENT_RX_FRAMING_ERROR;
00020a  f4457580          ORR      r5,r5,#0x100
                  |L39.526|
;;;2031     }
;;;2032   
;;;2033     // Parity error
;;;2034     if ((sr & USART_SR_PE) != 0U) {
00020e  f0060001          AND      r0,r6,#1
000212  b130              CBZ      r0,|L39.546|
;;;2035       // Dummy data read to clear the PE flag
;;;2036       usart->reg->DR;
000214  6860              LDR      r0,[r4,#4]
000216  8880              LDRH     r0,[r0,#4]
;;;2037       usart->info->status.rx_parity_error = 1U;
000218  2101              MOVS     r1,#1
00021a  6b20              LDR      r0,[r4,#0x30]
00021c  7281              STRB     r1,[r0,#0xa]
;;;2038       event |= ARM_USART_EVENT_RX_PARITY_ERROR;
00021e  f4457500          ORR      r5,r5,#0x200
                  |L39.546|
;;;2039     }
;;;2040   
;;;2041     // Break Detection
;;;2042     if ((sr & USART_SR_LBD) != 0U) {
000222  f4067080          AND      r0,r6,#0x100
000226  b150              CBZ      r0,|L39.574|
;;;2043       // Clear Break detection flag
;;;2044       usart->reg->SR &= ~USART_SR_LBD;
000228  6860              LDR      r0,[r4,#4]
00022a  8800              LDRH     r0,[r0,#0]
00022c  f4207080          BIC      r0,r0,#0x100
000230  6861              LDR      r1,[r4,#4]
000232  8008              STRH     r0,[r1,#0]
;;;2045   
;;;2046       usart->info->status.rx_break = 1U;
000234  2101              MOVS     r1,#1
000236  6b20              LDR      r0,[r4,#0x30]
000238  7201              STRB     r1,[r0,#8]
;;;2047       event |= ARM_USART_EVENT_RX_BREAK;
00023a  f0450580          ORR      r5,r5,#0x80
                  |L39.574|
;;;2048     }
;;;2049   
;;;2050     // CTS changed
;;;2051     if ((sr & USART_SR_CTS) != 0U) {
00023e  f4067000          AND      r0,r6,#0x200
000242  b138              CBZ      r0,|L39.596|
;;;2052       // Clear CTS flag
;;;2053       usart->reg->SR &= ~USART_SR_CTS;
000244  6860              LDR      r0,[r4,#4]
000246  8800              LDRH     r0,[r0,#0]
000248  f4207000          BIC      r0,r0,#0x200
00024c  6861              LDR      r1,[r4,#4]
00024e  8008              STRH     r0,[r1,#0]
;;;2054   
;;;2055       event |= ARM_USART_EVENT_CTS;
000250  f4456580          ORR      r5,r5,#0x400
                  |L39.596|
;;;2056     }
;;;2057   
;;;2058     // Send Event
;;;2059     if ((event && usart->info->cb_event) != 0U) {
000254  b125              CBZ      r5,|L39.608|
000256  6b20              LDR      r0,[r4,#0x30]
000258  6800              LDR      r0,[r0,#0]
00025a  b108              CBZ      r0,|L39.608|
00025c  2001              MOVS     r0,#1
00025e  e000              B        |L39.610|
                  |L39.608|
000260  2000              MOVS     r0,#0
                  |L39.610|
000262  b118              CBZ      r0,|L39.620|
;;;2060       usart->info->cb_event (event);
000264  6b20              LDR      r0,[r4,#0x30]
000266  6801              LDR      r1,[r0,#0]
000268  4628              MOV      r0,r5
00026a  4788              BLX      r1
                  |L39.620|
;;;2061     }
;;;2062   }
00026c  e8bd81f0          POP      {r4-r8,pc}
;;;2063   
                          ENDP


                          AREA ||i.USART_Initialize||, CODE, READONLY, ALIGN=1

                  USART_Initialize PROC
;;;752    */
;;;753    static int32_t USART_Initialize (      ARM_USART_SignalEvent_t  cb_event,
000000  b570              PUSH     {r4-r6,lr}
;;;754                                     const USART_RESOURCES         *usart) {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;755    
;;;756      if (usart->info->flags & USART_FLAG_INITIALIZED) {
000006  6b20              LDR      r0,[r4,#0x30]
000008  7ac0              LDRB     r0,[r0,#0xb]
00000a  f0000001          AND      r0,r0,#1
00000e  b108              CBZ      r0,|L40.20|
;;;757        // Driver is already initialized
;;;758        return ARM_DRIVER_OK;
000010  2000              MOVS     r0,#0
                  |L40.18|
;;;759      }
;;;760    
;;;761      // Initialize USART Run-time Resources
;;;762      usart->info->cb_event = cb_event;
;;;763    
;;;764      usart->info->status.tx_busy          = 0U;
;;;765      usart->info->status.rx_busy          = 0U;
;;;766      usart->info->status.tx_underflow     = 0U;
;;;767      usart->info->status.rx_overflow      = 0U;
;;;768      usart->info->status.rx_break         = 0U;
;;;769      usart->info->status.rx_framing_error = 0U;
;;;770      usart->info->status.rx_parity_error  = 0U;
;;;771    
;;;772      usart->info->mode        = 0U;
;;;773      usart->xfer->send_active = 0U;
;;;774    
;;;775      // Clear transfer information
;;;776      memset(usart->xfer, 0, sizeof(USART_TRANSFER_INFO));
;;;777    
;;;778      // Setup pin remap
;;;779      GPIO_AFConfigure(usart->io.afio);
;;;780    
;;;781      // Enable TX pin port clock
;;;782      if (usart->io.tx) {
;;;783        GPIO_PortClock (usart->io.tx->port, true);
;;;784      }
;;;785    
;;;786      // Enable RX pin port clock
;;;787      if (usart->io.rx) {
;;;788        GPIO_PortClock (usart->io.rx->port, true);
;;;789      }
;;;790    
;;;791      // Enable CK pin port clock
;;;792      if (usart->io.ck) {
;;;793        GPIO_PortClock (usart->io.ck->port, true);
;;;794      }
;;;795    
;;;796      // Enable RTS pin port clock
;;;797      if (usart->io.rts) {
;;;798        GPIO_PortClock (usart->io.rts->port, true);
;;;799      }
;;;800    
;;;801      // Enable CTS pin port clock
;;;802      if (usart->io.cts) {
;;;803        GPIO_PortClock (usart->io.cts->port, true);
;;;804      }
;;;805    
;;;806      usart->info->flags = USART_FLAG_INITIALIZED;
;;;807    
;;;808      return ARM_DRIVER_OK;
;;;809    }
000012  bd70              POP      {r4-r6,pc}
                  |L40.20|
000014  6b20              LDR      r0,[r4,#0x30]         ;762
000016  6005              STR      r5,[r0,#0]            ;762
000018  2000              MOVS     r0,#0                 ;764
00001a  6b21              LDR      r1,[r4,#0x30]         ;764
00001c  7108              STRB     r0,[r1,#4]            ;764
00001e  2100              MOVS     r1,#0                 ;765
000020  6b20              LDR      r0,[r4,#0x30]         ;765
000022  7141              STRB     r1,[r0,#5]            ;765
000024  6b20              LDR      r0,[r4,#0x30]         ;766
000026  7181              STRB     r1,[r0,#6]            ;766
000028  6b20              LDR      r0,[r4,#0x30]         ;767
00002a  71c1              STRB     r1,[r0,#7]            ;767
00002c  6b20              LDR      r0,[r4,#0x30]         ;768
00002e  7201              STRB     r1,[r0,#8]            ;768
000030  6b20              LDR      r0,[r4,#0x30]         ;769
000032  7241              STRB     r1,[r0,#9]            ;769
000034  6b20              LDR      r0,[r4,#0x30]         ;770
000036  7281              STRB     r1,[r0,#0xa]          ;770
000038  2000              MOVS     r0,#0                 ;772
00003a  6b21              LDR      r1,[r4,#0x30]         ;772
00003c  60c8              STR      r0,[r1,#0xc]          ;772
00003e  6b61              LDR      r1,[r4,#0x34]         ;773
000040  f8810021          STRB     r0,[r1,#0x21]         ;773
000044  2124              MOVS     r1,#0x24              ;776
000046  6b60              LDR      r0,[r4,#0x34]         ;776
000048  f7fffffe          BL       __aeabi_memclr4
00004c  8c60              LDRH     r0,[r4,#0x22]         ;779
00004e  f7fffffe          BL       GPIO_AFConfigure
000052  68e0              LDR      r0,[r4,#0xc]          ;782
000054  b120              CBZ      r0,|L40.96|
000056  68e1              LDR      r1,[r4,#0xc]          ;783
000058  6808              LDR      r0,[r1,#0]            ;783
00005a  2101              MOVS     r1,#1                 ;783
00005c  f7fffffe          BL       GPIO_PortClock
                  |L40.96|
000060  6920              LDR      r0,[r4,#0x10]         ;787
000062  b120              CBZ      r0,|L40.110|
000064  6921              LDR      r1,[r4,#0x10]         ;788
000066  6808              LDR      r0,[r1,#0]            ;788
000068  2101              MOVS     r1,#1                 ;788
00006a  f7fffffe          BL       GPIO_PortClock
                  |L40.110|
00006e  6960              LDR      r0,[r4,#0x14]         ;792
000070  b120              CBZ      r0,|L40.124|
000072  6961              LDR      r1,[r4,#0x14]         ;793
000074  6808              LDR      r0,[r1,#0]            ;793
000076  2101              MOVS     r1,#1                 ;793
000078  f7fffffe          BL       GPIO_PortClock
                  |L40.124|
00007c  69a0              LDR      r0,[r4,#0x18]         ;797
00007e  b120              CBZ      r0,|L40.138|
000080  69a1              LDR      r1,[r4,#0x18]         ;798
000082  6808              LDR      r0,[r1,#0]            ;798
000084  2101              MOVS     r1,#1                 ;798
000086  f7fffffe          BL       GPIO_PortClock
                  |L40.138|
00008a  69e0              LDR      r0,[r4,#0x1c]         ;802
00008c  b120              CBZ      r0,|L40.152|
00008e  69e1              LDR      r1,[r4,#0x1c]         ;803
000090  6808              LDR      r0,[r1,#0]            ;803
000092  2101              MOVS     r1,#1                 ;803
000094  f7fffffe          BL       GPIO_PortClock
                  |L40.152|
000098  2001              MOVS     r0,#1                 ;806
00009a  6b21              LDR      r1,[r4,#0x30]         ;806
00009c  72c8              STRB     r0,[r1,#0xb]          ;806
00009e  2000              MOVS     r0,#0                 ;808
0000a0  e7b7              B        |L40.18|
;;;810    
                          ENDP


                          AREA ||i.USART_PeripheralReset||, CODE, READONLY, ALIGN=2

                  USART_PeripheralReset PROC
;;;686    */
;;;687    static void USART_PeripheralReset (const USART_TypeDef *usart) {
000000  491d              LDR      r1,|L41.120|
;;;688    
;;;689      if (usart == USART1) { RCC->APB2RSTR |= RCC_APB2RSTR_USART1RST; }
000002  4288              CMP      r0,r1
000004  d105              BNE      |L41.18|
000006  491d              LDR      r1,|L41.124|
000008  68c9              LDR      r1,[r1,#0xc]
00000a  f4414180          ORR      r1,r1,#0x4000
00000e  4a1b              LDR      r2,|L41.124|
000010  60d1              STR      r1,[r2,#0xc]
                  |L41.18|
;;;690      if (usart == USART2) { RCC->APB1RSTR |= RCC_APB1RSTR_USART2RST; }
000012  491b              LDR      r1,|L41.128|
000014  4288              CMP      r0,r1
000016  d105              BNE      |L41.36|
000018  4918              LDR      r1,|L41.124|
00001a  6909              LDR      r1,[r1,#0x10]
00001c  f4413100          ORR      r1,r1,#0x20000
000020  4a16              LDR      r2,|L41.124|
000022  6111              STR      r1,[r2,#0x10]
                  |L41.36|
;;;691    #if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
;;;692      if (usart == USART3) { RCC->APB1RSTR |= RCC_APB1RSTR_USART3RST; }
000024  4917              LDR      r1,|L41.132|
000026  4288              CMP      r0,r1
000028  d105              BNE      |L41.54|
00002a  4914              LDR      r1,|L41.124|
00002c  6909              LDR      r1,[r1,#0x10]
00002e  f4412180          ORR      r1,r1,#0x40000
000032  4a12              LDR      r2,|L41.124|
000034  6111              STR      r1,[r2,#0x10]
                  |L41.54|
;;;693    #endif
;;;694    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;695      if (usart == UART4)  { RCC->APB1RSTR |= RCC_APB1RSTR_UART4RST;  }
;;;696      if (usart == UART5)  { RCC->APB1RSTR |= RCC_APB1RSTR_UART5RST;  }
;;;697    #endif
;;;698    
;;;699      __NOP(); __NOP(); __NOP(); __NOP();
000036  bf00              NOP      
000038  bf00              NOP      
00003a  bf00              NOP      
00003c  bf00              NOP      
;;;700    
;;;701      if (usart == USART1) { RCC->APB2RSTR &= ~RCC_APB2RSTR_USART1RST; }
00003e  490e              LDR      r1,|L41.120|
000040  4288              CMP      r0,r1
000042  d105              BNE      |L41.80|
000044  490d              LDR      r1,|L41.124|
000046  68c9              LDR      r1,[r1,#0xc]
000048  f4214180          BIC      r1,r1,#0x4000
00004c  4a0b              LDR      r2,|L41.124|
00004e  60d1              STR      r1,[r2,#0xc]
                  |L41.80|
;;;702      if (usart == USART2) { RCC->APB1RSTR &= ~RCC_APB1RSTR_USART2RST; }
000050  490b              LDR      r1,|L41.128|
000052  4288              CMP      r0,r1
000054  d105              BNE      |L41.98|
000056  4909              LDR      r1,|L41.124|
000058  6909              LDR      r1,[r1,#0x10]
00005a  f4213100          BIC      r1,r1,#0x20000
00005e  4a07              LDR      r2,|L41.124|
000060  6111              STR      r1,[r2,#0x10]
                  |L41.98|
;;;703    #if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
;;;704      if (usart == USART3) { RCC->APB1RSTR &= ~RCC_APB1RSTR_USART3RST; }
000062  4908              LDR      r1,|L41.132|
000064  4288              CMP      r0,r1
000066  d105              BNE      |L41.116|
000068  4904              LDR      r1,|L41.124|
00006a  6909              LDR      r1,[r1,#0x10]
00006c  f4212180          BIC      r1,r1,#0x40000
000070  4a02              LDR      r2,|L41.124|
000072  6111              STR      r1,[r2,#0x10]
                  |L41.116|
;;;705    #endif
;;;706    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;707      if (usart == UART4)  { RCC->APB1RSTR &= ~RCC_APB1RSTR_UART4RST;  }
;;;708      if (usart == UART5)  { RCC->APB1RSTR &= ~RCC_APB1RSTR_UART5RST;  }
;;;709    #endif
;;;710    }
000074  4770              BX       lr
;;;711    
                          ENDP

000076  0000              DCW      0x0000
                  |L41.120|
                          DCD      0x40013800
                  |L41.124|
                          DCD      0x40021000
                  |L41.128|
                          DCD      0x40004400
                  |L41.132|
                          DCD      0x40004800

                          AREA ||i.USART_PowerControl||, CODE, READONLY, ALIGN=2

                  USART_PowerControl PROC
;;;841    */
;;;842    static int32_t USART_PowerControl (      ARM_POWER_STATE  state,
000000  b570              PUSH     {r4-r6,lr}
;;;843                                       const USART_RESOURCES *usart) {
000002  4605              MOV      r5,r0
000004  460c              MOV      r4,r1
;;;844    
;;;845      switch (state) {
000006  b125              CBZ      r5,|L42.18|
000008  2d01              CMP      r5,#1
00000a  d069              BEQ      |L42.224|
00000c  2d02              CMP      r5,#2
00000e  d172              BNE      |L42.246|
000010  e069              B        |L42.230|
                  |L42.18|
;;;846        case ARM_POWER_OFF:
;;;847          // Peripheral reset
;;;848          USART_PeripheralReset (usart->reg);
000012  6860              LDR      r0,[r4,#4]
000014  f7fffffe          BL       USART_PeripheralReset
;;;849    
;;;850          NVIC_DisableIRQ (usart->irq_num);
000018  f9940024          LDRSB    r0,[r4,#0x24]
00001c  2800              CMP      r0,#0
00001e  db17              BLT      |L42.80|
000020  f000021f          AND      r2,r0,#0x1f
000024  2101              MOVS     r1,#1
000026  4091              LSLS     r1,r1,r2
000028  4a73              LDR      r2,|L42.504|
00002a  0943              LSRS     r3,r0,#5
00002c  f8421023          STR      r1,[r2,r3,LSL #2]
000030  bf00              NOP      
000032  bf00              NOP      
000034  bf00              NOP      
000036  f3bf8f4f          DSB      
00003a  bf00              NOP      
00003c  bf00              NOP      
00003e  bf00              NOP      
000040  bf00              NOP      
000042  bf00              NOP      
000044  bf00              NOP      
000046  f3bf8f6f          ISB      
00004a  bf00              NOP      
00004c  bf00              NOP      
00004e  bf00              NOP      
                  |L42.80|
000050  bf00              NOP      
;;;851    
;;;852    #ifdef __USART_DMA
;;;853          if (usart->dma_rx) {
000052  6ae0              LDR      r0,[r4,#0x2c]
000054  b120              CBZ      r0,|L42.96|
;;;854            // Deinitialize DMA
;;;855            DMA_ChannelUninitialize (usart->dma_rx->dma_num, usart->dma_rx->ch_num);
000056  6ae2              LDR      r2,[r4,#0x2c]
000058  7951              LDRB     r1,[r2,#5]
00005a  7910              LDRB     r0,[r2,#4]
00005c  f7fffffe          BL       DMA_ChannelUninitialize
                  |L42.96|
;;;856          }
;;;857    
;;;858          if (usart->dma_tx) {
000060  6aa0              LDR      r0,[r4,#0x28]
000062  b120              CBZ      r0,|L42.110|
;;;859            // Deinitialize DMA
;;;860            DMA_ChannelUninitialize (usart->dma_tx->dma_num, usart->dma_tx->ch_num);
000064  6aa2              LDR      r2,[r4,#0x28]
000066  7951              LDRB     r1,[r2,#5]
000068  7910              LDRB     r0,[r2,#4]
00006a  f7fffffe          BL       DMA_ChannelUninitialize
                  |L42.110|
;;;861          }
;;;862    #endif
;;;863    
;;;864          // Disable USART clock
;;;865          if (usart->reg == USART1) { RCC->APB2ENR &= ~RCC_APB2ENR_USART1EN; }
00006e  4963              LDR      r1,|L42.508|
000070  6860              LDR      r0,[r4,#4]
000072  4288              CMP      r0,r1
000074  d105              BNE      |L42.130|
000076  4862              LDR      r0,|L42.512|
000078  6980              LDR      r0,[r0,#0x18]
00007a  f4204080          BIC      r0,r0,#0x4000
00007e  4960              LDR      r1,|L42.512|
000080  6188              STR      r0,[r1,#0x18]
                  |L42.130|
;;;866          if (usart->reg == USART2) { RCC->APB1ENR &= ~RCC_APB1ENR_USART2EN; }
000082  4960              LDR      r1,|L42.516|
000084  6860              LDR      r0,[r4,#4]
000086  4288              CMP      r0,r1
000088  d105              BNE      |L42.150|
00008a  485d              LDR      r0,|L42.512|
00008c  69c0              LDR      r0,[r0,#0x1c]
00008e  f4203000          BIC      r0,r0,#0x20000
000092  495b              LDR      r1,|L42.512|
000094  61c8              STR      r0,[r1,#0x1c]
                  |L42.150|
;;;867    #if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
;;;868          if (usart->reg == USART3) { RCC->APB1ENR &= ~RCC_APB1ENR_USART3EN; }
000096  495c              LDR      r1,|L42.520|
000098  6860              LDR      r0,[r4,#4]
00009a  4288              CMP      r0,r1
00009c  d105              BNE      |L42.170|
00009e  4858              LDR      r0,|L42.512|
0000a0  69c0              LDR      r0,[r0,#0x1c]
0000a2  f4202080          BIC      r0,r0,#0x40000
0000a6  4956              LDR      r1,|L42.512|
0000a8  61c8              STR      r0,[r1,#0x1c]
                  |L42.170|
;;;869    #endif
;;;870    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;871          if (usart->reg == UART4)  { RCC->APB1ENR &= ~RCC_APB1ENR_UART4EN;  }
;;;872          if (usart->reg == UART5)  { RCC->APB1ENR &= ~RCC_APB1ENR_UART5EN;  }
;;;873    #endif
;;;874    
;;;875          // Clear Status flags
;;;876          usart->info->status.tx_busy          = 0U;
0000aa  2000              MOVS     r0,#0
0000ac  6b21              LDR      r1,[r4,#0x30]
0000ae  7108              STRB     r0,[r1,#4]
;;;877          usart->info->status.rx_busy          = 0U;
0000b0  2100              MOVS     r1,#0
0000b2  6b20              LDR      r0,[r4,#0x30]
0000b4  7141              STRB     r1,[r0,#5]
;;;878          usart->info->status.tx_underflow     = 0U;
0000b6  6b20              LDR      r0,[r4,#0x30]
0000b8  7181              STRB     r1,[r0,#6]
;;;879          usart->info->status.rx_overflow      = 0U;
0000ba  6b20              LDR      r0,[r4,#0x30]
0000bc  71c1              STRB     r1,[r0,#7]
;;;880          usart->info->status.rx_break         = 0U;
0000be  6b20              LDR      r0,[r4,#0x30]
0000c0  7201              STRB     r1,[r0,#8]
;;;881          usart->info->status.rx_framing_error = 0U;
0000c2  6b20              LDR      r0,[r4,#0x30]
0000c4  7241              STRB     r1,[r0,#9]
;;;882          usart->info->status.rx_parity_error  = 0U;
0000c6  6b20              LDR      r0,[r4,#0x30]
0000c8  7281              STRB     r1,[r0,#0xa]
;;;883          usart->xfer->send_active             = 0U;
0000ca  2000              MOVS     r0,#0
0000cc  6b61              LDR      r1,[r4,#0x34]
0000ce  f8810021          STRB     r0,[r1,#0x21]
;;;884    
;;;885          usart->info->flags &= ~USART_FLAG_POWERED;
0000d2  6b20              LDR      r0,[r4,#0x30]
0000d4  7ac0              LDRB     r0,[r0,#0xb]
0000d6  f0200002          BIC      r0,r0,#2
0000da  6b21              LDR      r1,[r4,#0x30]
0000dc  72c8              STRB     r0,[r1,#0xb]
;;;886          break;
0000de  e087              B        |L42.496|
                  |L42.224|
;;;887    
;;;888        case ARM_POWER_LOW:
;;;889          return ARM_DRIVER_ERROR_UNSUPPORTED;
0000e0  f06f0003          MVN      r0,#3
                  |L42.228|
;;;890    
;;;891        case ARM_POWER_FULL:
;;;892          if ((usart->info->flags & USART_FLAG_INITIALIZED) == 0U) {
;;;893            return ARM_DRIVER_ERROR;
;;;894          }
;;;895          if ((usart->info->flags & USART_FLAG_POWERED)     != 0U) {
;;;896            return ARM_DRIVER_OK;
;;;897          }
;;;898    
;;;899          // Clear Status flags
;;;900          usart->info->status.tx_busy          = 0U;
;;;901          usart->info->status.rx_busy          = 0U;
;;;902          usart->info->status.tx_underflow     = 0U;
;;;903          usart->info->status.rx_overflow      = 0U;
;;;904          usart->info->status.rx_break         = 0U;
;;;905          usart->info->status.rx_framing_error = 0U;
;;;906          usart->info->status.rx_parity_error  = 0U;
;;;907    
;;;908          usart->xfer->send_active             = 0U;
;;;909          usart->xfer->def_val                 = 0U;
;;;910          usart->xfer->sync_mode               = 0U;
;;;911          usart->xfer->break_flag              = 0U;
;;;912          usart->info->mode                    = 0U;
;;;913          usart->info->flow_control            = 0U;
;;;914    
;;;915          usart->info->flags = USART_FLAG_POWERED | USART_FLAG_INITIALIZED;
;;;916    
;;;917          // Enable USART clock
;;;918          if (usart->reg == USART1) { RCC->APB2ENR |= RCC_APB2ENR_USART1EN; }
;;;919          if (usart->reg == USART2) { RCC->APB1ENR |= RCC_APB1ENR_USART2EN; }
;;;920    #if !defined (STM32F10X_LD) && !defined (STM32F10X_LD_VL)
;;;921          if (usart->reg == USART3) { RCC->APB1ENR |= RCC_APB1ENR_USART3EN; }
;;;922    #endif
;;;923    #if defined(STM32F10X_HD) || defined(STM32F10X_CL) || defined(STM32F10X_XL) || defined(STM32F10X_HD_VL)
;;;924          if (usart->reg == UART4)  { RCC->APB1ENR |= RCC_APB1ENR_UART4EN;  }
;;;925          if (usart->reg == UART5)  { RCC->APB1ENR |= RCC_APB1ENR_UART5EN;  }
;;;926    #endif
;;;927    
;;;928          // Clear and Enable USART IRQ
;;;929          NVIC_ClearPendingIRQ(usart->irq_num);
;;;930          NVIC_EnableIRQ(usart->irq_num);
;;;931    
;;;932    #ifdef __USART_DMA
;;;933          if (usart->dma_rx) {
;;;934             // Initialize DMA
;;;935             DMA_ChannelInitialize (usart->dma_rx->dma_num, usart->dma_rx->ch_num);
;;;936          }
;;;937    
;;;938          if (usart->dma_tx) {
;;;939            // Initialize DMA
;;;940            DMA_ChannelInitialize (usart->dma_tx->dma_num, usart->dma_tx->ch_num);
;;;941          }
;;;942    #endif
;;;943    
;;;944          // Peripheral reset
;;;945          USART_PeripheralReset (usart->reg);
;;;946        break;
;;;947        default: return ARM_DRIVER_ERROR_UNSUPPORTED;
;;;948      }
;;;949      return ARM_DRIVER_OK;
;;;950    }
0000e4  bd70              POP      {r4-r6,pc}
                  |L42.230|
0000e6  6b20              LDR      r0,[r4,#0x30]         ;892
0000e8  7ac0              LDRB     r0,[r0,#0xb]          ;892
0000ea  f0000001          AND      r0,r0,#1              ;892
0000ee  b918              CBNZ     r0,|L42.248|
0000f0  f04f30ff          MOV      r0,#0xffffffff        ;893
0000f4  e7f6              B        |L42.228|
                  |L42.246|
0000f6  e078              B        |L42.490|
                  |L42.248|
0000f8  6b20              LDR      r0,[r4,#0x30]         ;895
0000fa  7ac0              LDRB     r0,[r0,#0xb]          ;895
0000fc  f0000002          AND      r0,r0,#2              ;895
000100  b108              CBZ      r0,|L42.262|
000102  2000              MOVS     r0,#0                 ;896
000104  e7ee              B        |L42.228|
                  |L42.262|
000106  2000              MOVS     r0,#0                 ;900
000108  6b21              LDR      r1,[r4,#0x30]         ;900
00010a  7108              STRB     r0,[r1,#4]            ;900
00010c  2100              MOVS     r1,#0                 ;901
00010e  6b20              LDR      r0,[r4,#0x30]         ;901
000110  7141              STRB     r1,[r0,#5]            ;901
000112  6b20              LDR      r0,[r4,#0x30]         ;902
000114  7181              STRB     r1,[r0,#6]            ;902
000116  6b20              LDR      r0,[r4,#0x30]         ;903
000118  71c1              STRB     r1,[r0,#7]            ;903
00011a  6b20              LDR      r0,[r4,#0x30]         ;904
00011c  7201              STRB     r1,[r0,#8]            ;904
00011e  6b20              LDR      r0,[r4,#0x30]         ;905
000120  7241              STRB     r1,[r0,#9]            ;905
000122  6b20              LDR      r0,[r4,#0x30]         ;906
000124  7281              STRB     r1,[r0,#0xa]          ;906
000126  2000              MOVS     r0,#0                 ;908
000128  6b61              LDR      r1,[r4,#0x34]         ;908
00012a  f8810021          STRB     r0,[r1,#0x21]         ;908
00012e  6b61              LDR      r1,[r4,#0x34]         ;909
000130  8348              STRH     r0,[r1,#0x1a]         ;909
000132  6b61              LDR      r1,[r4,#0x34]         ;910
000134  61c8              STR      r0,[r1,#0x1c]         ;910
000136  6b61              LDR      r1,[r4,#0x34]         ;911
000138  f8810020          STRB     r0,[r1,#0x20]         ;911
00013c  6b21              LDR      r1,[r4,#0x30]         ;912
00013e  60c8              STR      r0,[r1,#0xc]          ;912
000140  6b21              LDR      r1,[r4,#0x30]         ;913
000142  6108              STR      r0,[r1,#0x10]         ;913
000144  2003              MOVS     r0,#3                 ;915
000146  6b21              LDR      r1,[r4,#0x30]         ;915
000148  72c8              STRB     r0,[r1,#0xb]          ;915
00014a  492c              LDR      r1,|L42.508|
00014c  6860              LDR      r0,[r4,#4]            ;918
00014e  4288              CMP      r0,r1                 ;918
000150  d105              BNE      |L42.350|
000152  482b              LDR      r0,|L42.512|
000154  6980              LDR      r0,[r0,#0x18]         ;918
000156  f4404080          ORR      r0,r0,#0x4000         ;918
00015a  4929              LDR      r1,|L42.512|
00015c  6188              STR      r0,[r1,#0x18]         ;918
                  |L42.350|
00015e  4929              LDR      r1,|L42.516|
000160  6860              LDR      r0,[r4,#4]            ;919
000162  4288              CMP      r0,r1                 ;919
000164  d105              BNE      |L42.370|
000166  4826              LDR      r0,|L42.512|
000168  69c0              LDR      r0,[r0,#0x1c]         ;919
00016a  f4403000          ORR      r0,r0,#0x20000        ;919
00016e  4924              LDR      r1,|L42.512|
000170  61c8              STR      r0,[r1,#0x1c]         ;919
                  |L42.370|
000172  4925              LDR      r1,|L42.520|
000174  6860              LDR      r0,[r4,#4]            ;921
000176  4288              CMP      r0,r1                 ;921
000178  d105              BNE      |L42.390|
00017a  4821              LDR      r0,|L42.512|
00017c  69c0              LDR      r0,[r0,#0x1c]         ;921
00017e  f4402080          ORR      r0,r0,#0x40000        ;921
000182  491f              LDR      r1,|L42.512|
000184  61c8              STR      r0,[r1,#0x1c]         ;921
                  |L42.390|
000186  f9940024          LDRSB    r0,[r4,#0x24]         ;929
00018a  2800              CMP      r0,#0                 ;929
00018c  db07              BLT      |L42.414|
00018e  f000021f          AND      r2,r0,#0x1f           ;929
000192  2101              MOVS     r1,#1                 ;929
000194  4091              LSLS     r1,r1,r2              ;929
000196  4a1d              LDR      r2,|L42.524|
000198  0943              LSRS     r3,r0,#5              ;929
00019a  f8421023          STR      r1,[r2,r3,LSL #2]     ;929
                  |L42.414|
00019e  bf00              NOP                            ;929
0001a0  f9940024          LDRSB    r0,[r4,#0x24]         ;930
0001a4  2800              CMP      r0,#0                 ;930
0001a6  db0d              BLT      |L42.452|
0001a8  bf00              NOP                            ;930
0001aa  bf00              NOP                            ;930
0001ac  f000021f          AND      r2,r0,#0x1f           ;930
0001b0  2101              MOVS     r1,#1                 ;930
0001b2  4091              LSLS     r1,r1,r2              ;930
0001b4  0942              LSRS     r2,r0,#5              ;930
0001b6  0092              LSLS     r2,r2,#2              ;930
0001b8  f10222e0          ADD      r2,r2,#0xe000e000     ;930
0001bc  f8c21100          STR      r1,[r2,#0x100]        ;930
0001c0  bf00              NOP                            ;930
0001c2  bf00              NOP                            ;930
                  |L42.452|
0001c4  bf00              NOP                            ;930
0001c6  6ae0              LDR      r0,[r4,#0x2c]         ;933
0001c8  b120              CBZ      r0,|L42.468|
0001ca  6ae2              LDR      r2,[r4,#0x2c]         ;935
0001cc  7951              LDRB     r1,[r2,#5]            ;935
0001ce  7910              LDRB     r0,[r2,#4]            ;935
0001d0  f7fffffe          BL       DMA_ChannelInitialize
                  |L42.468|
0001d4  6aa0              LDR      r0,[r4,#0x28]         ;938
0001d6  b120              CBZ      r0,|L42.482|
0001d8  6aa2              LDR      r2,[r4,#0x28]         ;940
0001da  7951              LDRB     r1,[r2,#5]            ;940
0001dc  7910              LDRB     r0,[r2,#4]            ;940
0001de  f7fffffe          BL       DMA_ChannelInitialize
                  |L42.482|
0001e2  6860              LDR      r0,[r4,#4]            ;945
0001e4  f7fffffe          BL       USART_PeripheralReset
0001e8  e002              B        |L42.496|
                  |L42.490|
0001ea  f06f0003          MVN      r0,#3                 ;947
0001ee  e779              B        |L42.228|
                  |L42.496|
0001f0  bf00              NOP                            ;886
0001f2  2000              MOVS     r0,#0                 ;949
0001f4  e776              B        |L42.228|
;;;951    
                          ENDP

0001f6  0000              DCW      0x0000
                  |L42.504|
                          DCD      0xe000e180
                  |L42.508|
                          DCD      0x40013800
                  |L42.512|
                          DCD      0x40021000
                  |L42.516|
                          DCD      0x40004400
                  |L42.520|
                          DCD      0x40004800
                  |L42.524|
                          DCD      0xe000e280

                          AREA ||i.USART_RX_DMA_Complete||, CODE, READONLY, ALIGN=1

                  USART_RX_DMA_Complete PROC
;;;2088   #ifdef __USART_DMA_RX
;;;2089   void USART_RX_DMA_Complete(const USART_RESOURCES *usart) {
000000  b570              PUSH     {r4-r6,lr}
000002  4604              MOV      r4,r0
;;;2090     uint32_t val, event;
;;;2091   
;;;2092     if ((DMA_ChannelTransferItemCount(usart->dma_rx->instance) != 0U) && (usart->xfer->rx_num != 0U)) {
000004  6ae1              LDR      r1,[r4,#0x2c]
000006  6808              LDR      r0,[r1,#0]
000008  6841              LDR      r1,[r0,#4]
00000a  b119              CBZ      r1,|L43.20|
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  6800              LDR      r0,[r0,#0]
000010  b100              CBZ      r0,|L43.20|
                  |L43.18|
;;;2093       // RX DMA Complete caused by receive/transfer abort
;;;2094       return;
;;;2095     }
;;;2096   
;;;2097     // Disable IDLE interrupt
;;;2098     usart->reg->CR1 &= ~USART_CR1_IDLEIE;
;;;2099   
;;;2100     event = 0U;
;;;2101   
;;;2102     if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;2103       val = usart->xfer->sync_mode;
;;;2104       usart->xfer->sync_mode = 0U;
;;;2105       switch (val) {
;;;2106         case USART_SYNC_MODE_TX:
;;;2107           event = ARM_USART_EVENT_SEND_COMPLETE;
;;;2108           break;
;;;2109         case USART_SYNC_MODE_RX:
;;;2110           event = ARM_USART_EVENT_RECEIVE_COMPLETE;
;;;2111           break;
;;;2112         case USART_SYNC_MODE_TX_RX:
;;;2113           event = ARM_USART_EVENT_TRANSFER_COMPLETE;
;;;2114            break;
;;;2115         default: break;
;;;2116       }
;;;2117     } else {
;;;2118       event = ARM_USART_EVENT_RECEIVE_COMPLETE;
;;;2119     }
;;;2120   
;;;2121     usart->xfer->rx_cnt = usart->xfer->rx_num;
;;;2122     usart->info->status.rx_busy = 0U;
;;;2123   
;;;2124     // Enable RXNE interrupt to detect RX overrun
;;;2125     usart->reg->CR1 |= USART_CR1_RXNEIE;
;;;2126   
;;;2127     if (usart->info->cb_event && event) { usart->info->cb_event (event); }
;;;2128   }
000012  bd70              POP      {r4-r6,pc}
                  |L43.20|
000014  6860              LDR      r0,[r4,#4]            ;2098
000016  8980              LDRH     r0,[r0,#0xc]          ;2098
000018  f0200010          BIC      r0,r0,#0x10           ;2098
00001c  6861              LDR      r1,[r4,#4]            ;2098
00001e  8188              STRH     r0,[r1,#0xc]          ;2098
000020  2500              MOVS     r5,#0                 ;2100
000022  6b20              LDR      r0,[r4,#0x30]         ;2102
000024  68c0              LDR      r0,[r0,#0xc]          ;2102
000026  2802              CMP      r0,#2                 ;2102
000028  d113              BNE      |L43.82|
00002a  6b60              LDR      r0,[r4,#0x34]         ;2103
00002c  69c6              LDR      r6,[r0,#0x1c]         ;2103
00002e  2000              MOVS     r0,#0                 ;2104
000030  6b61              LDR      r1,[r4,#0x34]         ;2104
000032  61c8              STR      r0,[r1,#0x1c]         ;2104
000034  2e01              CMP      r6,#1                 ;2105
000036  d004              BEQ      |L43.66|
000038  2e02              CMP      r6,#2                 ;2105
00003a  d004              BEQ      |L43.70|
00003c  2e03              CMP      r6,#3                 ;2105
00003e  d106              BNE      |L43.78|
000040  e003              B        |L43.74|
                  |L43.66|
000042  2501              MOVS     r5,#1                 ;2107
000044  e004              B        |L43.80|
                  |L43.70|
000046  2502              MOVS     r5,#2                 ;2110
000048  e002              B        |L43.80|
                  |L43.74|
00004a  2504              MOVS     r5,#4                 ;2113
00004c  e000              B        |L43.80|
                  |L43.78|
00004e  bf00              NOP                            ;2115
                  |L43.80|
000050  e000              B        |L43.84|
                  |L43.82|
000052  2502              MOVS     r5,#2                 ;2118
                  |L43.84|
000054  6b60              LDR      r0,[r4,#0x34]         ;2121
000056  6800              LDR      r0,[r0,#0]            ;2121
000058  6b61              LDR      r1,[r4,#0x34]         ;2121
00005a  6108              STR      r0,[r1,#0x10]         ;2121
00005c  2100              MOVS     r1,#0                 ;2122
00005e  6b20              LDR      r0,[r4,#0x30]         ;2122
000060  7141              STRB     r1,[r0,#5]            ;2122
000062  6860              LDR      r0,[r4,#4]            ;2125
000064  8980              LDRH     r0,[r0,#0xc]          ;2125
000066  f0400020          ORR      r0,r0,#0x20           ;2125
00006a  6861              LDR      r1,[r4,#4]            ;2125
00006c  8188              STRH     r0,[r1,#0xc]          ;2125
00006e  6b20              LDR      r0,[r4,#0x30]         ;2127
000070  6800              LDR      r0,[r0,#0]            ;2127
000072  b120              CBZ      r0,|L43.126|
000074  b11d              CBZ      r5,|L43.126|
000076  6b20              LDR      r0,[r4,#0x30]         ;2127
000078  6801              LDR      r1,[r0,#0]            ;2127
00007a  4628              MOV      r0,r5                 ;2127
00007c  4788              BLX      r1                    ;2127
                  |L43.126|
00007e  bf00              NOP      
000080  e7c7              B        |L43.18|
;;;2129   #endif
                          ENDP


                          AREA ||i.USART_Receive||, CODE, READONLY, ALIGN=1

                  USART_Receive PROC
;;;1062   */
;;;1063   static int32_t USART_Receive (      void            *data,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;1064                                       uint32_t         num,
;;;1065                                 const USART_RESOURCES *usart) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;1066   
;;;1067     int32_t  stat;
;;;1068   
;;;1069   #ifdef __USART_DMA_RX
;;;1070     uint32_t cfg, cr1;
;;;1071   #endif
;;;1072   
;;;1073     if ((data == NULL) || (num == 0U)) {
00000a  b106              CBZ      r6,|L44.14|
00000c  b91f              CBNZ     r7,|L44.22|
                  |L44.14|
;;;1074       // Invalid parameters
;;;1075       return ARM_DRIVER_ERROR_PARAMETER;
00000e  f06f0004          MVN      r0,#4
                  |L44.18|
;;;1076     }
;;;1077   
;;;1078     if ((usart->info->flags & USART_FLAG_CONFIGURED) == 0U) {
;;;1079       // USART is not configured (mode not selected)
;;;1080       return ARM_DRIVER_ERROR;
;;;1081     }
;;;1082   
;;;1083     // Check if receiver is busy
;;;1084     if (usart->info->status.rx_busy == 1U) {
;;;1085       return ARM_DRIVER_ERROR_BUSY;
;;;1086     }
;;;1087   
;;;1088     // Disable RXNE Interrupt
;;;1089     usart->reg->CR1 &= ~USART_CR1_RXNEIE;
;;;1090   
;;;1091     // Save number of data to be received
;;;1092     usart->xfer->rx_num = num;
;;;1093   
;;;1094     // Clear RX statuses
;;;1095     usart->info->status.rx_break          = 0U;
;;;1096     usart->info->status.rx_framing_error  = 0U;
;;;1097     usart->info->status.rx_overflow       = 0U;
;;;1098     usart->info->status.rx_parity_error   = 0U;
;;;1099   
;;;1100     // Save receive buffer info
;;;1101     usart->xfer->rx_buf = (uint8_t *)data;
;;;1102     usart->xfer->rx_cnt =  0U;
;;;1103   
;;;1104     // Set RX busy flag
;;;1105     usart->info->status.rx_busy = 1U;
;;;1106   
;;;1107   #ifdef __USART_DMA_RX
;;;1108   
;;;1109     cfg = DMA_MEMORY_INCREMENT;
;;;1110   
;;;1111     // Synchronous mode
;;;1112     if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;1113       if (usart->xfer->sync_mode == USART_SYNC_MODE_TX) {
;;;1114         // Dummy DMA reads (do not increment destination address)
;;;1115         cfg = 0U;
;;;1116       }
;;;1117     }
;;;1118   
;;;1119     // DMA mode
;;;1120     if (usart->dma_rx) {
;;;1121       // Configure and enable rx DMA channel
;;;1122       cfg |= ((usart->dma_rx->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;1123                DMA_PERIPHERAL_TO_MEMORY       |
;;;1124                DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;1125   
;;;1126       cr1 = usart->reg->CR1;
;;;1127       if (((cr1 & USART_CR1_M) != 0U) && ((cr1 & USART_CR1_PCE) == 0U)) {
;;;1128         // 9-bit data frame, no parity
;;;1129         cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;1130       } else {
;;;1131         // 8-bit data frame
;;;1132         cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;1133       }
;;;1134   
;;;1135       DMA_ChannelConfigure(usart->dma_rx->instance,
;;;1136                            cfg,
;;;1137                            (uint32_t)(&usart->reg->DR),
;;;1138                            (uint32_t)(uint32_t)data,
;;;1139                            num);
;;;1140       DMA_ChannelEnable(usart->dma_rx->instance);
;;;1141   
;;;1142       usart->reg->CR3 |= USART_CR3_DMAR;
;;;1143       // Enable IDLE interrupt
;;;1144       usart->reg->CR1 |= USART_CR1_IDLEIE;
;;;1145     } else
;;;1146   #endif
;;;1147     {
;;;1148       // Enable RXNE and IDLE interrupt
;;;1149       usart->reg->CR1 |= (USART_CR1_IDLEIE | USART_CR1_RXNEIE);
;;;1150     }  
;;;1151   
;;;1152     // Synchronous mode
;;;1153     if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;1154       if (usart->xfer->sync_mode == 0U) {
;;;1155         usart->xfer->sync_mode = USART_SYNC_MODE_RX;
;;;1156         // Send dummy data
;;;1157         stat = USART_Send (&usart->xfer->def_val, num, usart);
;;;1158         if (stat == ARM_DRIVER_ERROR_BUSY) { return ARM_DRIVER_ERROR_BUSY; }
;;;1159       }
;;;1160     }
;;;1161   
;;;1162     return ARM_DRIVER_OK;
;;;1163   }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L44.22|
000016  6b20              LDR      r0,[r4,#0x30]         ;1078
000018  7ac0              LDRB     r0,[r0,#0xb]          ;1078
00001a  f0000004          AND      r0,r0,#4              ;1078
00001e  b910              CBNZ     r0,|L44.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;1080
000024  e7f5              B        |L44.18|
                  |L44.38|
000026  6b20              LDR      r0,[r4,#0x30]         ;1084
000028  7940              LDRB     r0,[r0,#5]            ;1084
00002a  2801              CMP      r0,#1                 ;1084
00002c  d101              BNE      |L44.50|
00002e  1ec0              SUBS     r0,r0,#3              ;1085
000030  e7ef              B        |L44.18|
                  |L44.50|
000032  6860              LDR      r0,[r4,#4]            ;1089
000034  8980              LDRH     r0,[r0,#0xc]          ;1089
000036  f0200020          BIC      r0,r0,#0x20           ;1089
00003a  6861              LDR      r1,[r4,#4]            ;1089
00003c  8188              STRH     r0,[r1,#0xc]          ;1089
00003e  6b60              LDR      r0,[r4,#0x34]         ;1092
000040  6007              STR      r7,[r0,#0]            ;1092
000042  2100              MOVS     r1,#0                 ;1095
000044  6b20              LDR      r0,[r4,#0x30]         ;1095
000046  7201              STRB     r1,[r0,#8]            ;1095
000048  6b20              LDR      r0,[r4,#0x30]         ;1096
00004a  7241              STRB     r1,[r0,#9]            ;1096
00004c  6b20              LDR      r0,[r4,#0x30]         ;1097
00004e  71c1              STRB     r1,[r0,#7]            ;1097
000050  6b20              LDR      r0,[r4,#0x30]         ;1098
000052  7281              STRB     r1,[r0,#0xa]          ;1098
000054  6b60              LDR      r0,[r4,#0x34]         ;1101
000056  6086              STR      r6,[r0,#8]            ;1101
000058  2000              MOVS     r0,#0                 ;1102
00005a  6b61              LDR      r1,[r4,#0x34]         ;1102
00005c  6108              STR      r0,[r1,#0x10]         ;1102
00005e  2101              MOVS     r1,#1                 ;1105
000060  6b20              LDR      r0,[r4,#0x30]         ;1105
000062  7141              STRB     r1,[r0,#5]            ;1105
000064  2580              MOVS     r5,#0x80              ;1109
000066  6b20              LDR      r0,[r4,#0x30]         ;1112
000068  68c0              LDR      r0,[r0,#0xc]          ;1112
00006a  2802              CMP      r0,#2                 ;1112
00006c  d104              BNE      |L44.120|
00006e  6b60              LDR      r0,[r4,#0x34]         ;1113
000070  69c0              LDR      r0,[r0,#0x1c]         ;1113
000072  2801              CMP      r0,#1                 ;1113
000074  d100              BNE      |L44.120|
000076  2500              MOVS     r5,#0                 ;1115
                  |L44.120|
000078  6ae0              LDR      r0,[r4,#0x2c]         ;1120
00007a  b388              CBZ      r0,|L44.224|
00007c  6ae0              LDR      r0,[r4,#0x2c]         ;1122
00007e  7980              LDRB     r0,[r0,#6]            ;1122
000080  f44f5140          MOV      r1,#0x3000            ;1122
000084  ea013000          AND      r0,r1,r0,LSL #12      ;1122
000088  1c80              ADDS     r0,r0,#2              ;1122
00008a  4305              ORRS     r5,r5,r0              ;1122
00008c  6860              LDR      r0,[r4,#4]            ;1126
00008e  f8b0900c          LDRH     r9,[r0,#0xc]          ;1126
000092  f4095080          AND      r0,r9,#0x1000         ;1127
000096  b128              CBZ      r0,|L44.164|
000098  f4096080          AND      r0,r9,#0x400          ;1127
00009c  b910              CBNZ     r0,|L44.164|
00009e  f44565a0          ORR      r5,r5,#0x500          ;1129
0000a2  e000              B        |L44.166|
                  |L44.164|
0000a4  bf00              NOP                            ;1132
                  |L44.166|
0000a6  6ae2              LDR      r2,[r4,#0x2c]         ;1135
0000a8  6810              LDR      r0,[r2,#0]            ;1135
0000aa  6862              LDR      r2,[r4,#4]            ;1135
0000ac  1d11              ADDS     r1,r2,#4              ;1135
0000ae  6005              STR      r5,[r0,#0]            ;1135
0000b0  6081              STR      r1,[r0,#8]            ;1135
0000b2  60c6              STR      r6,[r0,#0xc]          ;1135
0000b4  6047              STR      r7,[r0,#4]            ;1135
0000b6  bf00              NOP                            ;1135
0000b8  6ae1              LDR      r1,[r4,#0x2c]         ;1140
0000ba  6808              LDR      r0,[r1,#0]            ;1140
0000bc  6801              LDR      r1,[r0,#0]            ;1140
0000be  f0410101          ORR      r1,r1,#1              ;1140
0000c2  6001              STR      r1,[r0,#0]            ;1140
0000c4  bf00              NOP                            ;1140
0000c6  6860              LDR      r0,[r4,#4]            ;1142
0000c8  8a80              LDRH     r0,[r0,#0x14]         ;1142
0000ca  f0400040          ORR      r0,r0,#0x40           ;1142
0000ce  6861              LDR      r1,[r4,#4]            ;1142
0000d0  8288              STRH     r0,[r1,#0x14]         ;1142
0000d2  6860              LDR      r0,[r4,#4]            ;1144
0000d4  8980              LDRH     r0,[r0,#0xc]          ;1144
0000d6  f0400010          ORR      r0,r0,#0x10           ;1144
0000da  6861              LDR      r1,[r4,#4]            ;1144
0000dc  8188              STRH     r0,[r1,#0xc]          ;1144
0000de  e006              B        |L44.238|
                  |L44.224|
0000e0  e7ff              B        |L44.226|
                  |L44.226|
0000e2  6860              LDR      r0,[r4,#4]            ;1149
0000e4  8980              LDRH     r0,[r0,#0xc]          ;1149
0000e6  f0400030          ORR      r0,r0,#0x30           ;1149
0000ea  6861              LDR      r1,[r4,#4]            ;1149
0000ec  8188              STRH     r0,[r1,#0xc]          ;1149
                  |L44.238|
0000ee  6b20              LDR      r0,[r4,#0x30]         ;1153
0000f0  68c0              LDR      r0,[r0,#0xc]          ;1153
0000f2  2802              CMP      r0,#2                 ;1153
0000f4  d113              BNE      |L44.286|
0000f6  6b60              LDR      r0,[r4,#0x34]         ;1154
0000f8  69c0              LDR      r0,[r0,#0x1c]         ;1154
0000fa  b980              CBNZ     r0,|L44.286|
0000fc  2002              MOVS     r0,#2                 ;1155
0000fe  6b61              LDR      r1,[r4,#0x34]         ;1155
000100  61c8              STR      r0,[r1,#0x1c]         ;1155
000102  6b61              LDR      r1,[r4,#0x34]         ;1157
000104  f101001a          ADD      r0,r1,#0x1a           ;1157
000108  4622              MOV      r2,r4                 ;1157
00010a  4639              MOV      r1,r7                 ;1157
00010c  f7fffffe          BL       USART_Send
000110  4680              MOV      r8,r0                 ;1157
000112  f1080002          ADD      r0,r8,#2              ;1158
000116  b910              CBNZ     r0,|L44.286|
000118  f06f0001          MVN      r0,#1                 ;1158
00011c  e779              B        |L44.18|
                  |L44.286|
00011e  2000              MOVS     r0,#0                 ;1162
000120  e777              B        |L44.18|
;;;1164   
                          ENDP


                          AREA ||i.USART_Send||, CODE, READONLY, ALIGN=1

                  USART_Send PROC
;;;961    */
;;;962    static int32_t USART_Send (const void            *data,
000000  e92d47f0          PUSH     {r4-r10,lr}
;;;963                                     uint32_t         num,
;;;964                               const USART_RESOURCES *usart) {
000004  4606              MOV      r6,r0
000006  460f              MOV      r7,r1
000008  4614              MOV      r4,r2
;;;965      int32_t  stat;
;;;966    
;;;967    #ifdef __USART_DMA_TX
;;;968      uint32_t cfg, cr1;
;;;969    #endif
;;;970    
;;;971      if ((data == NULL) || (num == 0U)) {
00000a  b106              CBZ      r6,|L45.14|
00000c  b91f              CBNZ     r7,|L45.22|
                  |L45.14|
;;;972        // Invalid parameters
;;;973        return ARM_DRIVER_ERROR_PARAMETER;
00000e  f06f0004          MVN      r0,#4
                  |L45.18|
;;;974      }
;;;975    
;;;976      if ((usart->info->flags & USART_FLAG_CONFIGURED) == 0U) {
;;;977        // USART is not configured (mode not selected)
;;;978        return ARM_DRIVER_ERROR;
;;;979      }
;;;980    
;;;981      if (usart->xfer->send_active != 0U) {
;;;982        // Send is not completed yet
;;;983        return ARM_DRIVER_ERROR_BUSY;
;;;984      }
;;;985    
;;;986      // Set Send active flag
;;;987      usart->xfer->send_active = 1U;
;;;988    
;;;989      // Save transmit buffer info
;;;990      usart->xfer->tx_buf = (uint8_t *)data;
;;;991      usart->xfer->tx_num = num;
;;;992      usart->xfer->tx_cnt = 0U;
;;;993    
;;;994    #ifdef __USART_DMA_TX
;;;995      cfg = DMA_MEMORY_INCREMENT;
;;;996    #endif
;;;997    
;;;998      // Synchronous mode
;;;999      if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;1000       if (usart->xfer->sync_mode == 0U) {
;;;1001         usart->xfer->sync_mode = USART_SYNC_MODE_TX;
;;;1002         // Start dummy reads
;;;1003         stat = USART_Receive (&usart->xfer->dump_val, num, usart);
;;;1004         if (stat == ARM_DRIVER_ERROR_BUSY) { return ARM_DRIVER_ERROR_BUSY; }
;;;1005   
;;;1006   #ifdef __USART_DMA_TX
;;;1007       } else {
;;;1008         if (usart->xfer->sync_mode == USART_SYNC_MODE_RX) {
;;;1009           // Dummy DMA writes (do not increment source address)
;;;1010           cfg = 0;
;;;1011         }
;;;1012   #endif
;;;1013       }
;;;1014     }
;;;1015   
;;;1016   #ifdef __USART_DMA_TX
;;;1017     // DMA mode
;;;1018     if (usart->dma_tx) {
;;;1019       // Configure and enable tx DMA channel
;;;1020       cfg |= ((usart->dma_tx->priority << DMA_PRIORITY_POS) & DMA_PRIORITY_MASK) |
;;;1021                DMA_READ_MEMORY                |
;;;1022                DMA_TRANSFER_COMPLETE_INTERRUPT;
;;;1023   
;;;1024       cr1 = usart->reg->CR1;
;;;1025       if (((cr1 & USART_CR1_M) != 0U) && ((cr1 & USART_CR1_PCE) == 0U)) {
;;;1026         // 9-bit data frame, no parity
;;;1027         cfg |= DMA_PERIPHERAL_DATA_16BIT | DMA_MEMORY_DATA_16BIT;
;;;1028       } else {
;;;1029         // 8-bit data frame
;;;1030         cfg |= DMA_PERIPHERAL_DATA_8BIT | DMA_MEMORY_DATA_8BIT;
;;;1031       }
;;;1032   
;;;1033       DMA_ChannelConfigure(usart->dma_tx->instance,
;;;1034                            cfg,
;;;1035                            (uint32_t)(&usart->reg->DR),
;;;1036                            (uint32_t)(uint32_t)data,
;;;1037                            num);
;;;1038       DMA_ChannelEnable(usart->dma_tx->instance);
;;;1039   
;;;1040       // DMA Enable transmitter
;;;1041       usart->reg->CR3 |= USART_CR3_DMAT;
;;;1042     } else
;;;1043   #endif
;;;1044     // Interrupt mode
;;;1045     {
;;;1046       // TXE interrupt enable
;;;1047       usart->reg->CR1 |= USART_CR1_TXEIE;
;;;1048     }
;;;1049   
;;;1050     return ARM_DRIVER_OK;
;;;1051   }
000012  e8bd87f0          POP      {r4-r10,pc}
                  |L45.22|
000016  6b20              LDR      r0,[r4,#0x30]         ;976
000018  7ac0              LDRB     r0,[r0,#0xb]          ;976
00001a  f0000004          AND      r0,r0,#4              ;976
00001e  b910              CBNZ     r0,|L45.38|
000020  f04f30ff          MOV      r0,#0xffffffff        ;978
000024  e7f5              B        |L45.18|
                  |L45.38|
000026  6b60              LDR      r0,[r4,#0x34]         ;981
000028  f8900021          LDRB     r0,[r0,#0x21]         ;981
00002c  b110              CBZ      r0,|L45.52|
00002e  f06f0001          MVN      r0,#1                 ;983
000032  e7ee              B        |L45.18|
                  |L45.52|
000034  2001              MOVS     r0,#1                 ;987
000036  6b61              LDR      r1,[r4,#0x34]         ;987
000038  f8810021          STRB     r0,[r1,#0x21]         ;987
00003c  6b60              LDR      r0,[r4,#0x34]         ;990
00003e  60c6              STR      r6,[r0,#0xc]          ;990
000040  6b60              LDR      r0,[r4,#0x34]         ;991
000042  6047              STR      r7,[r0,#4]            ;991
000044  2000              MOVS     r0,#0                 ;992
000046  6b61              LDR      r1,[r4,#0x34]         ;992
000048  6148              STR      r0,[r1,#0x14]         ;992
00004a  2580              MOVS     r5,#0x80              ;995
00004c  6b20              LDR      r0,[r4,#0x30]         ;999
00004e  68c0              LDR      r0,[r0,#0xc]          ;999
000050  2802              CMP      r0,#2                 ;999
000052  d118              BNE      |L45.134|
000054  6b60              LDR      r0,[r4,#0x34]         ;1000
000056  69c0              LDR      r0,[r0,#0x1c]         ;1000
000058  b980              CBNZ     r0,|L45.124|
00005a  2001              MOVS     r0,#1                 ;1001
00005c  6b61              LDR      r1,[r4,#0x34]         ;1001
00005e  61c8              STR      r0,[r1,#0x1c]         ;1001
000060  6b61              LDR      r1,[r4,#0x34]         ;1003
000062  f1010018          ADD      r0,r1,#0x18           ;1003
000066  4622              MOV      r2,r4                 ;1003
000068  4639              MOV      r1,r7                 ;1003
00006a  f7fffffe          BL       USART_Receive
00006e  4680              MOV      r8,r0                 ;1003
000070  f1080002          ADD      r0,r8,#2              ;1004
000074  b938              CBNZ     r0,|L45.134|
000076  f06f0001          MVN      r0,#1                 ;1004
00007a  e7ca              B        |L45.18|
                  |L45.124|
00007c  6b60              LDR      r0,[r4,#0x34]         ;1008
00007e  69c0              LDR      r0,[r0,#0x1c]         ;1008
000080  2802              CMP      r0,#2                 ;1008
000082  d100              BNE      |L45.134|
000084  2500              MOVS     r5,#0                 ;1010
                  |L45.134|
000086  6aa0              LDR      r0,[r4,#0x28]         ;1018
000088  b368              CBZ      r0,|L45.230|
00008a  6aa0              LDR      r0,[r4,#0x28]         ;1020
00008c  7980              LDRB     r0,[r0,#6]            ;1020
00008e  f44f5140          MOV      r1,#0x3000            ;1020
000092  ea013000          AND      r0,r1,r0,LSL #12      ;1020
000096  f0400010          ORR      r0,r0,#0x10           ;1020
00009a  1c80              ADDS     r0,r0,#2              ;1020
00009c  4305              ORRS     r5,r5,r0              ;1020
00009e  6860              LDR      r0,[r4,#4]            ;1024
0000a0  f8b0900c          LDRH     r9,[r0,#0xc]          ;1024
0000a4  f4095080          AND      r0,r9,#0x1000         ;1025
0000a8  b128              CBZ      r0,|L45.182|
0000aa  f4096080          AND      r0,r9,#0x400          ;1025
0000ae  b910              CBNZ     r0,|L45.182|
0000b0  f44565a0          ORR      r5,r5,#0x500          ;1027
0000b4  e000              B        |L45.184|
                  |L45.182|
0000b6  bf00              NOP                            ;1030
                  |L45.184|
0000b8  6aa2              LDR      r2,[r4,#0x28]         ;1033
0000ba  6810              LDR      r0,[r2,#0]            ;1033
0000bc  6862              LDR      r2,[r4,#4]            ;1033
0000be  1d11              ADDS     r1,r2,#4              ;1033
0000c0  6005              STR      r5,[r0,#0]            ;1033
0000c2  6081              STR      r1,[r0,#8]            ;1033
0000c4  60c6              STR      r6,[r0,#0xc]          ;1033
0000c6  6047              STR      r7,[r0,#4]            ;1033
0000c8  bf00              NOP                            ;1033
0000ca  6aa1              LDR      r1,[r4,#0x28]         ;1038
0000cc  6808              LDR      r0,[r1,#0]            ;1038
0000ce  6801              LDR      r1,[r0,#0]            ;1038
0000d0  f0410101          ORR      r1,r1,#1              ;1038
0000d4  6001              STR      r1,[r0,#0]            ;1038
0000d6  bf00              NOP                            ;1038
0000d8  6860              LDR      r0,[r4,#4]            ;1041
0000da  8a80              LDRH     r0,[r0,#0x14]         ;1041
0000dc  f0400080          ORR      r0,r0,#0x80           ;1041
0000e0  6861              LDR      r1,[r4,#4]            ;1041
0000e2  8288              STRH     r0,[r1,#0x14]         ;1041
0000e4  e005              B        |L45.242|
                  |L45.230|
0000e6  6860              LDR      r0,[r4,#4]            ;1047
0000e8  8980              LDRH     r0,[r0,#0xc]          ;1047
0000ea  f0400080          ORR      r0,r0,#0x80           ;1047
0000ee  6861              LDR      r1,[r4,#4]            ;1047
0000f0  8188              STRH     r0,[r1,#0xc]          ;1047
                  |L45.242|
0000f2  2000              MOVS     r0,#0                 ;1050
0000f4  e78d              B        |L45.18|
;;;1052   
                          ENDP


                          AREA ||i.USART_SetModemControl||, CODE, READONLY, ALIGN=1

                  USART_SetModemControl PROC
;;;1812   */
;;;1813   static int32_t USART_SetModemControl (      ARM_USART_MODEM_CONTROL  control,
000000  b570              PUSH     {r4-r6,lr}
;;;1814                                         const USART_RESOURCES         *usart) {
000002  4604              MOV      r4,r0
;;;1815   
;;;1816     switch (control) {
000004  b134              CBZ      r4,|L46.20|
000006  2c01              CMP      r4,#1
000008  d022              BEQ      |L46.80|
00000a  2c02              CMP      r4,#2
00000c  d03f              BEQ      |L46.142|
00000e  2c03              CMP      r4,#3
000010  d13c              BNE      |L46.140|
000012  e03d              B        |L46.144|
                  |L46.20|
;;;1817       case ARM_USART_RTS_CLEAR:
;;;1818         if ((usart->info->flow_control == ARM_USART_FLOW_CONTROL_NONE) ||
000014  6b08              LDR      r0,[r1,#0x30]
000016  6900              LDR      r0,[r0,#0x10]
000018  b120              CBZ      r0,|L46.36|
;;;1819             (usart->info->flow_control == ARM_USART_FLOW_CONTROL_CTS)) {
00001a  6b08              LDR      r0,[r1,#0x30]
00001c  6900              LDR      r0,[r0,#0x10]
00001e  f5b03f00          CMP      r0,#0x20000
000022  d111              BNE      |L46.72|
                  |L46.36|
;;;1820           if (usart->io.rts) {
000024  6988              LDR      r0,[r1,#0x18]
000026  b190              CBZ      r0,|L46.78|
;;;1821             GPIO_PinWrite (usart->io.rts->port, usart->io.rts->pin, 1U);
000028  698d              LDR      r5,[r1,#0x18]
00002a  88aa              LDRH     r2,[r5,#4]
00002c  2301              MOVS     r3,#1
00002e  6828              LDR      r0,[r5,#0]
000030  b11b              CBZ      r3,|L46.58|
000032  2501              MOVS     r5,#1
000034  4095              LSLS     r5,r5,r2
000036  6105              STR      r5,[r0,#0x10]
000038  e004              B        |L46.68|
                  |L46.58|
00003a  f1020510          ADD      r5,r2,#0x10
00003e  2601              MOVS     r6,#1
000040  40ae              LSLS     r6,r6,r5
000042  6106              STR      r6,[r0,#0x10]
                  |L46.68|
000044  bf00              NOP      
000046  e002              B        |L46.78|
                  |L46.72|
;;;1822           }
;;;1823         } else {
;;;1824           // Hardware RTS
;;;1825           return ARM_DRIVER_ERROR;
000048  f04f30ff          MOV      r0,#0xffffffff
                  |L46.76|
;;;1826         }
;;;1827         break;
;;;1828       case ARM_USART_RTS_SET:
;;;1829         if ((usart->info->flow_control == ARM_USART_FLOW_CONTROL_NONE) ||
;;;1830             (usart->info->flow_control == ARM_USART_FLOW_CONTROL_CTS)) {
;;;1831           if (usart->io.rts) {
;;;1832             GPIO_PinWrite (usart->io.rts->port, usart->io.rts->pin, 0U);
;;;1833           }
;;;1834         } else {
;;;1835           // Hardware RTS
;;;1836           return ARM_DRIVER_ERROR;
;;;1837         }
;;;1838         break;
;;;1839       case ARM_USART_DTR_CLEAR:
;;;1840       case ARM_USART_DTR_SET:
;;;1841       default: return ARM_DRIVER_ERROR;
;;;1842     }
;;;1843   
;;;1844     return ARM_DRIVER_OK;
;;;1845   }
00004c  bd70              POP      {r4-r6,pc}
                  |L46.78|
00004e  e022              B        |L46.150|
                  |L46.80|
000050  6b08              LDR      r0,[r1,#0x30]         ;1829
000052  6900              LDR      r0,[r0,#0x10]         ;1829
000054  b120              CBZ      r0,|L46.96|
000056  6b08              LDR      r0,[r1,#0x30]         ;1830
000058  6900              LDR      r0,[r0,#0x10]         ;1830
00005a  f5b03f00          CMP      r0,#0x20000           ;1830
00005e  d111              BNE      |L46.132|
                  |L46.96|
000060  6988              LDR      r0,[r1,#0x18]         ;1831
000062  b190              CBZ      r0,|L46.138|
000064  698d              LDR      r5,[r1,#0x18]         ;1832
000066  88aa              LDRH     r2,[r5,#4]            ;1832
000068  2300              MOVS     r3,#0                 ;1832
00006a  6828              LDR      r0,[r5,#0]            ;1832
00006c  b11b              CBZ      r3,|L46.118|
00006e  2501              MOVS     r5,#1                 ;1832
000070  4095              LSLS     r5,r5,r2              ;1832
000072  6105              STR      r5,[r0,#0x10]         ;1832
000074  e004              B        |L46.128|
                  |L46.118|
000076  f1020510          ADD      r5,r2,#0x10           ;1832
00007a  2601              MOVS     r6,#1                 ;1832
00007c  40ae              LSLS     r6,r6,r5              ;1832
00007e  6106              STR      r6,[r0,#0x10]         ;1832
                  |L46.128|
000080  bf00              NOP                            ;1832
000082  e002              B        |L46.138|
                  |L46.132|
000084  f04f30ff          MOV      r0,#0xffffffff        ;1836
000088  e7e0              B        |L46.76|
                  |L46.138|
00008a  e004              B        |L46.150|
                  |L46.140|
00008c  bf00              NOP                            ;1839
                  |L46.142|
00008e  bf00              NOP                            ;1840
                  |L46.144|
000090  f04f30ff          MOV      r0,#0xffffffff        ;1841
000094  e7da              B        |L46.76|
                  |L46.150|
000096  bf00              NOP                            ;1827
000098  2000              MOVS     r0,#0                 ;1844
00009a  e7d7              B        |L46.76|
;;;1846   
                          ENDP


                          AREA ||i.USART_TX_DMA_Complete||, CODE, READONLY, ALIGN=1

                  USART_TX_DMA_Complete PROC
;;;2064   #ifdef __USART_DMA_TX
;;;2065   void USART_TX_DMA_Complete(const USART_RESOURCES *usart) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;2066   
;;;2067     if ((DMA_ChannelTransferItemCount(usart->dma_tx->instance) != 0U) && (usart->xfer->tx_num != 0U)) {
000004  6aa1              LDR      r1,[r4,#0x28]
000006  6808              LDR      r0,[r1,#0]
000008  6841              LDR      r1,[r0,#4]
00000a  b119              CBZ      r1,|L47.20|
00000c  6b60              LDR      r0,[r4,#0x34]
00000e  6840              LDR      r0,[r0,#4]
000010  b100              CBZ      r0,|L47.20|
                  |L47.18|
;;;2068       // TX DMA Complete caused by send/transfer abort
;;;2069       return;
;;;2070     }
;;;2071   
;;;2072     usart->xfer->tx_cnt = usart->xfer->tx_num;
;;;2073     // Clear TX busy flag
;;;2074     usart->xfer->send_active = 0U;
;;;2075   
;;;2076     // TC interrupt enable
;;;2077     usart->reg->CR1 |= USART_CR1_TCIE; 
;;;2078   
;;;2079     // Set Send Complete event for asynchronous transfers
;;;2080     if (usart->info->mode != ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;2081       if (usart->info->cb_event) {
;;;2082         usart->info->cb_event (ARM_USART_EVENT_SEND_COMPLETE);
;;;2083       }
;;;2084     }
;;;2085   }
000012  bd10              POP      {r4,pc}
                  |L47.20|
000014  6b60              LDR      r0,[r4,#0x34]         ;2072
000016  6840              LDR      r0,[r0,#4]            ;2072
000018  6b61              LDR      r1,[r4,#0x34]         ;2072
00001a  6148              STR      r0,[r1,#0x14]         ;2072
00001c  2000              MOVS     r0,#0                 ;2074
00001e  6b61              LDR      r1,[r4,#0x34]         ;2074
000020  f8810021          STRB     r0,[r1,#0x21]         ;2074
000024  6860              LDR      r0,[r4,#4]            ;2077
000026  8980              LDRH     r0,[r0,#0xc]          ;2077
000028  f0400040          ORR      r0,r0,#0x40           ;2077
00002c  6861              LDR      r1,[r4,#4]            ;2077
00002e  8188              STRH     r0,[r1,#0xc]          ;2077
000030  6b20              LDR      r0,[r4,#0x30]         ;2080
000032  68c0              LDR      r0,[r0,#0xc]          ;2080
000034  2802              CMP      r0,#2                 ;2080
000036  d006              BEQ      |L47.70|
000038  6b20              LDR      r0,[r4,#0x30]         ;2081
00003a  6800              LDR      r0,[r0,#0]            ;2081
00003c  b118              CBZ      r0,|L47.70|
00003e  6b20              LDR      r0,[r4,#0x30]         ;2082
000040  6801              LDR      r1,[r0,#0]            ;2082
000042  2001              MOVS     r0,#1                 ;2082
000044  4788              BLX      r1                    ;2082
                  |L47.70|
000046  bf00              NOP      
000048  e7e3              B        |L47.18|
;;;2086   #endif
                          ENDP


                          AREA ||i.USART_Transfer||, CODE, READONLY, ALIGN=1

                  USART_Transfer PROC
;;;1176   */
;;;1177   static int32_t USART_Transfer (const void             *data_out,
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;1178                                        void             *data_in,
;;;1179                                        uint32_t          num,
;;;1180                                  const USART_RESOURCES  *usart) {
000004  4680              MOV      r8,r0
000006  460e              MOV      r6,r1
000008  4617              MOV      r7,r2
00000a  461c              MOV      r4,r3
;;;1181     int32_t status;
;;;1182   
;;;1183     if ((data_out == NULL) || (data_in == NULL) || (num == 0U)) {
00000c  f1b80f00          CMP      r8,#0
000010  d001              BEQ      |L48.22|
000012  b106              CBZ      r6,|L48.22|
000014  b91f              CBNZ     r7,|L48.30|
                  |L48.22|
;;;1184       // Invalid parameters
;;;1185       return ARM_DRIVER_ERROR_PARAMETER;
000016  f06f0004          MVN      r0,#4
                  |L48.26|
;;;1186     }
;;;1187   
;;;1188     if ((usart->info->flags & USART_FLAG_CONFIGURED) == 0U) {
;;;1189       // USART is not configured
;;;1190       return ARM_DRIVER_ERROR;
;;;1191     }
;;;1192   
;;;1193     if (usart->info->mode == ARM_USART_MODE_SYNCHRONOUS_MASTER) {
;;;1194   
;;;1195       // Set xfer mode
;;;1196       usart->xfer->sync_mode = USART_SYNC_MODE_TX_RX;
;;;1197   
;;;1198       // Receive
;;;1199       status = USART_Receive (data_in, num, usart);
;;;1200       if (status != ARM_DRIVER_OK) { return status; }
;;;1201   
;;;1202       // Send
;;;1203       status = USART_Send (data_out, num, usart);
;;;1204       if (status != ARM_DRIVER_OK) { return status; }
;;;1205   
;;;1206     } else {
;;;1207       // Only in synchronous mode
;;;1208       return ARM_DRIVER_ERROR;
;;;1209     }
;;;1210     return ARM_DRIVER_OK;
;;;1211   }
00001a  e8bd81f0          POP      {r4-r8,pc}
                  |L48.30|
00001e  6b20              LDR      r0,[r4,#0x30]         ;1188
000020  7ac0              LDRB     r0,[r0,#0xb]          ;1188
000022  f0000004          AND      r0,r0,#4              ;1188
000026  b910              CBNZ     r0,|L48.46|
000028  f04f30ff          MOV      r0,#0xffffffff        ;1190
00002c  e7f5              B        |L48.26|
                  |L48.46|
00002e  6b20              LDR      r0,[r4,#0x30]         ;1193
000030  68c0              LDR      r0,[r0,#0xc]          ;1193
000032  2802              CMP      r0,#2                 ;1193
000034  d114              BNE      |L48.96|
000036  2003              MOVS     r0,#3                 ;1196
000038  6b61              LDR      r1,[r4,#0x34]         ;1196
00003a  61c8              STR      r0,[r1,#0x1c]         ;1196
00003c  4622              MOV      r2,r4                 ;1199
00003e  4639              MOV      r1,r7                 ;1199
000040  4630              MOV      r0,r6                 ;1199
000042  f7fffffe          BL       USART_Receive
000046  4605              MOV      r5,r0                 ;1199
000048  b10d              CBZ      r5,|L48.78|
00004a  4628              MOV      r0,r5                 ;1200
00004c  e7e5              B        |L48.26|
                  |L48.78|
00004e  4622              MOV      r2,r4                 ;1203
000050  4639              MOV      r1,r7                 ;1203
000052  4640              MOV      r0,r8                 ;1203
000054  f7fffffe          BL       USART_Send
000058  4605              MOV      r5,r0                 ;1203
00005a  b125              CBZ      r5,|L48.102|
00005c  4628              MOV      r0,r5                 ;1204
00005e  e7dc              B        |L48.26|
                  |L48.96|
000060  f04f30ff          MOV      r0,#0xffffffff        ;1208
000064  e7d9              B        |L48.26|
                  |L48.102|
000066  2000              MOVS     r0,#0                 ;1210
000068  e7d7              B        |L48.26|
;;;1212   
                          ENDP


                          AREA ||i.USART_Uninitialize||, CODE, READONLY, ALIGN=1

                  USART_Uninitialize PROC
;;;816    */
;;;817    static int32_t USART_Uninitialize (const USART_RESOURCES *usart) {
000000  b510              PUSH     {r4,lr}
000002  4604              MOV      r4,r0
;;;818    
;;;819      // Unconfigure USART pins
;;;820      if (usart->io.tx)  GPIO_PinConfigure(usart->io.tx->port,  usart->io.tx->pin,  GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000004  68e0              LDR      r0,[r4,#0xc]
000006  b130              CBZ      r0,|L49.22|
000008  68e2              LDR      r2,[r4,#0xc]
00000a  8891              LDRH     r1,[r2,#4]
00000c  2300              MOVS     r3,#0
00000e  6810              LDR      r0,[r2,#0]
000010  461a              MOV      r2,r3
000012  f7fffffe          BL       GPIO_PinConfigure
                  |L49.22|
;;;821      if (usart->io.rx)  GPIO_PinConfigure(usart->io.rx->port,  usart->io.rx->pin,  GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000016  6920              LDR      r0,[r4,#0x10]
000018  b130              CBZ      r0,|L49.40|
00001a  6922              LDR      r2,[r4,#0x10]
00001c  8891              LDRH     r1,[r2,#4]
00001e  2300              MOVS     r3,#0
000020  6810              LDR      r0,[r2,#0]
000022  461a              MOV      r2,r3
000024  f7fffffe          BL       GPIO_PinConfigure
                  |L49.40|
;;;822      if (usart->io.ck)  GPIO_PinConfigure(usart->io.ck->port,  usart->io.ck->pin,  GPIO_IN_ANALOG, GPIO_MODE_INPUT);
000028  6960              LDR      r0,[r4,#0x14]
00002a  b130              CBZ      r0,|L49.58|
00002c  6962              LDR      r2,[r4,#0x14]
00002e  8891              LDRH     r1,[r2,#4]
000030  2300              MOVS     r3,#0
000032  6810              LDR      r0,[r2,#0]
000034  461a              MOV      r2,r3
000036  f7fffffe          BL       GPIO_PinConfigure
                  |L49.58|
;;;823      if (usart->io.rts) GPIO_PinConfigure(usart->io.rts->port, usart->io.rts->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
00003a  69a0              LDR      r0,[r4,#0x18]
00003c  b130              CBZ      r0,|L49.76|
00003e  69a2              LDR      r2,[r4,#0x18]
000040  8891              LDRH     r1,[r2,#4]
000042  2300              MOVS     r3,#0
000044  6810              LDR      r0,[r2,#0]
000046  461a              MOV      r2,r3
000048  f7fffffe          BL       GPIO_PinConfigure
                  |L49.76|
;;;824      if (usart->io.cts) GPIO_PinConfigure(usart->io.cts->port, usart->io.cts->pin, GPIO_IN_ANALOG, GPIO_MODE_INPUT);
00004c  69e0              LDR      r0,[r4,#0x1c]
00004e  b130              CBZ      r0,|L49.94|
000050  69e2              LDR      r2,[r4,#0x1c]
000052  8891              LDRH     r1,[r2,#4]
000054  2300              MOVS     r3,#0
000056  6810              LDR      r0,[r2,#0]
000058  461a              MOV      r2,r3
00005a  f7fffffe          BL       GPIO_PinConfigure
                  |L49.94|
;;;825    
;;;826      // Unconfigure pin remap
;;;827      GPIO_AFConfigure(usart->io.afio_def);
00005e  8c20              LDRH     r0,[r4,#0x20]
000060  f7fffffe          BL       GPIO_AFConfigure
;;;828    
;;;829      // Reset USART status flags
;;;830      usart->info->flags = 0U;
000064  2000              MOVS     r0,#0
000066  6b21              LDR      r1,[r4,#0x30]
000068  72c8              STRB     r0,[r1,#0xb]
;;;831    
;;;832      return ARM_DRIVER_OK;
;;;833    }
00006a  bd10              POP      {r4,pc}
;;;834    
                          ENDP


                          AREA ||i.USARTx_GetVersion||, CODE, READONLY, ALIGN=2

                  USARTx_GetVersion PROC
;;;730    */
;;;731    static ARM_DRIVER_VERSION USARTx_GetVersion (void) {
000000  b508              PUSH     {r3,lr}
;;;732      return usart_driver_version;
000002  4802              LDR      r0,|L50.12|
000004  6800              LDR      r0,[r0,#0]  ; usart_driver_version
000006  9000              STR      r0,[sp,#0]
;;;733    }
000008  bd08              POP      {r3,pc}
;;;734    
                          ENDP

00000a  0000              DCW      0x0000
                  |L50.12|
                          DCD      usart_driver_version

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  USART1_Info
                          %        20
                  USART1_TransferInfo
                          %        36
                  USART2_Info
                          %        20
                  USART2_TransferInfo
                          %        36

                          AREA ||.constdata||, DATA, READONLY, ALIGN=2

                  usart_driver_version
000000  02030202          DCW      0x0203,0x0202
                  USART1_rx
                          DCD      0x40010800
000008  000a              DCW      0x000a
00000a  0000              DCB      0x00,0x00
                  USART1_DMA_Tx
                          DCD      0x40020044
000010  01040000          DCB      0x01,0x04,0x00,0x00
                  USART1_DMA_Rx
                          DCD      0x40020058
000018  01050000          DCB      0x01,0x05,0x00,0x00
                  USART1_Resources
00001c  39060000          DCB      0x39,0x06,0x00,0x00
                          DCD      0x40013800
                          DCD      0x044aa200
                          DCD      0x00000000
                          DCD      USART1_rx
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
00003c  00220022          DCW      0x0022,0x0022
000040  25000000          DCB      0x25,0x00,0x00,0x00
                          DCD      USART1_DMA_Tx
                          DCD      USART1_DMA_Rx
                          DCD      USART1_Info
                          DCD      USART1_TransferInfo
                  USART2_tx
                          DCD      0x40010800
000058  0002              DCW      0x0002
00005a  0000              DCB      0x00,0x00
                  USART2_rx
                          DCD      0x40010800
000060  0003              DCW      0x0003
000062  0000              DCB      0x00,0x00
                  USART2_DMA_Tx
                          DCD      0x40020080
000068  01070000          DCB      0x01,0x07,0x00,0x00
                  USART2_DMA_Rx
                          DCD      0x4002006c
000070  01060000          DCB      0x01,0x06,0x00,0x00
                  USART2_Resources
000074  39060000          DCB      0x39,0x06,0x00,0x00
                          DCD      0x40004400
                          DCD      0x02255100
                          DCD      USART2_tx
                          DCD      USART2_rx
                          DCD      0x00000000
                          DCD      0x00000000
                          DCD      0x00000000
000094  00230023          DCW      0x0023,0x0023
000098  26000000          DCB      0x26,0x00,0x00,0x00
                          DCD      USART2_DMA_Tx
                          DCD      USART2_DMA_Rx
                          DCD      USART2_Info
                          DCD      USART2_TransferInfo
                  Driver_USART1
                          DCD      USARTx_GetVersion
                          DCD      USART1_GetCapabilities
                          DCD      USART1_Initialize
                          DCD      USART1_Uninitialize
                          DCD      USART1_PowerControl
                          DCD      USART1_Send
                          DCD      USART1_Receive
                          DCD      USART1_Transfer
                          DCD      USART1_GetTxCount
                          DCD      USART1_GetRxCount
                          DCD      USART1_Control
                          DCD      USART1_GetStatus
                          DCD      USART1_SetModemControl
                          DCD      USART1_GetModemStatus
                  Driver_USART2
                          DCD      USARTx_GetVersion
                          DCD      USART2_GetCapabilities
                          DCD      USART2_Initialize
                          DCD      USART2_Uninitialize
                          DCD      USART2_PowerControl
                          DCD      USART2_Send
                          DCD      USART2_Receive
                          DCD      USART2_Transfer
                          DCD      USART2_GetTxCount
                          DCD      USART2_GetRxCount
                          DCD      USART2_Control
                          DCD      USART2_GetStatus
                          DCD      USART2_SetModemControl
                          DCD      USART2_GetModemStatus

;*** Start embedded assembler ***

#line 1 "Driver\\STM32F10x_ARM_Driver\\USART_STM32F10x.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___17_USART_STM32F10x_c_c6c549ad____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___17_USART_STM32F10x_c_c6c549ad____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___17_USART_STM32F10x_c_c6c549ad____REVSH|
#line 507
|__asm___17_USART_STM32F10x_c_c6c549ad____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___17_USART_STM32F10x_c_c6c549ad____RRX|
#line 694
|__asm___17_USART_STM32F10x_c_c6c549ad____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
