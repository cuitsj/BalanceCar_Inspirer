; generated by Component: ARM Compiler 5.06 update 7 (build 960) Tool: ArmCC [4d365d]
; commandline ArmCC [--c99 --list --split_sections --debug -c --asm --interleave -o.\usbd_user_cdc_acm.o --asm_dir=.\build\ --list_dir=.\build\ --depend=.\usbd_user_cdc_acm.d --cpu=Cortex-M3 --apcs=interwork -O0 --diag_suppress=9931 -I.\CMSIS-DAP -I.\USB -I.\User -I.\Driver\STM32F10x_ARM_Driver -I.\Driver\STM32F10x_StdPeriph_Driver\inc -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Include -IC:\Keil_v5\ARM\Pack\ARM\CMSIS\5.3.0\CMSIS\Driver\Include -ID:\Keil_v5\ARM\RV31\INC -ID:\Keil_v5\ARM\CMSIS\Include -ID:\Keil_v5\ARM\INC\ST\STM32F10x -D__MICROLIB -D__UVISION_VERSION=535 -DUSE_STDPERIPH_DRIVER -DSTM32F10X_MD -DBOARD_V1 -DSWO_PA10 -W --omf_browse=.\usbd_user_cdc_acm.crf USB\usbd_user_cdc_acm.c]
                          THUMB

                          AREA ||i.CDC_ACM_UART_to_USB||, CODE, READONLY, ALIGN=2

                  CDC_ACM_UART_to_USB PROC
;;;125    // \param[in]     arg           not used.
;;;126    void CDC_ACM_UART_to_USB(void)
000000  b538              PUSH     {r3-r5,lr}
;;;127    {
;;;128    	int32_t cnt, cnt_to_wrap;
;;;129    
;;;130    	// UART - > USB
;;;131    	if (ptrUART->GetStatus().rx_busy != 0U) {
000002  491b              LDR      r1,|L1.112|
000004  6ac8              LDR      r0,[r1,#0x2c]  ; Driver_USART2
000006  4780              BLX      r0
000008  9000              STR      r0,[sp,#0]
00000a  f3c00040          UBFX     r0,r0,#1,#1
00000e  b368              CBZ      r0,|L1.108|
;;;132    		cnt  = uart_rx_cnt;
000010  4818              LDR      r0,|L1.116|
000012  6804              LDR      r4,[r0,#0]  ; uart_rx_cnt
;;;133    		cnt += ptrUART->GetRxCount();
000014  4916              LDR      r1,|L1.112|
000016  6a48              LDR      r0,[r1,#0x24]  ; Driver_USART2
000018  4780              BLX      r0
00001a  4404              ADD      r4,r4,r0
;;;134    		cnt -= usb_tx_cnt;
00001c  4816              LDR      r0,|L1.120|
00001e  6800              LDR      r0,[r0,#0]  ; usb_tx_cnt
000020  1a24              SUBS     r4,r4,r0
;;;135    		if (cnt >= UART_BUFFER_SIZE) {
000022  f5b46f80          CMP      r4,#0x400
000026  db05              BLT      |L1.52|
;;;136    			// Dump data received on UART if USB is not consuming fast enough
;;;137    			usb_tx_cnt += cnt;
000028  4813              LDR      r0,|L1.120|
00002a  6800              LDR      r0,[r0,#0]  ; usb_tx_cnt
00002c  4420              ADD      r0,r0,r4
00002e  4912              LDR      r1,|L1.120|
000030  6008              STR      r0,[r1,#0]  ; usb_tx_cnt
;;;138    			cnt = 0U;
000032  2400              MOVS     r4,#0
                  |L1.52|
;;;139    		}
;;;140    		if (cnt > 0) {
000034  2c00              CMP      r4,#0
000036  dd19              BLE      |L1.108|
;;;141    			cnt_to_wrap = (int32_t)(UART_BUFFER_SIZE - ((uint32_t)usb_tx_cnt & (UART_BUFFER_SIZE - 1)));
000038  480f              LDR      r0,|L1.120|
00003a  6800              LDR      r0,[r0,#0]  ; usb_tx_cnt
00003c  f3c00009          UBFX     r0,r0,#0,#10
000040  f5c06580          RSB      r5,r0,#0x400
;;;142    			if (cnt > cnt_to_wrap) {
000044  42ac              CMP      r4,r5
000046  dd00              BLE      |L1.74|
;;;143    				cnt = cnt_to_wrap;
000048  462c              MOV      r4,r5
                  |L1.74|
;;;144    			}
;;;145    			cnt = USBD_CDC_ACM_DataSend(uart_rx_buf + ((uint32_t)usb_tx_cnt & (UART_BUFFER_SIZE - 1)), cnt);
00004a  490b              LDR      r1,|L1.120|
00004c  6809              LDR      r1,[r1,#0]  ; usb_tx_cnt
00004e  f3c10109          UBFX     r1,r1,#0,#10
000052  4a0a              LDR      r2,|L1.124|
000054  1888              ADDS     r0,r1,r2
000056  4621              MOV      r1,r4
000058  f7fffffe          BL       USBD_CDC_ACM_DataSend
00005c  4604              MOV      r4,r0
;;;146    			if (cnt > 0) {
00005e  2c00              CMP      r4,#0
000060  dd04              BLE      |L1.108|
;;;147    				usb_tx_cnt += cnt;
000062  4805              LDR      r0,|L1.120|
000064  6800              LDR      r0,[r0,#0]  ; usb_tx_cnt
000066  4420              ADD      r0,r0,r4
000068  4903              LDR      r1,|L1.120|
00006a  6008              STR      r0,[r1,#0]  ; usb_tx_cnt
                  |L1.108|
;;;148    			}
;;;149    		}
;;;150    	}
;;;151    }
00006c  bd38              POP      {r3-r5,pc}
;;;152    
                          ENDP

00006e  0000              DCW      0x0000
                  |L1.112|
                          DCD      Driver_USART2
                  |L1.116|
                          DCD      uart_rx_cnt
                  |L1.120|
                          DCD      usb_tx_cnt
                  |L1.124|
                          DCD      uart_rx_buf

                          AREA ||i.UART_Callback||, CODE, READONLY, ALIGN=2

                  UART_Callback PROC
;;;103    //               - ARM_USART_EVENT_RECEIVE_COMPLETE: all requested data was received
;;;104    static void UART_Callback (uint32_t event) {
000000  b570              PUSH     {r4-r6,lr}
000002  4605              MOV      r5,r0
;;;105    	int32_t cnt;
;;;106    
;;;107    	u8LedMode |= 0x02; //set LED fast flash mode when UART INT actived
000004  4812              LDR      r0,|L2.80|
000006  7800              LDRB     r0,[r0,#0]  ; u8LedMode
000008  f0400002          ORR      r0,r0,#2
00000c  4910              LDR      r1,|L2.80|
00000e  7008              STRB     r0,[r1,#0]
;;;108    	
;;;109    	if (event & ARM_USART_EVENT_RECEIVE_COMPLETE) {
000010  f0050002          AND      r0,r5,#2
000014  b158              CBZ      r0,|L2.46|
;;;110    		// UART data received, restart new reception
;;;111    		uart_rx_cnt += UART_BUFFER_SIZE;
000016  480f              LDR      r0,|L2.84|
000018  6800              LDR      r0,[r0,#0]  ; uart_rx_cnt
00001a  f5006080          ADD      r0,r0,#0x400
00001e  490d              LDR      r1,|L2.84|
000020  6008              STR      r0,[r1,#0]  ; uart_rx_cnt
;;;112    		ptrUART->Receive(uart_rx_buf, UART_BUFFER_SIZE);
000022  480d              LDR      r0,|L2.88|
000024  f44f6180          MOV      r1,#0x400
000028  6982              LDR      r2,[r0,#0x18]  ; Driver_USART2
00002a  480c              LDR      r0,|L2.92|
00002c  4790              BLX      r2
                  |L2.46|
;;;113    	}
;;;114    	
;;;115    	if (event & ARM_USART_EVENT_SEND_COMPLETE) {
00002e  f0050001          AND      r0,r5,#1
000032  b160              CBZ      r0,|L2.78|
;;;116    		// USB -> UART
;;;117    		cnt = USBD_CDC_ACM_DataRead(uart_tx_buf, UART_BUFFER_SIZE);
000034  f44f6180          MOV      r1,#0x400
000038  4809              LDR      r0,|L2.96|
00003a  f7fffffe          BL       USBD_CDC_ACM_DataRead
00003e  4604              MOV      r4,r0
;;;118    		if (cnt > 0) {
000040  2c00              CMP      r4,#0
000042  dd04              BLE      |L2.78|
;;;119    			ptrUART->Send(uart_tx_buf, (uint32_t)(cnt));
000044  4804              LDR      r0,|L2.88|
000046  4621              MOV      r1,r4
000048  6942              LDR      r2,[r0,#0x14]  ; Driver_USART2
00004a  4805              LDR      r0,|L2.96|
00004c  4790              BLX      r2
                  |L2.78|
;;;120    		}
;;;121    	}
;;;122    }
00004e  bd70              POP      {r4-r6,pc}
;;;123    
                          ENDP

                  |L2.80|
                          DCD      u8LedMode
                  |L2.84|
                          DCD      uart_rx_cnt
                  |L2.88|
                          DCD      Driver_USART2
                  |L2.92|
                          DCD      uart_rx_buf
                  |L2.96|
                          DCD      uart_tx_buf

                          AREA ||i.USBD_CDC_ACM_DataReceived||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_DataReceived PROC
;;;156    // \param[in]   len           number of bytes available to read.
;;;157    void USBD_CDC_ACM_DataReceived (uint32_t len) {
000000  b538              PUSH     {r3-r5,lr}
000002  4605              MOV      r5,r0
;;;158    	int32_t cnt;
;;;159    
;;;160    	(void)(len);
;;;161    
;;;162    	if (ptrUART->GetStatus().tx_busy == 0U) {
000004  490a              LDR      r1,|L3.48|
000006  6ac8              LDR      r0,[r1,#0x2c]  ; Driver_USART2
000008  4780              BLX      r0
00000a  9000              STR      r0,[sp,#0]
00000c  f0000001          AND      r0,r0,#1
000010  b960              CBNZ     r0,|L3.44|
;;;163    		// Start USB -> UART
;;;164    		cnt = USBD_CDC_ACM_DataRead(uart_tx_buf, UART_BUFFER_SIZE);
000012  f44f6180          MOV      r1,#0x400
000016  4807              LDR      r0,|L3.52|
000018  f7fffffe          BL       USBD_CDC_ACM_DataRead
00001c  4604              MOV      r4,r0
;;;165    		if (cnt > 0) {
00001e  2c00              CMP      r4,#0
000020  dd04              BLE      |L3.44|
;;;166    			ptrUART->Send(uart_tx_buf, (uint32_t)(cnt));
000022  4803              LDR      r0,|L3.48|
000024  4621              MOV      r1,r4
000026  6942              LDR      r2,[r0,#0x14]  ; Driver_USART2
000028  4802              LDR      r0,|L3.52|
00002a  4790              BLX      r2
                  |L3.44|
;;;167    		}
;;;168    	}
;;;169    }
00002c  bd38              POP      {r3-r5,pc}
;;;170    
                          ENDP

00002e  0000              DCW      0x0000
                  |L3.48|
                          DCD      Driver_USART2
                  |L3.52|
                          DCD      uart_tx_buf

                          AREA ||i.USBD_CDC_ACM_PortGetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortGetLineCoding PROC
;;;279    // \return      false         get line coding request not supported or not processed.
;;;280    int32_t  USBD_CDC_ACM_PortGetLineCoding (CDC_LINE_CODING *line_coding) {
000000  4601              MOV      r1,r0
;;;281    
;;;282    	// Load settings from ones stored on USBD_CDC0_ACM_SetLineCoding callback
;;;283    	*line_coding = cdc_acm_line_coding;
000002  4804              LDR      r0,|L4.20|
000004  6802              LDR      r2,[r0,#0]  ; cdc_acm_line_coding
000006  600a              STR      r2,[r1,#0]
000008  8882              LDRH     r2,[r0,#4]  ; cdc_acm_line_coding
00000a  808a              STRH     r2,[r1,#4]
00000c  7980              LDRB     r0,[r0,#6]  ; cdc_acm_line_coding
00000e  7188              STRB     r0,[r1,#6]
;;;284    
;;;285    	return (1);
000010  2001              MOVS     r0,#1
;;;286    }
000012  4770              BX       lr
;;;287    
                          ENDP

                  |L4.20|
                          DCD      cdc_acm_line_coding

                          AREA ||i.USBD_CDC_ACM_PortInitialize||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortInitialize PROC
;;;171    // Called during USBD_Initialize to initialize the USB CDC class instance (ACM).
;;;172    int32_t USBD_CDC_ACM_PortInitialize (void) {
000000  b510              PUSH     {r4,lr}
;;;173    	ptrUART->Initialize   (UART_Callback);
000002  4805              LDR      r0,|L5.24|
000004  6881              LDR      r1,[r0,#8]  ; Driver_USART2
000006  4805              LDR      r0,|L5.28|
000008  4788              BLX      r1
;;;174    	ptrUART->PowerControl (ARM_POWER_FULL);
00000a  4803              LDR      r0,|L5.24|
00000c  6901              LDR      r1,[r0,#0x10]  ; Driver_USART2
00000e  2002              MOVS     r0,#2
000010  4788              BLX      r1
;;;175    
;;;176    	return(1);
000012  2001              MOVS     r0,#1
;;;177    }
000014  bd10              POP      {r4,pc}
;;;178    
                          ENDP

000016  0000              DCW      0x0000
                  |L5.24|
                          DCD      Driver_USART2
                  |L5.28|
                          DCD      UART_Callback

                          AREA ||i.USBD_CDC_ACM_PortReset||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortReset PROC
;;;189    // Called upon USB Bus Reset Event.
;;;190    int32_t USBD_CDC_ACM_PortReset (void) {
000000  b510              PUSH     {r4,lr}
;;;191    	ptrUART->Control      (ARM_USART_ABORT_SEND,    0U);
000002  4806              LDR      r0,|L6.28|
000004  2100              MOVS     r1,#0
000006  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000008  2018              MOVS     r0,#0x18
00000a  4790              BLX      r2
;;;192    	ptrUART->Control      (ARM_USART_ABORT_RECEIVE, 0U);
00000c  4803              LDR      r0,|L6.28|
00000e  2100              MOVS     r1,#0
000010  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000012  2019              MOVS     r0,#0x19
000014  4790              BLX      r2
;;;193    
;;;194    	return (1);
000016  2001              MOVS     r0,#1
;;;195    }
000018  bd10              POP      {r4,pc}
;;;196    
                          ENDP

00001a  0000              DCW      0x0000
                  |L6.28|
                          DCD      Driver_USART2

                          AREA ||i.USBD_CDC_ACM_PortSetControlLineState||, CODE, READONLY, ALIGN=1

                  USBD_CDC_ACM_PortSetControlLineState PROC
;;;293    // \return      false         set control line state request not supported or not processed.
;;;294    int32_t  USBD_CDC_ACM_PortSetControlLineState (uint16_t state) {
000000  4601              MOV      r1,r0
;;;295    	// Add code for set control line state
;;;296    
;;;297    	(void)(state);
;;;298    
;;;299    	return (1);
000002  2001              MOVS     r0,#1
;;;300    }
000004  4770              BX       lr
;;;301    
                          ENDP


                          AREA ||i.USBD_CDC_ACM_PortSetLineCoding||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortSetLineCoding PROC
;;;200    // \return      false         set line coding request not supported or not processed.
;;;201    int32_t  USBD_CDC_ACM_PortSetLineCoding (CDC_LINE_CODING *line_coding) {
000000  e92d41f0          PUSH     {r4-r8,lr}
000004  4604              MOV      r4,r0
;;;202    	uint32_t data_bits = 0U, parity = 0U, stop_bits = 0U;
000006  2600              MOVS     r6,#0
000008  2700              MOVS     r7,#0
00000a  46b0              MOV      r8,r6
;;;203    	int32_t  status;
;;;204    
;;;205    	ptrUART->Control (ARM_USART_ABORT_SEND,    0U);
00000c  483d              LDR      r0,|L8.260|
00000e  2100              MOVS     r1,#0
000010  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000012  2018              MOVS     r0,#0x18
000014  4790              BLX      r2
;;;206    	ptrUART->Control (ARM_USART_ABORT_RECEIVE, 0U);
000016  483b              LDR      r0,|L8.260|
000018  2100              MOVS     r1,#0
00001a  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
00001c  2019              MOVS     r0,#0x19
00001e  4790              BLX      r2
;;;207    	ptrUART->Control (ARM_USART_CONTROL_TX,    0U);
000020  4838              LDR      r0,|L8.260|
000022  2100              MOVS     r1,#0
000024  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000026  2015              MOVS     r0,#0x15
000028  4790              BLX      r2
;;;208    	ptrUART->Control (ARM_USART_CONTROL_RX,    0U);
00002a  4836              LDR      r0,|L8.260|
00002c  2100              MOVS     r1,#0
00002e  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000030  2016              MOVS     r0,#0x16
000032  4790              BLX      r2
;;;209    
;;;210    	switch (line_coding->bCharFormat) {
000034  7920              LDRB     r0,[r4,#4]
000036  b120              CBZ      r0,|L8.66|
000038  2801              CMP      r0,#1
00003a  d005              BEQ      |L8.72|
00003c  2802              CMP      r0,#2
00003e  d109              BNE      |L8.84|
000040  e005              B        |L8.78|
                  |L8.66|
;;;211    	case 0:                             // 1 Stop bit
;;;212    		stop_bits = ARM_USART_STOP_BITS_1;
000042  f04f0800          MOV      r8,#0
;;;213    		break;
000046  e005              B        |L8.84|
                  |L8.72|
;;;214    	case 1:                             // 1.5 Stop bits
;;;215    		stop_bits = ARM_USART_STOP_BITS_1_5;
000048  f44f4800          MOV      r8,#0x8000
;;;216    		break;
00004c  e002              B        |L8.84|
                  |L8.78|
;;;217    	case 2:                             // 2 Stop bits
;;;218    		stop_bits = ARM_USART_STOP_BITS_2;
00004e  f44f4880          MOV      r8,#0x4000
000052  bf00              NOP                            ;210
                  |L8.84|
000054  bf00              NOP                            ;213
;;;219    	}
;;;220    
;;;221    	switch (line_coding->bParityType) {
000056  7960              LDRB     r0,[r4,#5]
000058  b120              CBZ      r0,|L8.100|
00005a  2801              CMP      r0,#1
00005c  d004              BEQ      |L8.104|
00005e  2802              CMP      r0,#2
000060  d108              BNE      |L8.116|
000062  e004              B        |L8.110|
                  |L8.100|
;;;222    	case 0:                             // None
;;;223    		parity = ARM_USART_PARITY_NONE;
000064  2700              MOVS     r7,#0
;;;224    		break;
000066  e008              B        |L8.122|
                  |L8.104|
;;;225    	case 1:                             // Odd
;;;226    		parity = ARM_USART_PARITY_ODD;
000068  f44f5700          MOV      r7,#0x2000
;;;227    		break;
00006c  e005              B        |L8.122|
                  |L8.110|
;;;228    	case 2:                             // Even
;;;229    		parity = ARM_USART_PARITY_EVEN;
00006e  f44f5780          MOV      r7,#0x1000
;;;230    		break;
000072  e002              B        |L8.122|
                  |L8.116|
;;;231    	default:
;;;232    		return (0);
000074  2000              MOVS     r0,#0
                  |L8.118|
;;;233    	}
;;;234    
;;;235    	switch (line_coding->bDataBits) {
;;;236    	case 5:
;;;237    		data_bits = ARM_USART_DATA_BITS_5;
;;;238    		break;
;;;239    	case 6:
;;;240    		data_bits = ARM_USART_DATA_BITS_6;
;;;241    		break;
;;;242    	case 7:
;;;243    		data_bits = ARM_USART_DATA_BITS_7;
;;;244    		break;
;;;245    	case 8:
;;;246    		data_bits = ARM_USART_DATA_BITS_8;
;;;247    		break;
;;;248    	default:
;;;249    		return (0);
;;;250    	}
;;;251    
;;;252    	status = ptrUART->Control(ARM_USART_MODE_ASYNCHRONOUS  |
;;;253    	data_bits                    |
;;;254    	parity                       |
;;;255    	stop_bits                    |
;;;256    	ARM_USART_FLOW_CONTROL_NONE  ,
;;;257    	line_coding->dwDTERate       );
;;;258    
;;;259    	if (status != ARM_DRIVER_OK) {
;;;260    		return (0);
;;;261    	}
;;;262    
;;;263    	// Store requested settings to local variable
;;;264    	cdc_acm_line_coding = *line_coding;
;;;265    
;;;266    	uart_rx_cnt = 0;
;;;267    	usb_tx_cnt  = 0;
;;;268    
;;;269    	ptrUART->Control (ARM_USART_CONTROL_TX, 1U);
;;;270    	ptrUART->Control (ARM_USART_CONTROL_RX, 1U);
;;;271    	ptrUART->Receive (uart_rx_buf, UART_BUFFER_SIZE);
;;;272    
;;;273    	return (1);
;;;274    }
000076  e8bd81f0          POP      {r4-r8,pc}
                  |L8.122|
00007a  bf00              NOP                            ;224
00007c  79a0              LDRB     r0,[r4,#6]            ;235
00007e  2805              CMP      r0,#5                 ;235
000080  d006              BEQ      |L8.144|
000082  2806              CMP      r0,#6                 ;235
000084  d007              BEQ      |L8.150|
000086  2807              CMP      r0,#7                 ;235
000088  d008              BEQ      |L8.156|
00008a  2808              CMP      r0,#8                 ;235
00008c  d10b              BNE      |L8.166|
00008e  e008              B        |L8.162|
                  |L8.144|
000090  f44f66a0          MOV      r6,#0x500             ;237
000094  e009              B        |L8.170|
                  |L8.150|
000096  f44f66c0          MOV      r6,#0x600             ;240
00009a  e006              B        |L8.170|
                  |L8.156|
00009c  f44f66e0          MOV      r6,#0x700             ;243
0000a0  e003              B        |L8.170|
                  |L8.162|
0000a2  2600              MOVS     r6,#0                 ;246
0000a4  e001              B        |L8.170|
                  |L8.166|
0000a6  2000              MOVS     r0,#0                 ;249
0000a8  e7e5              B        |L8.118|
                  |L8.170|
0000aa  bf00              NOP                            ;238
0000ac  6821              LDR      r1,[r4,#0]            ;252
0000ae  f0460301          ORR      r3,r6,#1              ;252
0000b2  433b              ORRS     r3,r3,r7              ;252
0000b4  ea430008          ORR      r0,r3,r8              ;252
0000b8  4b12              LDR      r3,|L8.260|
0000ba  6a9a              LDR      r2,[r3,#0x28]         ;252  ; Driver_USART2
0000bc  4790              BLX      r2                    ;252
0000be  4605              MOV      r5,r0                 ;252
0000c0  b10d              CBZ      r5,|L8.198|
0000c2  2000              MOVS     r0,#0                 ;260
0000c4  e7d7              B        |L8.118|
                  |L8.198|
0000c6  4810              LDR      r0,|L8.264|
0000c8  6821              LDR      r1,[r4,#0]            ;264
0000ca  6001              STR      r1,[r0,#0]            ;264  ; cdc_acm_line_coding
0000cc  88a1              LDRH     r1,[r4,#4]            ;264
0000ce  8081              STRH     r1,[r0,#4]            ;264
0000d0  79a1              LDRB     r1,[r4,#6]            ;264
0000d2  7181              STRB     r1,[r0,#6]            ;264
0000d4  2000              MOVS     r0,#0                 ;266
0000d6  490d              LDR      r1,|L8.268|
0000d8  6008              STR      r0,[r1,#0]            ;266  ; uart_rx_cnt
0000da  490d              LDR      r1,|L8.272|
0000dc  6008              STR      r0,[r1,#0]            ;267  ; usb_tx_cnt
0000de  4809              LDR      r0,|L8.260|
0000e0  2101              MOVS     r1,#1                 ;269
0000e2  6a82              LDR      r2,[r0,#0x28]         ;269  ; Driver_USART2
0000e4  2015              MOVS     r0,#0x15              ;269
0000e6  4790              BLX      r2                    ;269
0000e8  4806              LDR      r0,|L8.260|
0000ea  2101              MOVS     r1,#1                 ;270
0000ec  6a82              LDR      r2,[r0,#0x28]         ;270  ; Driver_USART2
0000ee  2016              MOVS     r0,#0x16              ;270
0000f0  4790              BLX      r2                    ;270
0000f2  4804              LDR      r0,|L8.260|
0000f4  f44f6180          MOV      r1,#0x400             ;271
0000f8  6982              LDR      r2,[r0,#0x18]         ;271  ; Driver_USART2
0000fa  4806              LDR      r0,|L8.276|
0000fc  4790              BLX      r2                    ;271
0000fe  2001              MOVS     r0,#1                 ;273
000100  e7b9              B        |L8.118|
;;;275    
                          ENDP

000102  0000              DCW      0x0000
                  |L8.260|
                          DCD      Driver_USART2
                  |L8.264|
                          DCD      cdc_acm_line_coding
                  |L8.268|
                          DCD      uart_rx_cnt
                  |L8.272|
                          DCD      usb_tx_cnt
                  |L8.276|
                          DCD      uart_rx_buf

                          AREA ||i.USBD_CDC_ACM_PortUninitialize||, CODE, READONLY, ALIGN=2

                  USBD_CDC_ACM_PortUninitialize PROC
;;;180    // Called during USBD_Uninitialize to de-initialize the USB CDC class instance (ACM).
;;;181    int32_t USBD_CDC_ACM_PortUninitialize (void) {
000000  b510              PUSH     {r4,lr}
;;;182    	ptrUART->Control      (ARM_USART_ABORT_RECEIVE, 0U);
000002  4807              LDR      r0,|L9.32|
000004  2100              MOVS     r1,#0
000006  6a82              LDR      r2,[r0,#0x28]  ; Driver_USART2
000008  2019              MOVS     r0,#0x19
00000a  4790              BLX      r2
;;;183    	ptrUART->PowerControl (ARM_POWER_OFF);
00000c  4804              LDR      r0,|L9.32|
00000e  6901              LDR      r1,[r0,#0x10]  ; Driver_USART2
000010  2000              MOVS     r0,#0
000012  4788              BLX      r1
;;;184    	ptrUART->Uninitialize ();
000014  4902              LDR      r1,|L9.32|
000016  68c8              LDR      r0,[r1,#0xc]  ; Driver_USART2
000018  4780              BLX      r0
;;;185    
;;;186    	return(1);
00001a  2001              MOVS     r0,#1
;;;187    }
00001c  bd10              POP      {r4,pc}
;;;188    
                          ENDP

00001e  0000              DCW      0x0000
                  |L9.32|
                          DCD      Driver_USART2

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  uart_rx_buf
                          %        1024
                  uart_tx_buf
                          %        1024

                          AREA ||.data||, DATA, ALIGN=2

                  uart_rx_cnt
                          DCD      0x00000000
                  usb_tx_cnt
                          DCD      0x00000000
                  cdc_acm_line_coding
                          DCD      0x0001c200
00000c  000000            DCB      0x00,0x00,0x00

;*** Start embedded assembler ***

#line 1 "USB\\usbd_user_cdc_acm.c"
	AREA ||.rev16_text||, CODE
	THUMB
	EXPORT |__asm___19_usbd_user_cdc_acm_c_6cc2b114____REV16|
#line 492 ".\\User\\cmsis_armcc.h"
|__asm___19_usbd_user_cdc_acm_c_6cc2b114____REV16| PROC
#line 493

 rev16 r0, r0
 bx lr
	ENDP
	AREA ||.revsh_text||, CODE
	THUMB
	EXPORT |__asm___19_usbd_user_cdc_acm_c_6cc2b114____REVSH|
#line 507
|__asm___19_usbd_user_cdc_acm_c_6cc2b114____REVSH| PROC
#line 508

 revsh r0, r0
 bx lr
	ENDP
	AREA ||.rrx_text||, CODE
	THUMB
	EXPORT |__asm___19_usbd_user_cdc_acm_c_6cc2b114____RRX|
#line 694
|__asm___19_usbd_user_cdc_acm_c_6cc2b114____RRX| PROC
#line 695

 rrx r0, r0
 bx lr
	ENDP

;*** End   embedded assembler ***
